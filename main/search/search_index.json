{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to uptool","text":"<p>Universal, Manifest-First Dependency Updater</p> <p>uptool combines the ecosystem breadth of Topgrade, the precision of Dependabot, and the flexibility of Renovate \u2014 but with a manifest-first philosophy that works across ANY project toolchain defined in configuration files.</p>"},{"location":"#why-uptool","title":"Why uptool?","text":"<p>Modern projects use dozens of tools across multiple ecosystems. uptool helps you manage:</p> <ul> <li>Language dependencies: npm packages</li> <li>Infrastructure tools: Terraform modules, Helm charts</li> <li>Development tools: pre-commit hooks, tflint plugins</li> <li>Runtime version managers: asdf (<code>.tool-versions</code>), mise (<code>mise.toml</code>)</li> </ul> <p>Each ecosystem has its own update mechanism. Keeping them all current is tedious and error-prone.</p> <p>uptool provides a unified interface to scan, plan, and update dependencies across all your manifest files.</p>"},{"location":"#manifest-first-philosophy","title":"Manifest-First Philosophy","text":"<p>Unlike traditional dependency updaters that focus on lockfiles, uptool updates manifest files directly (package.json, Chart.yaml, *.tf files, etc.), preserving your intent while keeping dependencies current.</p>"},{"location":"#the-approach","title":"The Approach","text":"<ol> <li>Update manifests first: <code>package.json</code>, <code>Chart.yaml</code>, <code>*.tf</code> files</li> <li>Use native commands when they update manifests: <code>pre-commit autoupdate</code> updates <code>.pre-commit-config.yaml</code> \u2705</li> <li>Don't use commands that only update lockfiles: <code>npm update</code> only touches <code>package-lock.json</code> \u274c</li> <li>Then optionally run native lockfile updates: <code>npm install</code>, <code>terraform init</code>, etc.</li> </ol> <p>This ensures your declared dependencies stay current, not just resolved versions.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p> Multi-Ecosystem Support</p> <p>npm, Helm, Terraform, tflint, pre-commit, asdf, mise \u2014 all in one tool</p> </li> <li> <p> Manifest-First Updates</p> <p>Updates configuration files directly, preserving formatting and comments</p> </li> <li> <p> Intelligent Version Resolution</p> <p>Queries upstream registries (npm, Terraform Registry, Helm repos, GitHub Releases)</p> </li> <li> <p> Safe by Default</p> <p>Dry-run mode, diff generation, validation before applying changes</p> </li> <li> <p> Concurrent Execution</p> <p>Parallel scanning and planning with worker pools for fast performance</p> </li> <li> <p> GitHub Action Integration</p> <p>Use as a CLI tool locally or as a GitHub Action in CI/CD pipelines</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Scan for outdated dependencies\nuptool scan\n\n# Preview available updates\nuptool plan\n\n# Apply updates with diff preview\nuptool update --diff\n\n# Filter by integration\nuptool update --only npm,terraform\n</code></pre>"},{"location":"#supported-integrations","title":"Supported Integrations","text":"Integration Status Manifest Files Registry npm \u2705 Stable <code>package.json</code> npm Registry API Helm \u2705 Stable <code>Chart.yaml</code> Helm chart repositories pre-commit \u2705 Stable <code>.pre-commit-config.yaml</code> GitHub Releases Terraform \u2705 Stable <code>*.tf</code> Terraform Registry API tflint \u2705 Stable <code>.tflint.hcl</code> GitHub Releases asdf \u26a0\ufe0f Experimental <code>.tool-versions</code> GitHub Releases (per tool) mise \u26a0\ufe0f Experimental <code>mise.toml</code>, <code>.mise.toml</code> GitHub Releases (per tool)"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to get started? Choose your path:</p> <ul> <li> <p> Installation</p> <p>Install uptool via Go, pre-built binaries, or package managers</p> </li> <li> <p> Quick Start</p> <p>Get up and running in 5 minutes with a sample project</p> </li> <li> <p> User Guide</p> <p>Deep dive into configuration, environments, and advanced usage</p> </li> <li> <p> GitHub Action</p> <p>Automate dependency updates in your CI/CD pipelines</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: santosr2/uptool</li> <li>Issues: Report a bug</li> <li>Discussions: Ask questions</li> <li>Security: See our Security Policy</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Info</p> <p>uptool is under active development. The current focus is on:</p> <ul> <li>\u2705 Stabilizing core integrations (npm, Helm, Terraform, pre-commit, tflint)</li> <li>\ud83d\udea7 Completing asdf/mise integrations (detection works, updates not yet implemented)</li> <li>\ud83d\udea7 Expanding test coverage (target: &gt;70%)</li> <li>\ud83d\udea7 Adding Python ecosystem support</li> <li>\ud83d\udcdd Improving documentation and examples</li> </ul>"},{"location":"#license","title":"License","text":"<p>uptool is released under the MIT License.</p> <p>Made with \u2764\ufe0f by the uptool contributors</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>View Full Changelog</p> <p>For the complete changelog with all releases and updates, please see:</p> <p>CHANGELOG.md on GitHub</p>"},{"location":"CHANGELOG/#about-the-changelog","title":"About the Changelog","text":"<p>The uptool changelog follows the Keep a Changelog format and adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#changelog-categories","title":"Changelog Categories","text":"<ul> <li>Added: New features</li> <li>Changed: Changes in existing functionality</li> <li>Deprecated: Soon-to-be removed features</li> <li>Removed: Removed features</li> <li>Fixed: Bug fixes</li> <li>Security: Security vulnerability fixes</li> </ul>"},{"location":"CHANGELOG/#why-visit-github","title":"Why Visit GitHub?","text":"<p>The CHANGELOG.md on GitHub is automatically generated from conventional commits and is always up-to-date with the latest releases.</p> <p>\u2192 Read the full CHANGELOG.md on GitHub</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>View Full Code of Conduct</p> <p>For the complete Code of Conduct, please see:</p> <p>CODE_OF_CONDUCT.md on GitHub</p>"},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":""},{"location":"CODE_OF_CONDUCT/#examples-of-positive-behavior","title":"Examples of Positive Behavior","text":"<ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes</li> <li>Focusing on what is best for the overall community</li> </ul>"},{"location":"CODE_OF_CONDUCT/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>The use of sexualized language or imagery, and sexual attention or advances</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>\u2192 Read the full CODE_OF_CONDUCT.md on GitHub</p>"},{"location":"CONTRIBUTING/","title":"Contributing to uptool","text":"<p>View Full Contributing Guide</p> <p>This page provides a brief overview. For the complete contributing guide, please see:</p> <p>CONTRIBUTING.md on GitHub</p>"},{"location":"CONTRIBUTING/#quick-links","title":"Quick Links","text":"<ul> <li>Development Setup: See the full guide</li> <li>Code Standards: See the full guide</li> <li>Pull Request Process: See the full guide</li> <li>Testing Requirements: See the full guide</li> </ul>"},{"location":"CONTRIBUTING/#why-visit-github","title":"Why Visit GitHub?","text":"<p>The CONTRIBUTING.md file on GitHub is the source of truth and may contain updates more recent than this documentation build. It also includes:</p> <ul> <li>Detailed development environment setup instructions</li> <li>Comprehensive coding standards and style guides</li> <li>Testing and CI/CD requirements</li> <li>Commit message conventions</li> <li>Release process details</li> </ul> <p>\u2192 Read the full CONTRIBUTING.md on GitHub</p>"},{"location":"GOVERNANCE/","title":"Project Governance","text":"<p>View Full Governance Document</p> <p>For the complete governance policy and decision-making process, please see:</p> <p>GOVERNANCE.md on GitHub</p>"},{"location":"GOVERNANCE/#overview","title":"Overview","text":"<p>uptool follows a trunk-based development workflow with transparent decision-making and community-first principles.</p>"},{"location":"GOVERNANCE/#key-principles","title":"Key Principles","text":"<ul> <li>Trunk-Based Development: All changes merge directly to <code>main</code> after review</li> <li>No Git Flow: Simple, fast-moving development process</li> <li>Community First: Open discussion and transparent decision-making</li> <li>Quality Standards: Comprehensive testing and code review requirements</li> </ul>"},{"location":"GOVERNANCE/#roles","title":"Roles","text":"<ul> <li>Maintainers: Core team members with write access</li> <li>Contributors: Community members who submit pull requests</li> <li>Users: Anyone using uptool in their projects</li> </ul>"},{"location":"GOVERNANCE/#decision-making","title":"Decision Making","text":"<ul> <li>Minor Changes: Approved by any maintainer</li> <li>Major Changes: Require discussion and consensus</li> <li>Breaking Changes: Require RFC and community feedback</li> </ul>"},{"location":"GOVERNANCE/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork and create a feature branch</li> <li>Make changes with tests</li> <li>Submit PR with clear description</li> <li>Address review feedback</li> <li>Maintainer merges after approval</li> </ol> <p>\u2192 Read the full GOVERNANCE.md on GitHub</p>"},{"location":"INTEGRATION_TEMPLATE/","title":"[Integration Name] Integration","text":"<p>Brief one-sentence description of what this integration does.</p>"},{"location":"INTEGRATION_TEMPLATE/#overview","title":"Overview","text":"<p>Integration ID: <code>integration-id</code></p> <p>Manifest Files: <code>manifest-file.ext</code></p> <p>Update Strategy: How it updates (e.g., YAML rewriting, native command, HCL parsing)</p> <p>Registry: Where it queries versions (e.g., npm Registry API, GitHub Releases)</p> <p>Status: \u2705 Stable | \ud83e\uddea Experimental</p>"},{"location":"INTEGRATION_TEMPLATE/#what-gets-updated","title":"What Gets Updated","text":"<p>Clear bullet list of what parts of the manifest are updated:</p> <ul> <li><code>section1</code> - Description</li> <li><code>section2</code> - Description</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#example","title":"Example","text":"<p>Before:</p> <pre><code># Example manifest before update\ndependency: 1.0.0\n</code></pre> <p>After:</p> <pre><code># Example manifest after update\ndependency: 1.5.0\n</code></pre>"},{"location":"INTEGRATION_TEMPLATE/#integration-specific-behavior","title":"Integration-Specific Behavior","text":"<p>Any unique behavior for this integration:</p> <ul> <li>Version constraints: How constraints are handled</li> <li>Format preservation: What formatting is preserved</li> <li>Special features: Any unique features</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#configuration","title":"Configuration","text":"<p>Example <code>uptool.yaml</code> configuration:</p> <pre><code>version: 1\n\nintegrations:\n  - id: integration-id\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"INTEGRATION_TEMPLATE/#limitations","title":"Limitations","text":"<p>(Optional section - only include if there are notable limitations)</p> <p>List any known limitations:</p> <ol> <li>Limitation name: Description and workaround</li> </ol>"},{"location":"INTEGRATION_TEMPLATE/#see-also","title":"See Also","text":"<ul> <li>CLI Reference</li> <li>Configuration Guide</li> <li>Official Documentation</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#template-guidelines","title":"Template Guidelines","text":""},{"location":"INTEGRATION_TEMPLATE/#length-target","title":"Length Target","text":"<ul> <li>Minimum: 60 lines</li> <li>Target: 80-120 lines</li> <li>Maximum: 150 lines</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#required-sections","title":"Required Sections","text":"<ol> <li>Overview (ID, files, strategy, registry, status)</li> <li>What Gets Updated (bullet list)</li> <li>Example (before/after code blocks)</li> <li>Integration-Specific Behavior</li> </ol>"},{"location":"INTEGRATION_TEMPLATE/#optional-sections","title":"Optional Sections","text":"<ul> <li>Configuration (if non-standard)</li> <li>Limitations (only if notable)</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#sections-to-avoid","title":"Sections to AVOID","text":"<ul> <li>\u274c Generic CLI usage (covered in CLI reference)</li> <li>\u274c Obvious troubleshooting (e.g., \"check internet connection\")</li> <li>\u274c Redundant registry API details</li> <li>\u274c Monorepo support (mention briefly in \"What Gets Updated\")</li> <li>\u274c Version constraint tables (show in example instead)</li> <li>\u274c Step-by-step workflows (covered in quickstart)</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#style-guidelines","title":"Style Guidelines","text":"<ul> <li>Be direct and concise</li> <li>Use tables for structured data</li> <li>Use code blocks for examples</li> <li>Link to other docs instead of duplicating content</li> <li>Focus on integration-specific details only</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>uptool is licensed under the MIT License.</p>"},{"location":"LICENSE/#mit-license","title":"MIT License","text":"<p>https://github.com/santosr2/uptool/blob/{{ extra.uptool_version }}/LICENSE</p>"},{"location":"LICENSE/#third-party-licenses","title":"Third-Party Licenses","text":"<p>uptool uses the following open-source libraries:</p>"},{"location":"LICENSE/#go-standard-library","title":"Go Standard Library","text":"<ul> <li>License: BSD-3-Clause</li> <li>Copyright: The Go Authors</li> <li>URL: https://golang.org/LICENSE</li> </ul>"},{"location":"LICENSE/#third-party-go-modules","title":"Third-Party Go Modules","text":"<p>To see a complete list of dependencies and their licenses, run:</p> <pre><code>go mod graph\n</code></pre> <p>Or generate a license report:</p> <pre><code># Install go-licenses\ngo install github.com/google/go-licenses@latest\n\n# Generate report\ngo-licenses report github.com/santosr2/uptool/cmd/uptool\n</code></pre>"},{"location":"LICENSE/#attribution","title":"Attribution","text":"<p>If you use uptool in your project, attribution is appreciated but not required.</p> <p>You may include a notice like:</p> <pre><code>This project uses uptool (https://github.com/santosr2/uptool),\nlicensed under the MIT License.\n</code></pre>"},{"location":"LICENSE/#contributing","title":"Contributing","text":"<p>By contributing to uptool, you agree that your contributions will be licensed under the MIT License.</p> <p>See CONTRIBUTING.md for contribution guidelines.</p>"},{"location":"LICENSE/#questions","title":"Questions","text":"<p>If you have questions about licensing, please open an issue on GitHub.</p>"},{"location":"SECURITY/","title":"Security Policy","text":"<p>Security Vulnerabilities</p> <p>If you discover a security vulnerability, please report it responsibly:</p> <p>Report a Security Vulnerability</p> <p>View Full Security Policy</p> <p>For the complete security policy, supported versions, and reporting guidelines, please see:</p> <p>SECURITY.md on GitHub</p>"},{"location":"SECURITY/#quick-overview","title":"Quick Overview","text":""},{"location":"SECURITY/#supported-versions","title":"Supported Versions","text":"<p>uptool follows a 6-month support window for security patches:</p> <ul> <li>Latest minor version: Full support (features, bug fixes, security patches)</li> <li>Previous minor version: Security patches only (6 months after next minor release)</li> <li>Older versions: No support</li> </ul>"},{"location":"SECURITY/#reporting-process","title":"Reporting Process","text":"<ol> <li>DO NOT create a public GitHub issue</li> <li>Use GitHub Security Advisories (private reporting)</li> <li>Provide detailed description and reproduction steps</li> <li>Allow time for investigation and patch development</li> </ol>"},{"location":"SECURITY/#response-timeline","title":"Response Timeline","text":"<ul> <li>Initial Response: Within 48 hours</li> <li>Severity Assessment: Within 1 week</li> <li>Patch Development: Varies by severity (1-4 weeks)</li> <li>Public Disclosure: After patch is available</li> </ul> <p>\u2192 Read the full SECURITY.md on GitHub</p>"},{"location":"action-usage/","title":"GitHub Action Usage","text":"<p>Use uptool as a GitHub Action to automate dependency updates.</p>"},{"location":"action-usage/#quick-start","title":"Quick Start","text":"<pre><code># .github/workflows/uptool.yml\nname: Dependency Updates\n\non:\n  schedule:\n    - cron: '0 9 * * 1'  # Monday at 9 AM UTC\n  workflow_dispatch:\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: santosr2/uptool@v0  # Latest stable (recommended)\n        with:\n          command: update\n          create-pr: 'true'\n          token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Version pinning:</p> <ul> <li><code>@v0</code> - Latest stable (auto-updates)</li> <li><code>@v0.1</code> - Latest patch</li> <li><code>@v0.1.0</code> - Exact version (most secure)</li> </ul>"},{"location":"action-usage/#common-patterns","title":"Common Patterns","text":""},{"location":"action-usage/#scan-only-no-updates","title":"Scan Only (No Updates)","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: scan\n    format: json\n</code></pre>"},{"location":"action-usage/#dry-run-before-applying","title":"Dry-Run Before Applying","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: update\n    dry-run: 'true'\n</code></pre>"},{"location":"action-usage/#integration-specific-updates","title":"Integration-Specific Updates","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: update\n    only: npm,helm\n    create-pr: 'true'\n</code></pre>"},{"location":"action-usage/#monorepo-pattern","title":"Monorepo Pattern","text":"<pre><code>strategy:\n  matrix:\n    package: [api, web, worker]\nsteps:\n  - uses: santosr2/uptool@v0\n    with:\n      working-directory: packages/${{ matrix.package }}\n      command: update\n</code></pre>"},{"location":"action-usage/#auto-merge-patch-updates","title":"Auto-Merge Patch Updates","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: update\n    create-pr: 'true'\n    pr-auto-merge: 'true'  # Only for patch updates\n</code></pre>"},{"location":"action-usage/#inputs","title":"Inputs","text":"Input Required Default Description <code>command</code> Yes - Command: <code>scan</code>, <code>plan</code>, or <code>update</code> <code>create-pr</code> No <code>false</code> Create pull request <code>token</code> No <code>${{ github.token }}</code> GitHub token <code>only</code> No - Comma-separated integrations <code>exclude</code> No - Exclude integrations <code>dry-run</code> No <code>false</code> Preview without applying <code>format</code> No <code>table</code> Output format: <code>table</code> or <code>json</code> <code>pr-title</code> No <code>chore(deps): update dependencies</code> PR title <code>pr-branch</code> No <code>uptool/updates</code> PR branch name <code>pr-auto-merge</code> No <code>false</code> Auto-merge PR <code>working-directory</code> No <code>.</code> Working directory"},{"location":"action-usage/#outputs","title":"Outputs","text":"Output Description <code>updates-available</code> <code>true</code> if updates found <code>manifests-count</code> Number of manifests detected <code>updates-count</code> Number of updates available <code>pr-number</code> Created PR number (if applicable) <code>pr-url</code> Created PR URL (if applicable) <p>Usage:</p> <pre><code>- uses: santosr2/uptool@v0\n  id: uptool\n  with:\n    command: scan\n\n- name: Check results\n  if: steps.uptool.outputs.updates-available == 'true'\n  run: echo \"Found ${{ steps.uptool.outputs.updates-count }} updates\"\n</code></pre>"},{"location":"action-usage/#permissions","title":"Permissions","text":"<p>Minimum required:</p> <pre><code>permissions:\n  contents: write          # To commit changes\n  pull-requests: write     # To create PRs\n</code></pre> <p>For auto-merge:</p> <pre><code>permissions:\n  contents: write\n  pull-requests: write\n  checks: read             # To verify checks pass\n</code></pre>"},{"location":"action-usage/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"action-usage/#skip-ci-on-update-prs","title":"Skip CI on Update PRs","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    pr-title: 'chore(deps): update dependencies [skip ci]'\n</code></pre>"},{"location":"action-usage/#notify-on-failures","title":"Notify on Failures","text":"<pre><code>- uses: santosr2/uptool@v0\n  continue-on-error: true\n  id: uptool\n\n- name: Notify on failure\n  if: failure()\n  uses: slackapi/slack-github-action@v1\n  with:\n    payload: |\n      {\n        \"text\": \"uptool failed: ${{ steps.uptool.outputs.error }}\"\n      }\n</code></pre>"},{"location":"action-usage/#custom-pr-body","title":"Custom PR Body","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    pr-body: |\n      ## Automated Dependency Updates\n\n      This PR updates dependencies to their latest compatible versions.\n\n      **Generated by**: uptool\n      **Schedule**: Weekly on Monday\n</code></pre>"},{"location":"action-usage/#matrix-strategy-for-environments","title":"Matrix Strategy for Environments","text":"<pre><code>strategy:\n  matrix:\n    env: [staging, production]\nsteps:\n  - uses: santosr2/uptool@v0\n    with:\n      command: update\n      working-directory: environments/${{ matrix.env }}\n      pr-branch: uptool/updates-${{ matrix.env }}\n</code></pre>"},{"location":"action-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"action-usage/#pr-not-created","title":"PR Not Created","text":"<p>Check:</p> <ul> <li>Permissions include <code>contents: write</code> and <code>pull-requests: write</code></li> <li>Token has repo access</li> <li>No existing PR with same branch name</li> </ul>"},{"location":"action-usage/#no-updates-found","title":"No Updates Found","text":"<p>Check:</p> <ul> <li>Manifest files exist in repository</li> <li>Integration enabled in <code>uptool.yaml</code></li> <li>Run with <code>dry-run: 'true'</code> to see debug output</li> </ul>"},{"location":"action-usage/#authentication-errors","title":"Authentication Errors","text":"<p>For private packages:</p> <pre><code>- name: Setup npm auth\n  run: echo \"//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}\" &gt; ~/.npmrc\n\n- uses: santosr2/uptool@v0\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"action-usage/#action-times-out","title":"Action Times Out","text":"<p>Increase timeout:</p> <pre><code>- uses: santosr2/uptool@v0\n  timeout-minutes: 15  # Default is 360\n</code></pre>"},{"location":"action-usage/#best-practices","title":"Best Practices","text":"<ol> <li>Use semantic versioning: Pin to <code>@v0</code> for auto-updates</li> <li>Run on schedule: Weekly or daily, avoid high-traffic times</li> <li>Enable manual trigger: Add <code>workflow_dispatch</code> for testing</li> <li>Test in staging first: Use matrix strategy for environments</li> <li>Review PRs: Don't blindly auto-merge major updates</li> <li>Set PR labels: Use <code>pr-labels: 'dependencies,automated'</code></li> <li>Configure branch protection: Require reviews for major updates</li> </ol>"},{"location":"action-usage/#examples","title":"Examples","text":"<p>See .github/workflows/ for working examples:</p> <ul> <li><code>dependency-updates.yml</code> - Weekly automated updates</li> <li><code>dependency-scan.yml</code> - PR scan checks</li> </ul>"},{"location":"action-usage/#see-also","title":"See Also","text":"<ul> <li>Quick Start - CLI usage</li> <li>Configuration - <code>uptool.yaml</code> reference</li> <li>action.yml - Action definition</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>uptool's design, components, and data flow.</p>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Manifest-First: Update config files directly, not just lockfiles</li> <li>Format Preservation: Maintain YAML comments, indentation, structure</li> <li>Extensibility: Plugin-based integration architecture</li> </ol>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<pre><code>CLI (cmd/uptool)\n  \u2193\nEngine (Scan/Plan/Update)\n  \u2193\nIntegrations (npm, helm, terraform, etc.)\n  \u2193\nDatasources (registries) + Rewrite (manifest updates)\n</code></pre>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#cli-layer-cmduptool","title":"CLI Layer (<code>cmd/uptool</code>)","text":"<p>Command handlers using Cobra:</p> <ul> <li><code>scan</code> - Find and parse manifests</li> <li><code>plan</code> - Query registries for updates</li> <li><code>update</code> - Apply changes to manifests</li> <li><code>list</code> - Show available integrations</li> </ul>"},{"location":"architecture/#engine-layer-internalengine","title":"Engine Layer (<code>internal/engine</code>)","text":"<p>Orchestration logic:</p> <ul> <li>Scan: Parallel integration detection, manifest parsing</li> <li>Plan: Registry queries, version resolution, update policy</li> <li>Update: Manifest rewriting, validation, diff generation</li> </ul>"},{"location":"architecture/#integration-layer-internalintegrations","title":"Integration Layer (<code>internal/integrations</code>)","text":"<p>Each integration implements:</p> <pre><code>type Integration interface {\n    Name() string\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n    Plan(ctx context.Context, manifest *Manifest) (*UpdatePlan, error)\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p>Types:</p> <ol> <li>Manifest Rewriting (npm, Helm, asdf, mise) - Parse and rewrite files</li> <li>Native Command (pre-commit) - Execute tool's update command</li> <li>Hybrid (Terraform) - Parse HCL, query registry, rewrite</li> </ol>"},{"location":"architecture/#datasource-layer-internaldatasource","title":"Datasource Layer (<code>internal/datasource</code>)","text":"<p>Registry abstraction:</p> <ul> <li>npm Registry API</li> <li>Helm/Artifact Hub</li> <li>Terraform Registry</li> <li>GitHub Releases (for tflint, asdf, mise)</li> </ul>"},{"location":"architecture/#rewrite-layer-internalrewrite","title":"Rewrite Layer (<code>internal/rewrite</code>)","text":"<p>Format-preserving updates:</p> <ul> <li>YAML: Line-by-line rewriting, preserves comments</li> <li>JSON: Structured rewriting with indentation</li> <li>TOML: gopkg.in/toml-based updates</li> <li>HCL: hashicorp/hcl parser</li> </ul>"},{"location":"architecture/#resolve-layer-internalresolve","title":"Resolve Layer (<code>internal/resolve</code>)","text":"<p>Semantic version resolution:</p> <ul> <li>Parse version constraints (<code>^4.0.0</code>, <code>~1.2.3</code>, <code>&gt;=2.0.0</code>)</li> <li>Find compatible versions</li> <li>Handle pre-release tags</li> </ul>"},{"location":"architecture/#policy-layer-internalpolicy","title":"Policy Layer (<code>internal/policy</code>)","text":"<p>Update policies from <code>uptool.yaml</code>:</p> <ul> <li>Maximum update level (none/patch/minor/major)</li> <li>Pre-release inclusion</li> <li>Pin vs range versions</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#scan","title":"Scan","text":"<ol> <li>CLI receives <code>scan</code> command</li> <li>Engine loads integrations</li> <li>Each integration detects manifests (parallel)</li> <li>Parse manifests, extract dependencies</li> <li>Return list of manifests with dependency counts</li> </ol>"},{"location":"architecture/#plan","title":"Plan","text":"<ol> <li>For each manifest, query datasources</li> <li>Resolve latest compatible versions</li> <li>Apply update policy filters</li> <li>Generate UpdatePlan with current \u2192 target versions</li> <li>Return plans (shows what would change)</li> </ol>"},{"location":"architecture/#update","title":"Update","text":"<ol> <li>Execute Plan for each manifest</li> <li>Integration rewrites manifest file</li> <li>Generate diff (before/after)</li> <li>Validate updated manifest</li> <li>Return ApplyResult with changes</li> </ol>"},{"location":"architecture/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/#pattern-1-manifest-rewriting-npm","title":"Pattern 1: Manifest Rewriting (npm)","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error) {\n    data, _ := os.ReadFile(plan.Manifest.Path)\n    var pkg PackageJSON\n    json.Unmarshal(data, &amp;pkg)\n\n    // Update versions\n    for dep, newVer := range plan.Updates {\n        pkg.Dependencies[dep] = newVer\n    }\n\n    // Write back with formatting\n    output, _ := json.MarshalIndent(pkg, \"\", \"  \")\n    os.WriteFile(plan.Manifest.Path, output, 0644)\n    return &amp;ApplyResult{Updated: len(plan.Updates)}, nil\n}\n</code></pre>"},{"location":"architecture/#pattern-2-native-command-pre-commit","title":"Pattern 2: Native Command (pre-commit)","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error) {\n    cmd := exec.CommandContext(ctx, \"pre-commit\", \"autoupdate\")\n    output, err := cmd.CombinedOutput()\n    // Native command updates .pre-commit-config.yaml\n    return &amp;ApplyResult{Updated: countUpdates(output)}, err\n}\n</code></pre>"},{"location":"architecture/#error-handling","title":"Error Handling","text":"<p>Errors categorized by severity:</p> <ul> <li>Fatal: Stop execution (invalid config, missing binary)</li> <li>Retryable: Temporary failures (network timeout, rate limit)</li> <li>Skippable: Non-critical (single integration failure)</li> </ul>"},{"location":"architecture/#performance","title":"Performance","text":"<p>Current:</p> <ul> <li>Parallel integration detection</li> <li>Sequential registry queries (network bound)</li> <li>Single-threaded manifest rewriting</li> </ul> <p>Future:</p> <ul> <li>Registry response caching</li> <li>Parallel registry queries with semaphore</li> <li>Batch updates for monorepos</li> </ul>"},{"location":"architecture/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests: Per-integration testing with testdata fixtures</li> <li>Integration tests: End-to-end with real registries</li> <li>Golden file tests: Manifest rewriting verification</li> <li>Target coverage: &gt;70% overall, &gt;80% for core engine</li> </ul>"},{"location":"architecture/#file-structure","title":"File Structure","text":"<pre><code>uptool/\n\u251c\u2500\u2500 cmd/uptool/              # CLI entry point\n\u2502   \u251c\u2500\u2500 main.go\n\u2502   \u2514\u2500\u2500 cmd/                 # Command handlers\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 engine/              # Core orchestration\n\u2502   \u251c\u2500\u2500 integrations/        # npm, helm, terraform, etc.\n\u2502   \u251c\u2500\u2500 datasource/          # Registry clients\n\u2502   \u251c\u2500\u2500 rewrite/             # Format-preserving updates\n\u2502   \u251c\u2500\u2500 resolve/             # Version resolution\n\u2502   \u2514\u2500\u2500 policy/              # Update policy engine\n\u251c\u2500\u2500 testdata/                # Test fixtures\n\u2514\u2500\u2500 examples/                # Sample configs\n</code></pre>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<ol> <li>New Integration: Implement <code>Integration</code> interface in <code>internal/integrations/</code></li> <li>New Datasource: Add client in <code>internal/datasource/</code></li> <li>New Format: Add rewriter in <code>internal/rewrite/</code></li> <li>Plugin: External <code>.so</code> implementing integration interface</li> </ol>"},{"location":"architecture/#see-also","title":"See Also","text":"<ul> <li>Plugin Development - Create custom integrations</li> <li>CONTRIBUTING.md - Development guidelines</li> <li>Integration Examples - Source code examples</li> </ul>"},{"location":"configuration/","title":"Configuration Reference","text":"<p>uptool can be configured using a <code>uptool.yaml</code> file in your repository root. Configuration is optional \u2014 if no file exists, uptool runs all integrations with sensible defaults.</p>"},{"location":"configuration/#quick-start","title":"Quick Start","text":"<p>Create <code>uptool.yaml</code> in your repository root:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"configuration/#configuration-schema","title":"Configuration Schema","text":""},{"location":"configuration/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>version: 1                    # Configuration format version (required)\n\nintegrations:                 # List of integration configurations\n  - id: &lt;integration_id&gt;      # Integration identifier\n    enabled: true|false       # Enable/disable this integration\n    match:                    # Optional: File matching rules\n      files: [...]            # List of file patterns\n    policy:                   # Update policy for this integration\n      update: none|patch|minor|major\n      allow_prerelease: true|false\n      pin: true|false\n      cadence: daily|weekly|monthly  # Update frequency (optional)\n\norg_policy:                   # Optional: Organization-level policies\n  require_signoff_from: [...]  # List of required approvers\n  signing:                    # Artifact signing verification\n    cosign_verify: true|false\n  auto_merge:                 # Automatic PR merging\n    enabled: true|false\n    guards: [...]             # Required conditions\n</code></pre>"},{"location":"configuration/#configuration-fields","title":"Configuration Fields","text":""},{"location":"configuration/#version","title":"version","text":"<p>Type: <code>integer</code> | Required: Yes | Default: N/A</p> <p>The configuration format version. Currently only <code>1</code> is supported.</p>"},{"location":"configuration/#integrations","title":"integrations","text":"<p>Type: <code>array</code> | Required: No | Default: All integrations enabled</p> <p>List of integration configurations.</p>"},{"location":"configuration/#id","title":"id","text":"<p>Type: <code>string</code> | Required: Yes</p> <p>Allowed values: <code>npm</code>, <code>helm</code>, <code>terraform</code>, <code>tflint</code>, <code>precommit</code>, <code>asdf</code>, <code>mise</code></p> <p>The integration identifier.</p>"},{"location":"configuration/#enabled","title":"enabled","text":"<p>Type: <code>boolean</code> | Required: No | Default: <code>true</code></p> <p>Whether this integration should run. CLI flags <code>--only</code> and <code>--exclude</code> override this setting.</p>"},{"location":"configuration/#match","title":"match","text":"<p>Type: <code>object</code> | Required: No</p> <p>File matching rules for this integration.</p> <p>match.files - Array of glob patterns:</p> <pre><code>- id: npm\n  match:\n    files:\n      - \"package.json\"           # Root package.json\n      - \"apps/*/package.json\"    # Monorepo packages\n      - \"packages/*/package.json\"\n</code></pre> <p>Default patterns by integration:</p> Integration Default Patterns npm <code>package.json</code> helm <code>Chart.yaml</code>, <code>*/Chart.yaml</code>, <code>charts/*/Chart.yaml</code> terraform <code>*.tf</code>, <code>**/*.tf</code> tflint <code>.tflint.hcl</code> precommit <code>.pre-commit-config.yaml</code> asdf <code>.tool-versions</code> mise <code>mise.toml</code>, <code>.mise.toml</code>"},{"location":"configuration/#policy","title":"policy","text":"<p>Type: <code>object</code> | Required: No</p> <p>Update policy for this integration.</p> <p>policy.update - Maximum version bump to allow:</p> Value Allows Example <code>none</code> No updates Scan/plan only <code>patch</code> Patch updates only 1.2.3 \u2192 1.2.4 <code>minor</code> Patch + minor 1.2.3 \u2192 1.3.0 <code>major</code> All updates 1.2.3 \u2192 2.0.0 <p>Default: <code>minor</code></p> <p>policy.allow_prerelease - Include pre-release versions:</p> <p>Type: <code>boolean</code> | Default: <code>false</code></p> <p>When <code>true</code>, considers versions like <code>1.2.3-alpha20250708</code>, <code>1.2.3-beta2</code>, <code>1.2.3-rc1</code>.</p> <p>policy.pin - Write exact versions or ranges:</p> <p>Type: <code>boolean</code> | Default: Depends on integration</p> Integration pin: true pin: false npm <code>\"4.19.2\"</code> <code>\"^4.19.2\"</code> (preserves constraint) helm <code>12.0.0</code> <code>12.0.0</code> (always pinned) terraform <code>\"5.8.1\"</code> <code>\"5.8.1\"</code> (always pinned) mise <code>\"1.25\"</code> <code>\"1.25\"</code> (always pinned) <p>policy.cadence - Update frequency for scheduled runs:</p> <p>Type: <code>string</code> | Default: None</p> <p>Values: <code>daily</code>, <code>weekly</code>, <code>monthly</code></p> <p>Controls how often to check for updates in automated scenarios (primarily for GitHub Actions integration).</p>"},{"location":"configuration/#org_policy","title":"org_policy","text":"<p>Type: <code>object</code> | Required: No</p> <p>Organization-level policies for governance and automation.</p> <p>org_policy.require_signoff_from - Required approvers:</p> <p>Type: <code>array of strings</code> | Default: None</p> <p>List of email addresses or team identifiers that must approve changes.</p> <pre><code>org_policy:\n  require_signoff_from:\n    - \"platform-team@company.com\"\n    - \"security-team@company.com\"\n</code></pre> <p>org_policy.signing - Artifact signing verification:</p> <p>Type: <code>object</code> | Default: None</p> <pre><code>org_policy:\n  signing:\n    cosign_verify: true  # Verify signatures with Cosign\n</code></pre> <p>org_policy.auto_merge - Automatic PR merging:</p> <p>Type: <code>object</code> | Default: None</p> <pre><code>org_policy:\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"           # All CI checks must pass\n      - \"codeowners-approve\"  # CODEOWNERS must approve\n</code></pre>"},{"location":"configuration/#complete-examples","title":"Complete Examples","text":""},{"location":"configuration/#conservative-production","title":"Conservative (Production)","text":"<p>For production systems requiring stability:</p> <pre><code>version: 1\n\nintegrations:\n  # Only patch updates for runtime dependencies\n  - id: mise\n    policy:\n      update: patch\n\n  - id: npm\n    policy:\n      update: patch\n\n  # Minor updates for infrastructure\n  - id: terraform\n    policy:\n      update: minor\n\n  - id: helm\n    policy:\n      update: minor\n</code></pre>"},{"location":"configuration/#comprehensive-all-features","title":"Comprehensive (All Features)","text":"<p>Full configuration with all options:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    match:\n      files:\n        - \"package.json\"\n        - \"apps/*/package.json\"     # Monorepo support\n        - \"packages/*/package.json\"\n    policy:\n      update: minor\n      allow_prerelease: false\n      pin: false  # Use version ranges\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: terraform\n    enabled: true\n    match:\n      files:\n        - \"infrastructure/**/*.tf\"\n        - \"modules/**/*.tf\"\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: precommit\n    enabled: true\n    policy:\n      update: major  # Aggressive for dev tools\n\n  - id: tflint\n    enabled: true\n    policy:\n      update: major\n\n  - id: asdf\n    enabled: true\n    policy:\n      update: patch  # Conservative for runtimes\n\n  - id: mise\n    enabled: true\n    policy:\n      update: patch  # Conservative for runtimes\n</code></pre>"},{"location":"configuration/#configuration-precedence","title":"Configuration Precedence","text":"<p>Settings are applied in this order (later overrides earlier):</p> <ol> <li>Integration defaults (hardcoded in code)</li> <li><code>uptool.yaml</code> configuration (if exists)</li> <li>CLI flags (<code>--only</code>, <code>--exclude</code>)</li> </ol> <p>Example:</p> <pre><code># uptool.yaml\nintegrations:\n  - id: npm\n    enabled: false\n</code></pre> <pre><code># CLI overrides config file\nuptool update --only=npm  # npm WILL update despite enabled: false\n</code></pre>"},{"location":"configuration/#validation","title":"Validation","text":"<p>uptool validates configuration on startup. Invalid values log warnings and use defaults:</p> <pre><code>WARN: Unknown integration 'unknown_integration' in config, skipping\nWARN: Invalid update policy 'invalid_value' for npm, using default 'minor'\n</code></pre>"},{"location":"configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Start conservative: Use <code>patch</code> or <code>minor</code> for production</li> <li>Separate policies: Conservative for runtime, aggressive for dev tools</li> <li>Explicit paths: Avoid broad wildcards in monorepos (<code>apps/*/package.json</code> not <code>**/package.json</code>)</li> <li>Document decisions: Add comments explaining policy choices</li> </ol>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":"<p>Config not loading: Check <code>uptool.yaml</code> exists in root, valid YAML syntax, run with <code>-v</code></p> <p>Integration not running: Verify <code>enabled: true</code>, no CLI overrides (<code>--exclude</code>), files match pattern</p> <p>Policy not applied: Policy applies to <code>uptool update</code>, bypassed with <code>--only</code> flag</p>"},{"location":"configuration/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command documentation</li> <li>Integration Guides - Integration-specific details</li> <li>GitHub Action Usage - CI/CD configuration</li> <li>Examples - Sample configurations</li> </ul>"},{"location":"environments/","title":"GitHub Environments Setup","text":"<p>uptool uses GitHub Environments with approval gates to control releases. This provides an additional layer of security and creates an audit trail for all releases.</p>"},{"location":"environments/#overview","title":"Overview","text":"<p>Three environments are configured in the release workflows:</p> <ol> <li>pre-release - Used for creating pre-release versions (rc/beta/alpha)</li> <li>production - Used for promoting pre-releases to stable versions</li> <li>patch-release - Used for creating patch releases on release branches</li> </ol> <p>All environments require manual approval from designated reviewers before the workflow can proceed with creating/promoting releases.</p>"},{"location":"environments/#environment-configuration","title":"Environment Configuration","text":""},{"location":"environments/#prerequisites","title":"Prerequisites","text":"<ul> <li>Repository administrator access</li> <li>Appropriate repository permissions (Settings \u2192 Environments)</li> </ul>"},{"location":"environments/#creating-environments","title":"Creating Environments","text":""},{"location":"environments/#1-navigate-to-environments","title":"1. Navigate to Environments","text":"<ol> <li>Go to your repository on GitHub</li> <li>Click Settings (top menu)</li> <li>In the left sidebar, click Environments</li> </ol>"},{"location":"environments/#2-create-pre-release-environment","title":"2. Create Pre-Release Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>pre-release</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve pre-releases</li> <li>Recommended: At least 1 reviewer</li> <li> <p>Prevents accidental pre-release creation</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes (no automatic delay)</li> <li> <p>Or add a delay if desired</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add rule: <code>main</code> branch only</li> <li>This ensures only main branch can create releases</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> <li>GitHub token is automatically provided</li> </ul> <p>Save the environment</p>"},{"location":"environments/#3-create-production-environment","title":"3. Create Production Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>production</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve stable releases</li> <li>Recommended: At least 2 reviewers for production</li> <li> <p>Requires multiple approvals for critical releases</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes for immediate review</li> <li> <p>Or set to 10-30 minutes for time to review changes</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add rule: <code>main</code> branch only</li> <li> <p>Ensures only main branch can promote to stable</p> </li> <li> <p>\u26a0\ufe0f Prevent self-review (recommended)</p> </li> <li>Enable this to require approval from someone other than the workflow trigger</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> </ul> <p>Save the environment</p>"},{"location":"environments/#4-create-patch-release-environment","title":"4. Create Patch Release Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>patch-release</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve patch releases</li> <li>Recommended: At least 1 reviewer (can be same as pre-release)</li> <li> <p>Ensures security/bug fixes are reviewed before release</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes for immediate review</li> <li> <p>Patch releases are typically urgent (security fixes)</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add pattern: <code>release-*</code> (for release branches)</li> <li> <p>This ensures only release branches can create patch releases</p> </li> <li> <p>\u26a0\ufe0f Prevent self-review (recommended)</p> </li> <li>Enable this for security patches especially</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> </ul> <p>Save the environment</p>"},{"location":"environments/#approval-workflow","title":"Approval Workflow","text":""},{"location":"environments/#pre-release-creation","title":"Pre-Release Creation","text":"<p>When someone triggers the Pre-Release workflow:</p> <ol> <li>Workflow calculates version and updates files</li> <li>Tests run automatically</li> <li>Workflow pauses at the <code>build</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are built and pre-release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Pre-release version (e.g., <code>v0.2.0-rc1</code>)</li> <li>Commit SHA being released</li> <li>Link to the release page (once approved)</li> <li>Comment field for approval notes</li> </ul>"},{"location":"environments/#stable-release-promotion","title":"Stable Release Promotion","text":"<p>When someone triggers the Promote to Stable Release workflow:</p> <ol> <li>Workflow validates pre-release tag exists</li> <li>Updates version files to stable</li> <li>Tests run automatically</li> <li>Workflow pauses at the <code>promote</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are promoted and stable release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Pre-release being promoted (e.g., <code>v0.2.0-rc1</code>)</li> <li>Stable version (e.g., <code>v0.2.0</code>)</li> <li>Link to the stable release page (once approved)</li> </ul>"},{"location":"environments/#patch-release-creation","title":"Patch Release Creation","text":"<p>When someone triggers the Patch Release workflow:</p> <ol> <li>Workflow validates release branch exists</li> <li>Updates version files on release branch</li> <li>Builds binaries and generates SBOMs</li> <li>Workflow pauses at the <code>release</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are signed and patch release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Release branch (e.g., <code>release-0.1</code>)</li> <li>Patch version (e.g., <code>v0.1.1</code>)</li> <li>Patch type (security or bugfix)</li> <li>Commits included in patch</li> <li>Link to the patch release page (once approved)</li> </ul>"},{"location":"environments/#approving-a-deployment","title":"Approving a Deployment","text":""},{"location":"environments/#as-a-reviewer","title":"As a Reviewer","text":"<p>When you receive a deployment approval request:</p> <ol> <li>Check your email or GitHub notifications</li> <li>Go to Actions tab in the repository</li> <li>Find the workflow run waiting for approval</li> <li>Review the details:</li> <li>Check the version being released</li> <li>Review the commits included</li> <li>Verify tests passed</li> <li> <p>Check CHANGELOG updates</p> </li> <li> <p>Click Review deployments</p> </li> <li>Select the environment (<code>pre-release</code>, <code>production</code>, or <code>patch-release</code>)</li> <li>Add a comment (optional but recommended):</li> </ol> <pre><code>Approved: Version v0.2.0 includes security fixes\n</code></pre> <ol> <li>Click Approve and deploy or Reject</li> </ol>"},{"location":"environments/#review-checklist","title":"Review Checklist","text":"<p>Before approving a pre-release:</p> <ul> <li> Version number is correct</li> <li> All tests passed</li> <li> No breaking changes without documentation</li> <li> CHANGELOG is updated</li> <li> Commit messages follow conventional commits</li> </ul> <p>Before approving a stable release:</p> <ul> <li> Pre-release was tested successfully</li> <li> No critical issues reported</li> <li> Documentation is accurate</li> <li> Version matches what was tested</li> <li> All artifacts are present</li> </ul> <p>Before approving a patch release:</p> <ul> <li> Patch is on correct release branch (e.g., <code>release-0.1</code>)</li> <li> Version increment is correct (patch only)</li> <li> Security vulnerability is properly fixed (if security patch)</li> <li> Changes are minimal and targeted (no feature additions)</li> <li> All tests passed on release branch</li> <li> No conflicts with existing stable releases</li> </ul>"},{"location":"environments/#viewing-deployment-history","title":"Viewing Deployment History","text":"<p>GitHub tracks all deployments in the environment:</p> <ol> <li>Go to Settings \u2192 Environments</li> <li>Click on <code>pre-release</code>, <code>production</code>, or <code>patch-release</code></li> <li>View Deployment history:</li> <li>Who triggered the workflow</li> <li>Who approved/rejected</li> <li>When it was deployed</li> <li>Links to workflow runs</li> <li>Comments from reviewers</li> </ol> <p>This creates a complete audit trail for compliance.</p>"},{"location":"environments/#bypassing-approval-not-recommended","title":"Bypassing Approval (Not Recommended)","text":"<p>Warning: Only repository administrators can bypass environment protection rules.</p> <p>If you need to bypass approval (emergency only):</p> <ol> <li>Go to Settings \u2192 Environments</li> <li>Select the environment</li> <li>Temporarily remove Required reviewers</li> <li>Run the workflow</li> <li>Immediately re-enable required reviewers</li> </ol> <p>Better approach: Add yourself as an approved reviewer if needed.</p>"},{"location":"environments/#troubleshooting","title":"Troubleshooting","text":"<p>Workflow stuck waiting: Check Actions tab for \"Review deployments\" button, verify you're a required reviewer</p> <p>Cannot approve: Ensure you're listed as reviewer and didn't trigger the workflow yourself (if self-review prevented)</p> <p>Environment not found: Verify environment names in workflow files match Settings \u2192 Environments exactly</p>"},{"location":"environments/#security-best-practices","title":"Security Best Practices","text":""},{"location":"environments/#required-reviewers","title":"Required Reviewers","text":"<p>Pre-release environment:</p> <ul> <li>Minimum: 1 reviewer</li> <li>Recommended: 1-2 reviewers</li> <li>Should include: Project maintainers</li> </ul> <p>Production environment:</p> <ul> <li>Minimum: 2 reviewers</li> <li>Recommended: 2-3 reviewers</li> <li>Should include: Senior maintainers, security lead</li> </ul> <p>Patch release environment:</p> <ul> <li>Minimum: 1 reviewer</li> <li>Recommended: 1-2 reviewers (can be same as pre-release)</li> <li>Should include: Security lead (for security patches), maintainers</li> <li>Note: Security patches should be expedited but still reviewed</li> </ul>"},{"location":"environments/#branch-protection","title":"Branch Protection","text":"<p>Combine environment protection with branch protection:</p> <ol> <li>Go to Settings \u2192 Branches</li> <li>Add rule for <code>main</code> branch:</li> <li>\u2705 Require pull request reviews (at least 1)</li> <li>\u2705 Require status checks to pass</li> <li>\u2705 Require branches to be up to date</li> <li> <p>\u2705 Include administrators</p> </li> <li> <p>Add rule for <code>release-*</code> pattern (for patch release branches):</p> </li> <li>\u2705 Require pull request reviews (at least 1)</li> <li>\u2705 Require status checks to pass</li> <li>\u2705 Include administrators</li> <li>\u2705 Restrict who can push (maintainers only)</li> </ol> <p>This ensures:</p> <ul> <li>Code is reviewed before merging</li> <li>Tests pass before merging</li> <li>Releases require additional approval</li> <li>Patch releases are protected and audited</li> </ul>"},{"location":"environments/#audit-trail","title":"Audit Trail","text":"<p>GitHub automatically logs:</p> <ul> <li>Who triggered the workflow</li> <li>Who approved/rejected</li> <li>When deployment occurred</li> <li>Environment variables used</li> <li>Workflow run details</li> </ul> <p>Export deployment logs regularly for compliance:</p> <ol> <li>Go to Settings \u2192 Environments \u2192 [Environment]</li> <li>View deployment history</li> <li>Document approvals in release notes</li> </ol>"},{"location":"environments/#example-release-flow","title":"Example Release Flow","text":""},{"location":"environments/#standard-release-flow","title":"Standard Release Flow","text":"<ol> <li>Pre-Release: Trigger workflow \u2192 Reviewer approves \u2192 <code>v0.2.0-rc1</code> created</li> <li>Testing: Test artifacts, fix issues, create new RC if needed</li> <li>Promotion: Trigger promote workflow \u2192 Multiple reviewers approve \u2192 <code>v0.2.0</code> created</li> <li>Audit: All approvals logged in environment history</li> </ol>"},{"location":"environments/#patch-release-flow","title":"Patch Release Flow","text":"<ol> <li>Security Fix: Vulnerability discovered in <code>v0.1.0</code></li> <li>Create Branch: Create <code>release-0.1</code> from <code>v0.1.0</code> tag (if not exists)</li> <li>Apply Fix: Cherry-pick security fix to release branch</li> <li>Patch Release: Trigger patch workflow \u2192 Reviewer approves \u2192 <code>v0.1.1</code> created</li> <li>Audit: Patch release approval logged in patch-release environment history</li> </ol>"},{"location":"environments/#see-also","title":"See Also","text":"<ul> <li>GitHub Environments Documentation</li> <li>Deployment Protection Rules</li> <li>Version Management Guide</li> <li>Contributing Guide</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This page covers various methods to install uptool on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25+ (if installing from source)</li> <li>Git (for version control)</li> <li>Internet connection (for downloading binaries or building from source)</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-docker-recommended","title":"Method 1: Docker (Recommended)","text":"<p>The easiest way to get started with uptool is using Docker. This method requires no local installation and works across all platforms.</p> <pre><code># Pull the latest stable image\ndocker pull ghcr.io/santosr2/uptool:latest\n\n# Run uptool directly\ndocker run --rm -v \"$PWD:/workspace\" ghcr.io/santosr2/uptool version\n\n# Create an alias for convenience\necho 'alias uptool=\"docker run --rm -v \\\"\\$PWD:/workspace\\\" ghcr.io/santosr2/uptool\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n# Now you can use uptool as a regular command\nuptool scan\n</code></pre> <p>Docker Image Tags</p> <ul> <li><code>latest</code> - Latest stable release</li> <li><code>v1.0.0</code> - Specific version (immutable)</li> <li><code>v1</code> - Latest v1.x.x release (mutable)</li> <li><code>v1.0</code> - Latest v1.0.x patch (mutable)</li> <li><code>v1.0.0-rc1</code> - Pre-release versions</li> </ul> <p>Multi-platform Support</p> <p>The Docker image supports both <code>linux/amd64</code> and <code>linux/arm64</code> architectures automatically.</p>"},{"location":"installation/#method-2-go-install-for-go-users","title":"Method 2: Go Install (For Go users)","text":"<p>If you have Go 1.25+ installed:</p> <pre><code>go install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre> <p>This will install the latest version of uptool to your <code>$GOPATH/bin</code> directory.</p> <p>Add to PATH</p> <p>Ensure <code>$GOPATH/bin</code> is in your <code>$PATH</code>: <pre><code>export PATH=\"$PATH:$(go env GOPATH)/bin\"\n</code></pre></p>"},{"location":"installation/#method-3-pre-built-binaries","title":"Method 3: Pre-built Binaries","text":"<p>Download pre-compiled binaries from the GitHub Releases page.</p> Linux (AMD64) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-linux-amd64\nchmod +x uptool-linux-amd64\nsudo mv uptool-linux-amd64 /usr/local/bin/uptool\n</code></pre> Linux (ARM64) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-linux-arm64\nchmod +x uptool-linux-arm64\nsudo mv uptool-linux-arm64 /usr/local/bin/uptool\n</code></pre> macOS (Apple Silicon) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-darwin-arm64\nchmod +x uptool-darwin-arm64\nsudo mv uptool-darwin-arm64 /usr/local/bin/uptool\n</code></pre> macOS (Intel) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-darwin-amd64\nchmod +x uptool-darwin-amd64\nsudo mv uptool-darwin-amd64 /usr/local/bin/uptool\n</code></pre> Windows (AMD64) <pre><code># Download from GitHub Releases\nInvoke-WebRequest -Uri https://github.com/santosr2/uptool/releases/latest/download/uptool-windows-amd64.exe -OutFile uptool.exe\n\n# Move to a directory in your PATH\nMove-Item uptool.exe C:\\Windows\\System32\\uptool.exe\n</code></pre>"},{"location":"installation/#method-3-build-from-source","title":"Method 3: Build from Source","text":"<p>Clone the repository and build from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/santosr2/uptool.git\ncd uptool\n\n# Build the binary\nmise run build\n\n# Install to $GOPATH/bin\nmise run install\n\n# Or manually copy the binary\nsudo cp dist/uptool /usr/local/bin/\n</code></pre>"},{"location":"installation/#method-4-using-mise-development-environment","title":"Method 4: Using mise (Development Environment)","text":"<p>If you use mise for managing development tools:</p> <pre><code># Add to your mise.toml\necho 'uptool = \"latest\"' &gt;&gt; mise.toml\n\n# Install\nmise install\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify the installation by checking the version:</p> <pre><code>uptool version\n</code></pre> <p>Expected output:</p> <pre><code>uptool version 0.1.0\n</code></pre>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>After installation, you may want to configure uptool for your project. See the Configuration Guide for details.</p>"},{"location":"installation/#updating-uptool","title":"Updating uptool","text":""},{"location":"installation/#docker","title":"Docker","text":"<p>Docker images are always up-to-date when you pull:</p> <pre><code># Pull the latest stable release\ndocker pull ghcr.io/santosr2/uptool:latest\n\n# Or pull a specific version\ndocker pull ghcr.io/santosr2/uptool:v1.0.0\n</code></pre>"},{"location":"installation/#go-install","title":"Go Install","text":"<pre><code>go install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre>"},{"location":"installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release and replace your existing binary.</p>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>cd uptool\ngit pull origin main\nmise run build\nsudo cp dist/uptool /usr/local/bin/\n</code></pre>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":""},{"location":"installation/#go-install_1","title":"Go Install","text":"<pre><code>rm $(which uptool)\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<pre><code>sudo rm /usr/local/bin/uptool\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started with your first project</li> <li>Configuration - Learn about uptool configuration</li> <li>GitHub Action Usage - Use uptool in CI/CD</li> </ul>"},{"location":"manifests/","title":"Manifest Files Reference","text":"<p>uptool is a manifest-first dependency updater. This document catalogs all supported manifest file types across different ecosystems.</p>"},{"location":"manifests/#philosophy-manifest-first","title":"Philosophy: Manifest-First","text":"<p>uptool updates manifest files (source of truth) rather than lockfiles or resolved dependencies:</p> <ol> <li>Manifests declare intent - They specify which versions you want</li> <li>Lockfiles are generated - They record resolved versions</li> <li>Update manifests first - Changes propagate to lockfiles via native tools</li> </ol> <p>This ensures your declared dependencies stay current, not just resolved versions.</p>"},{"location":"manifests/#supported-manifest-types","title":"Supported Manifest Types","text":""},{"location":"manifests/#javascriptnodejs-npm","title":"JavaScript/Node.js (npm)","text":"<p>Integration: <code>npm</code></p> <p>Manifest Files:</p> <ul> <li><code>package.json</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>dependencies</code></li> <li><code>devDependencies</code></li> <li><code>peerDependencies</code></li> <li><code>optionalDependencies</code></li> </ul> <p>Update Strategy:</p> <ul> <li>Custom JSON rewriting</li> <li>Preserves version constraint prefixes (<code>^</code>, <code>~</code>, <code>&gt;=</code>, etc.)</li> <li>Preserves formatting and key order</li> </ul> <p>Example:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",     // Updated to \"^4.19.2\"\n    \"lodash\": \"~4.17.20\"       // Updated to \"~4.17.21\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"&gt;=29.0.0\"         // Updated to \"&gt;=29.7.0\"\n  }\n}\n</code></pre> <p>Registry: npm Registry API (<code>https://registry.npmjs.org</code>)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>package-lock.json</code> directly</li> <li>Run <code>npm install</code> after updating to regenerate lockfile</li> <li>Workspace support: Yes (monorepos with <code>workspaces</code> field)</li> </ul>"},{"location":"manifests/#kuberneteshelm","title":"Kubernetes/Helm","text":"<p>Integration: <code>helm</code></p> <p>Manifest Files:</p> <ul> <li><code>Chart.yaml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>dependencies[].version</code> - Chart dependencies</li> </ul> <p>Update Strategy:</p> <ul> <li>YAML parsing and rewriting</li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>apiVersion: v2\nname: my-app\ndependencies:\n  - name: postgresql\n    version: 12.0.0           # Updated to 18.1.8\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 17.0.0           # Updated to 23.2.12\n    repository: https://charts.bitnami.com/bitnami\n</code></pre> <p>Registry: Helm chart repositories (index.yaml)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>Chart.lock</code></li> <li>Run <code>helm dependency update</code> after to regenerate lockfile</li> <li>Only updates dependency versions, not chart metadata</li> </ul>"},{"location":"manifests/#terraform","title":"Terraform","text":"<p>Integration: <code>terraform</code></p> <p>Manifest Files:</p> <ul> <li><code>*.tf</code> (any Terraform file)</li> <li><code>main.tf</code>, <code>modules.tf</code>, <code>providers.tf</code>, etc.</li> </ul> <p>What Gets Updated:</p> <ul> <li><code>module</code> block <code>version</code> attributes</li> <li>Module source versions in git URLs (future)</li> <li>Provider versions (future)</li> </ul> <p>Update Strategy:</p> <ul> <li>HCL parsing and rewriting via <code>hashicorp/hcl</code></li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"           # Updated to \"5.13.0\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 4.0\"          # Updated to \"~&gt; 5.0\"\n}\n</code></pre> <p>Registry: Terraform Registry API (<code>https://registry.terraform.io</code>)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>.terraform.lock.hcl</code></li> <li>Run <code>terraform init -upgrade</code> after to regenerate lockfile</li> <li>Version constraints are preserved</li> </ul>"},{"location":"manifests/#tflint","title":"tflint","text":"<p>Integration: <code>tflint</code></p> <p>Manifest Files:</p> <ul> <li><code>.tflint.hcl</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>plugin</code> block <code>version</code> attributes</li> </ul> <p>Update Strategy:</p> <ul> <li>HCL parsing and rewriting</li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"          # Updated to \"0.44.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.20.0\"          # Updated to \"0.28.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n</code></pre> <p>Registry: GitHub Releases (for plugins)</p> <p>Notes:</p> <ul> <li>Plugin sources must be valid GitHub repository paths</li> <li>Follows semantic versioning</li> </ul>"},{"location":"manifests/#pre-commit-hooks","title":"Pre-Commit Hooks","text":"<p>Integration: <code>precommit</code></p> <p>Manifest Files:</p> <ul> <li><code>.pre-commit-config.yaml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>repos[].rev</code> - Hook repository revisions</li> </ul> <p>Update Strategy:</p> <ul> <li>Native command: <code>pre-commit autoupdate</code></li> <li>Uses pre-commit's built-in update mechanism</li> <li>This is because <code>pre-commit autoupdate</code> updates the manifest directly</li> </ul> <p>Example:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0               # Updated to v6.0.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n\n  - repo: https://github.com/psf/black\n    rev: 22.10.0              # Updated to 24.10.0\n    hooks:\n      - id: black\n</code></pre> <p>Registry: GitHub Releases (for hook repositories)</p> <p>Notes:</p> <ul> <li>Uses native <code>pre-commit autoupdate</code> command</li> <li>Respects minimum_pre_commit_version</li> <li>Does NOT create <code>.pre-commit-config.yaml.lock</code> (pre-commit doesn't use lockfiles)</li> </ul>"},{"location":"manifests/#asdf-version-manager","title":"asdf Version Manager","text":"<p>Integration: <code>asdf</code></p> <p>Manifest Files:</p> <ul> <li><code>.tool-versions</code></li> </ul> <p>What Gets Updated:</p> <ul> <li>Tool versions (e.g., <code>go 1.23.0</code> \u2192 <code>go 1.25.0</code>)</li> </ul> <p>Update Strategy:</p> <ul> <li>Line-based parsing and rewriting</li> <li>Preserves formatting and comments</li> </ul> <p>Example:</p> <pre><code># Development tools\ngo 1.23.0                     # Updated to 1.25.0\nnodejs 20.10.0                # Updated to 22.12.0\nterraform 1.5.0               # Updated to 1.10.5\n\n# Build tools\npython 3.11.0                 # Updated to 3.13.1\n</code></pre> <p>Registry: GitHub Releases (per tool via asdf plugin mapping)</p> <p>Notes:</p> <ul> <li>Does NOT update installed versions</li> <li>Run <code>asdf install</code> after to install new versions</li> <li>Supports multiple versions per tool (space-separated)</li> </ul>"},{"location":"manifests/#mise-version-manager","title":"mise Version Manager","text":"<p>Integration: <code>mise</code></p> <p>Manifest Files:</p> <ul> <li><code>mise.toml</code></li> <li><code>.mise.toml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>[tools]</code> section tool versions</li> </ul> <p>Update Strategy:</p> <ul> <li>TOML parsing and rewriting</li> <li>Supports both string format and map format</li> <li>Preserves comments and formatting</li> </ul> <p>Example (String Format):</p> <pre><code>[tools]\ngo = \"1.23\"                   # Updated to \"1.25\"\nnode = \"20\"                   # Updated to \"22\"\ngolangci-lint = \"2.6\"         # Updated to \"2.7\"\nterraform = \"1.5.0\"           # Updated to \"1.10.5\"\n</code></pre> <p>Example (Map Format):</p> <pre><code>[tools]\ngo = { version = \"1.23\" }     # Updated to { version = \"1.25\" }\nnode = { version = \"20\", path = \".nvmrc\" }\n</code></pre> <p>Registry: GitHub Releases (per tool)</p> <p>Notes:</p> <ul> <li>Does NOT install new versions automatically</li> <li>Run <code>mise install</code> after to install new versions</li> <li>Supports both mise.toml and .mise.toml (hidden file)</li> </ul>"},{"location":"manifests/#manifest-detection","title":"Manifest Detection","text":"<p>uptool automatically detects manifest files by:</p> <ol> <li>Filename matching: Exact matches like <code>package.json</code>, <code>Chart.yaml</code></li> <li>Pattern matching: Glob patterns like <code>*.tf</code>, <code>mise.toml</code></li> <li>Directory walking: Recursively scans from repository root</li> </ol>"},{"location":"manifests/#detection-order","title":"Detection Order","text":"<p>Each integration defines its own detection logic:</p> <pre><code>// Example: npm integration\nfunc Detect(ctx context.Context, repoRoot string) ([]*Manifest, error) {\n    // Look for package.json files\n    matches, err := filepath.Glob(filepath.Join(repoRoot, \"**/package.json\"))\n    // ...\n}\n</code></pre>"},{"location":"manifests/#ignored-directories","title":"Ignored Directories","text":"<p>By default, uptool skips:</p> <ul> <li><code>.git/</code></li> <li><code>node_modules/</code></li> <li><code>vendor/</code></li> <li><code>.terraform/</code></li> <li><code>dist/</code>, <code>build/</code></li> </ul>"},{"location":"manifests/#manifest-first-principles","title":"Manifest-First Principles","text":""},{"location":"manifests/#do-update-manifests","title":"\u2705 DO: Update Manifests","text":"<pre><code># Good: Updates package.json (manifest)\nuptool update --only=npm\n\n# Then regenerate lockfile\nnpm install\n</code></pre>"},{"location":"manifests/#dont-rely-on-lockfile-only-tools","title":"\u274c DON'T: Rely on Lockfile-Only Tools","text":"<pre><code># Bad: npm update only updates package-lock.json\nnpm update\n\n# package.json still has old versions!\n</code></pre>"},{"location":"manifests/#why-manifest-first","title":"Why Manifest-First?","text":"<ol> <li>Intent over resolution: Manifests declare what you want, lockfiles record what you got</li> <li>Portability: Manifests work across environments, lockfiles don't</li> <li>Auditability: Changes to manifests are explicit in version control</li> <li>Consistency: Everyone gets the same declared versions</li> </ol>"},{"location":"manifests/#native-commands-vs-custom-rewriting","title":"Native Commands vs Custom Rewriting","text":""},{"location":"manifests/#when-native-commands-are-used","title":"When Native Commands Are Used","text":"<p>uptool uses native commands only when they update the manifest:</p> Integration Native Command Reason <code>precommit</code> <code>pre-commit autoupdate</code> Updates <code>.pre-commit-config.yaml</code> directly"},{"location":"manifests/#when-custom-rewriting-is-used","title":"When Custom Rewriting Is Used","text":"<p>All other integrations use custom parsing/rewriting:</p> Integration Reason <code>npm</code> <code>npm update</code> only updates lockfile <code>helm</code> <code>helm dependency update</code> only updates Chart.lock <code>terraform</code> <code>terraform init -upgrade</code> only updates .terraform.lock.hcl <code>tflint</code> No native update command exists <code>asdf</code> <code>.tool-versions</code> is plain text, no native update <code>mise</code> <code>mise.toml</code> is TOML, custom parsing needed"},{"location":"manifests/#configuration","title":"Configuration","text":"<p>You can configure which manifests to process via <code>uptool.yaml</code>:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor              # Only minor/patch updates\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n\n  - id: terraform\n    enabled: false               # Disable Terraform updates\n</code></pre> <p>See configuration.md for complete reference.</p>"},{"location":"manifests/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference - Configure update policies</li> <li>Troubleshooting Guide - Common issues and solutions</li> <li>Integration Guides - Detailed integration documentation</li> </ul>"},{"location":"overview/","title":"Overview","text":"<p>Universal, manifest-first dependency updater for multiple ecosystems.</p>"},{"location":"overview/#what-is-uptool","title":"What is uptool?","text":"<p>Updates manifest files directly (package.json, Chart.yaml, *.tf) instead of just lockfiles, preserving your declared dependencies while keeping them current.</p>"},{"location":"overview/#manifest-first-philosophy","title":"Manifest-First Philosophy","text":"<ol> <li>Update manifests first (package.json, Chart.yaml, *.tf)</li> <li>Use native commands only when they update manifests (<code>pre-commit autoupdate</code> \u2705, <code>npm update</code> \u274c)</li> <li>Then run lockfile updates (<code>npm install</code>, <code>terraform init</code>)</li> </ol>"},{"location":"overview/#supported-integrations","title":"Supported Integrations","text":"<p>npm, Helm, Terraform, tflint, pre-commit, asdf (experimental), mise (experimental)</p> <p>See Integrations for complete list.</p>"},{"location":"overview/#key-features","title":"Key Features","text":"<p>Multi-ecosystem support \u2022 Manifest-first updates \u2022 CLI &amp; GitHub Action \u2022 Safe by default \u2022 Concurrent execution \u2022 Flexible filtering</p>"},{"location":"overview/#documentation","title":"Documentation","text":"<ul> <li>Installation \u2022 Quick Start \u2022 Configuration</li> <li>CLI Reference \u2022 Integrations \u2022 GitHub Action</li> <li>Architecture \u2022 Main README</li> </ul>"},{"location":"patch-release-workflow/","title":"Patch Release Workflow Guide","text":"<p>This guide explains how to manage security patches and bug fixes for previous minor versions of uptool, in accordance with our Security Policy.</p>"},{"location":"patch-release-workflow/#overview","title":"Overview","text":"<p>uptool supports multiple minor versions simultaneously:</p> <ul> <li>Latest minor version (e.g., 0.2.x): Full support (features, bug fixes, security patches)</li> <li>Previous minor version (e.g., 0.1.x): Security patches only for 6 months after next minor release</li> <li>Older versions: No support</li> </ul>"},{"location":"patch-release-workflow/#workflow-files","title":"Workflow Files","text":""},{"location":"patch-release-workflow/#1-create-release-branch-create-release-branchyml","title":"1. Create Release Branch (<code>create-release-branch.yml</code>)","text":"<p>Purpose: Create a long-lived release branch for a minor version to enable backporting.</p> <p>When to use: After releasing a new minor version (e.g., after v0.2.0 is released, create <code>release-0.1</code> for backports).</p> <p>How to use:</p> <ol> <li>Go to Actions \u2192 Create Release Branch</li> <li>Click Run workflow</li> <li>Enter the minor version (e.g., <code>0.1</code>)</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Creates a <code>release-X.Y</code> branch from the latest <code>vX.Y.Z</code> tag</li> <li>Adds branch protection rules</li> <li>Creates a README explaining the branch purpose</li> </ul> <p>Example:</p> <pre><code>Input: 0.1\nResult: Creates branch `release-0.1` from tag `v0.1.0`\n</code></pre>"},{"location":"patch-release-workflow/#2-patch-release-patch-releaseyml","title":"2. Patch Release (<code>patch-release.yml</code>)","text":"<p>Purpose: Create a patch release (e.g., v0.1.1) from a release branch with security or bug fixes.</p> <p>When to use: After cherry-picking fixes to a release branch.</p> <p>How to use:</p> <ol> <li>Cherry-pick fixes to the release branch:</li> </ol> <pre><code>git checkout release-0.1\ngit cherry-pick &lt;commit-sha&gt;\ngit push origin release-0.1\n</code></pre> <ol> <li>Go to Actions \u2192 Patch Release</li> <li>Click Run workflow</li> <li>Configure:</li> <li>Release branch: <code>release-0.1</code></li> <li>Patch type: <code>security</code> or <code>bugfix</code></li> <li>Changelog notes (optional): Additional context</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Calculates the next patch version (e.g., 0.1.0 \u2192 0.1.1)</li> <li>Updates version files</li> <li>Builds and signs binaries for all platforms</li> <li>Generates SBOM</li> <li>Creates a GitHub release</li> <li>Updates the mutable minor tag (e.g., <code>v0.1</code> \u2192 <code>v0.1.1</code>)</li> </ul> <p>Example:</p> <pre><code>Branch: release-0.1\nCurrent: v0.1.0\nNext: v0.1.1 (security patch)\n</code></pre>"},{"location":"patch-release-workflow/#3-coordinate-security-patches-security-patchyml","title":"3. Coordinate Security Patches (<code>security-patch.yml</code>)","text":"<p>Purpose: Automate cherry-picking security fixes to multiple release branches.</p> <p>When to use: When a security vulnerability affects multiple versions.</p> <p>How to use:</p> <ol> <li> <p>Fix the vulnerability on <code>main</code> and note the commit SHA(s)</p> </li> <li> <p>Go to Actions \u2192 Coordinate Security Patches</p> </li> <li>Click Run workflow</li> <li>Configure:</li> <li>Advisory ID: <code>GHSA-xxxx-xxxx-xxxx</code> (if applicable)</li> <li>Affected versions: <code>0.1.x,0.2.x</code> (comma-separated)</li> <li>Severity: <code>critical</code>, <code>high</code>, <code>medium</code>, or <code>low</code></li> <li>Description: Brief explanation of the vulnerability</li> <li>Fix commits: <code>abc123,def456</code> (commit SHAs from main)</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Identifies which release branches need patches</li> <li>Creates patch branches for each affected version</li> <li>Cherry-picks the fix commits</li> <li>Creates PRs for each release branch</li> <li>If cherry-pick fails, creates an issue for manual backporting</li> </ul> <p>Example:</p> <pre><code>Affected: 0.1.x, 0.2.x\nCommits: abc123, def456\nResult:\n  - PR to release-0.1\n  - PR to release-0.2\n</code></pre>"},{"location":"patch-release-workflow/#quick-examples","title":"Quick Examples","text":"<p>Security patch: Fix on main \u2192 Run \"Coordinate Security Patches\" workflow \u2192 Review automated PRs \u2192 Run \"Patch Release\" for each branch \u2192 Publish advisory</p> <p>Bug fix: Cherry-pick to release branch \u2192 Run \"Patch Release\" workflow</p> <p>New release branch: Automatically created when promoting to stable (or use \"Create Release Branch\" workflow)</p>"},{"location":"patch-release-workflow/#release-branch-management","title":"Release Branch Management","text":""},{"location":"patch-release-workflow/#branch-naming","title":"Branch Naming","text":"<ul> <li>Format: <code>release-X.Y</code></li> <li>Examples: <code>release-0.1</code>, <code>release-1.0</code>, <code>release-1.2</code></li> </ul>"},{"location":"patch-release-workflow/#branch-protection","title":"Branch Protection","text":"<p>Release branches have the same protection as <code>main</code>:</p> <ul> <li>Required status checks</li> <li>Required PR reviews</li> <li>No force pushes</li> <li>No deletions</li> </ul>"},{"location":"patch-release-workflow/#support-timeline","title":"Support Timeline","text":"<pre><code>Timeline: Support for release-0.1\n\n0.1.0 released \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 0.2.0 released \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 +6 months \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\n     \u2502                            \u2502                            \u2502\n     \u251c\u2500 Full support              \u251c\u2500 Security patches only     \u251c\u2500 Archive\n     \u2502                            \u2502                            \u2502\nrelease-0.1 created               \u2502                       End of support\n</code></pre>"},{"location":"patch-release-workflow/#end-of-support","title":"End of Support","text":"<p>When a release branch reaches end of support:</p> <ol> <li>Announce end of support (1 month before)</li> <li>Final patch release (if needed)</li> <li>Archive the branch:</li> </ol> <pre><code>git tag archive/release-0.1 release-0.1\ngit push origin archive/release-0.1\n</code></pre> <ol> <li>Update documentation</li> <li>Close remaining PRs/issues for that branch</li> </ol>"},{"location":"patch-release-workflow/#versioning","title":"Versioning","text":""},{"location":"patch-release-workflow/#version-tags","title":"Version Tags","text":"<ul> <li>Immutable tags: <code>v0.1.0</code>, <code>v0.1.1</code>, <code>v0.2.0</code> (never change)</li> <li>Mutable tags: <code>v0.1</code>, <code>v0.2</code>, <code>v0</code> (updated with each patch)</li> </ul>"},{"location":"patch-release-workflow/#tag-updates","title":"Tag Updates","text":"<p>When creating a patch release (e.g., v0.1.1):</p> <ol> <li>Create immutable tag: <code>v0.1.1</code></li> <li>Update mutable minor tag: <code>v0.1</code> \u2192 <code>v0.1.1</code></li> <li>Do NOT update major tag: <code>v0</code> stays at latest minor (e.g., <code>v0.2.0</code>)</li> </ol>"},{"location":"patch-release-workflow/#github-action-pinning","title":"GitHub Action Pinning","text":"<p>Users can pin to different levels:</p> <pre><code># Exact version (most secure, no automatic updates)\n- uses: santosr2/uptool@v0.1.0\n\n# Minor version (gets security patches automatically)\n- uses: santosr2/uptool@v0.1\n\n# Major version (gets all updates in v0.x)\n- uses: santosr2/uptool@v0\n</code></pre>"},{"location":"patch-release-workflow/#troubleshooting","title":"Troubleshooting","text":"<p>Cherry-pick conflicts: Check created issue for manual backport instructions, resolve conflicts manually, run Patch Release workflow</p> <p>Missing release branch: Run \"Create Release Branch\" workflow first</p> <p>Failed workflow: Check logs, fix issues on release branch, re-run</p> <p>Wrong version: Delete tag, fix version files, re-run workflow</p>"},{"location":"patch-release-workflow/#best-practices","title":"Best Practices","text":"<ul> <li>Only backport critical security fixes and bugs</li> <li>Test patches thoroughly before release</li> <li>Announce security updates via advisories and releases</li> <li>Follow semantic versioning strictly</li> <li>Never change immutable tags or mix features with patches</li> </ul>"},{"location":"patch-release-workflow/#faq","title":"FAQ","text":"<p>When to create release branch? After releasing a new minor version (automated via Promote workflow)</p> <p>Support duration? 6 months security patches after next minor release</p> <p>Backport features? No, only security fixes and critical bugs</p> <p>Cherry-pick conflicts? Workflow creates an issue with manual instructions</p> <p>Update mutable tags? Automatic via workflow</p>"},{"location":"patch-release-workflow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Policy - Support timelines and reporting</li> <li>Contributing Guide - Development workflow</li> <li>Versioning Guide - Semantic versioning details</li> <li>Release Process - Main branch releases</li> </ul>"},{"location":"patch-release-workflow/#support","title":"Support","text":"<p>For questions about patch releases:</p> <ul> <li>GitHub Discussions: https://github.com/santosr2/uptool/discussions</li> <li>Security Issues: https://github.com/santosr2/uptool/security/advisories</li> </ul> <p>Last Updated: 2025-01-16 Maintained By: uptool maintainers</p>"},{"location":"plugin-development/","title":"Plugin Development","text":"<p>Create external plugins to extend uptool with custom integrations.</p>"},{"location":"plugin-development/#overview","title":"Overview","text":"<p>Built-in vs Plugin:</p> <ul> <li>Built-in: Compiled into uptool (npm, Helm, Terraform) - for widely-used ecosystems</li> <li>Plugin: External <code>.so</code> library - for custom/experimental/proprietary integrations</li> </ul> <p>Plugins allow custom integrations without forking uptool.</p>"},{"location":"plugin-development/#plugin-interface","title":"Plugin Interface","text":"<p>Implement the <code>engine.Integration</code> interface:</p> <pre><code>type Integration interface {\n    Name() string\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n    Plan(ctx context.Context, manifest *Manifest) (*UpdatePlan, error)\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p>Export a <code>RegisterWith</code> function:</p> <pre><code>func RegisterWith(register func(name string, constructor func() engine.Integration)) {\n    register(\"yourintegration\", New)\n}\n</code></pre>"},{"location":"plugin-development/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugin-development/#1-project-structure","title":"1. Project Structure","text":"<pre><code>my-plugin/\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 plugin.go       # Integration implementation\n\u2514\u2500\u2500 main.go         # Plugin entry point\n</code></pre>"},{"location":"plugin-development/#2-implement-integration","title":"2. Implement Integration","text":"<pre><code>// plugin.go\npackage main\n\nimport (\n    \"context\"\n    \"github.com/santosr2/uptool/internal/engine\"\n)\n\ntype MyIntegration struct{}\n\nfunc New() engine.Integration {\n    return &amp;MyIntegration{}\n}\n\nfunc (i *MyIntegration) Name() string {\n    return \"myintegration\"\n}\n\nfunc (i *MyIntegration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error) {\n    // Find manifest files\n    return manifests, nil\n}\n\nfunc (i *MyIntegration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error) {\n    // Query registry for updates\n    return plan, nil\n}\n\nfunc (i *MyIntegration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error) {\n    // Update manifest file\n    return result, nil\n}\n\nfunc (i *MyIntegration) Validate(ctx context.Context, manifest *engine.Manifest) error {\n    // Validate manifest syntax\n    return nil\n}\n</code></pre>"},{"location":"plugin-development/#3-plugin-entry-point","title":"3. Plugin Entry Point","text":"<pre><code>// main.go\npackage main\n\nimport \"github.com/santosr2/uptool/internal/engine\"\n\nfunc RegisterWith(register func(name string, constructor func() engine.Integration)) {\n    register(\"myintegration\", New)\n}\n\nfunc main() {}\n</code></pre>"},{"location":"plugin-development/#4-build-plugin","title":"4. Build Plugin","text":"<pre><code># Build as shared library\ngo build -buildmode=plugin -o myintegration.so .\n</code></pre>"},{"location":"plugin-development/#plugin-discovery","title":"Plugin Discovery","text":"<p>uptool searches for plugins in these locations (in order):</p> <ol> <li><code>./plugins/</code> - Current directory</li> <li><code>~/.config/uptool/plugins/</code> - User config</li> <li><code>/etc/uptool/plugins/</code> - System-wide</li> <li><code>$UPTOOL_PLUGIN_DIR</code> - Custom location</li> </ol> <p>Install:</p> <pre><code>mkdir -p ~/.config/uptool/plugins\ncp myintegration.so ~/.config/uptool/plugins/\n</code></pre> <p>Verify:</p> <pre><code>uptool list --experimental\n# Should show \"myintegration\"\n</code></pre>"},{"location":"plugin-development/#testing","title":"Testing","text":""},{"location":"plugin-development/#unit-tests","title":"Unit Tests","text":"<pre><code>// plugin_test.go\npackage main\n\nimport (\n    \"context\"\n    \"testing\"\n)\n\nfunc TestDetect(t *testing.T) {\n    integration := New()\n    manifests, err := integration.Detect(context.Background(), \"./testdata\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    if len(manifests) != 1 {\n        t.Errorf(\"expected 1 manifest, got %d\", len(manifests))\n    }\n}\n</code></pre>"},{"location":"plugin-development/#integration-testing","title":"Integration Testing","text":"<pre><code># Build and test\ngo build -buildmode=plugin -o myintegration.so .\ncp myintegration.so ~/.config/uptool/plugins/\nuptool scan --only=myintegration\n</code></pre>"},{"location":"plugin-development/#best-practices","title":"Best Practices","text":"<ol> <li>Version compatibility: Match uptool's Go version and dependencies</li> <li>Error handling: Return descriptive errors with context</li> <li>Logging: Use structured logging, avoid print statements</li> <li>Context: Respect context cancellation</li> <li>Resource cleanup: Close files, network connections</li> <li>Testing: &gt;70% coverage target</li> <li>Documentation: Add README with usage examples</li> </ol>"},{"location":"plugin-development/#example-plugin","title":"Example Plugin","text":"<p>See <code>examples/plugins/python/</code> for a complete example:</p> <ul> <li>Detects <code>pyproject.toml</code>, <code>requirements.txt</code>, <code>Pipfile</code></li> <li>Queries PyPI registry</li> <li>Updates dependency versions</li> </ul>"},{"location":"plugin-development/#distribution","title":"Distribution","text":""},{"location":"plugin-development/#github-release","title":"GitHub Release","text":"<pre><code># .goreleaser.yml\nbuilds:\n  - id: plugin\n    main: .\n    flags:\n      - -buildmode=plugin\n    goos: [linux, darwin]\n    goarch: [amd64, arm64]\n</code></pre>"},{"location":"plugin-development/#installation-script","title":"Installation Script","text":"<pre><code>#!/bin/bash\nPLUGIN_DIR=\"${HOME}/.config/uptool/plugins\"\nmkdir -p \"$PLUGIN_DIR\"\ncurl -LO \"https://github.com/you/plugin/releases/latest/download/plugin-$(uname -s)-$(uname -m).so\"\nmv plugin-*.so \"$PLUGIN_DIR/myplugin.so\"\n</code></pre>"},{"location":"plugin-development/#limitations","title":"Limitations","text":"<ul> <li>Plugin must be compiled with same Go version as uptool</li> <li>Shared libraries are OS/arch specific</li> <li>Cannot modify core engine behavior</li> <li>Plugin crashes may crash uptool</li> </ul>"},{"location":"plugin-development/#see-also","title":"See Also","text":"<ul> <li>Integration Examples - Built-in integration code</li> <li>API Reference - Engine API documentation</li> <li>CONTRIBUTING.md - Development guidelines</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get up and running with uptool in 5 minutes!</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have uptool installed. If not, see the Installation Guide.</p> <pre><code>uptool version\n</code></pre>"},{"location":"quickstart/#step-1-initialize-your-project","title":"Step 1: Initialize Your Project","text":"<p>Navigate to your project directory:</p> <pre><code>cd your-project\n</code></pre>"},{"location":"quickstart/#step-2-scan-for-dependencies","title":"Step 2: Scan for Dependencies","text":"<p>Scan your project to detect supported manifest files and check for outdated dependencies:</p> <pre><code>uptool scan\n</code></pre> <p>Example output:</p> <pre><code>Found 5 manifest files:\n  \u2705 package.json (npm)\n  \u2705 Chart.yaml (helm)\n  \u2705 main.tf (terraform)\n  \u2705 .pre-commit-config.yaml (precommit)\n  \u2705 mise.toml (mise)\n\nScanning for updates...\n</code></pre>"},{"location":"quickstart/#step-3-plan-updates","title":"Step 3: Plan Updates","text":"<p>Preview what would be updated without making changes:</p> <pre><code>uptool plan\n</code></pre> <p>Example output:</p> <pre><code>Updates available:\n\nnpm (package.json):\n  - react: 18.2.0 \u2192 18.3.1\n  - typescript: 5.0.0 \u2192 5.4.5\n\nterraform (main.tf):\n  - aws: 5.0.0 \u2192 5.70.0\n\nprecommit (.pre-commit-config.yaml):\n  - golangci-lint: v1.63.4 \u2192 v2.6.2\n</code></pre> <p>Dry Run</p> <p>The <code>plan</code> command never modifies files. It only shows what would change.</p>"},{"location":"quickstart/#step-4-apply-updates","title":"Step 4: Apply Updates","text":"<p>Apply the updates with a diff preview:</p> <pre><code>uptool update --diff\n</code></pre> <p>This will:</p> <ol> <li>Update manifest files</li> <li>Show a diff of changes</li> <li>Preserve formatting and comments</li> <li>Validate the changes</li> </ol> <p>Example diff output:</p> <pre><code>--- package.json\n+++ package.json\n@@ -5,7 +5,7 @@\n   \"dependencies\": {\n-    \"react\": \"^18.2.0\",\n+    \"react\": \"^18.3.1\",\n-    \"typescript\": \"^5.0.0\"\n+    \"typescript\": \"^5.4.5\"\n   }\n }\n</code></pre>"},{"location":"quickstart/#step-5-review-and-commit","title":"Step 5: Review and Commit","text":"<p>After uptool applies the updates, review the changes:</p> <pre><code>git diff\n</code></pre> <p>Commit the changes:</p> <pre><code>git add .\ngit commit -m \"chore(deps): update dependencies via uptool\"\ngit push\n</code></pre>"},{"location":"quickstart/#advanced-usage","title":"Advanced Usage","text":""},{"location":"quickstart/#filter-by-integration","title":"Filter by Integration","text":"<p>Update only specific integrations:</p> <pre><code># Update only npm packages\nuptool update --only npm\n\n# Update everything except terraform\nuptool update --exclude terraform\n</code></pre>"},{"location":"quickstart/#dry-run-mode","title":"Dry Run Mode","text":"<p>Preview changes without applying:</p> <pre><code>uptool update --dry-run\n</code></pre>"},{"location":"quickstart/#quiet-mode","title":"Quiet Mode","text":"<p>Suppress informational output (errors only):</p> <pre><code>uptool update --quiet\n</code></pre>"},{"location":"quickstart/#verbose-mode","title":"Verbose Mode","text":"<p>Get detailed debug output:</p> <pre><code>uptool scan --verbose\n</code></pre>"},{"location":"quickstart/#configuration-file","title":"Configuration File","text":"<p>Create a <code>uptool.yaml</code> configuration file to customize behavior:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor           # none, patch, minor, major\n      allow_prerelease: false\n\n  - id: terraform\n    enabled: true\n    policy:\n      update: major\n      allow_prerelease: false\n\n  - id: helm\n    enabled: false  # Skip Helm charts\n</code></pre> <p>See the Configuration Guide for more details.</p>"},{"location":"quickstart/#using-as-a-github-action","title":"Using as a GitHub Action","text":"<p>Add uptool to your CI/CD pipeline:</p> <pre><code>name: Dependency Updates\n\non:\n  schedule:\n    - cron: '0 0 * * 1'  # Weekly on Monday\n  workflow_dispatch:\n\njobs:\n  update-dependencies:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run uptool\n        uses: santosr2/uptool@v0.1\n        with:\n          command: update\n          create-pr: true\n</code></pre> <p>See the GitHub Action Usage Guide for more examples.</p>"},{"location":"quickstart/#example-configurations","title":"Example Configurations","text":"<p>See the examples/ directory for sample configurations: uptool.yaml, uptool-minimal.yaml, uptool-monorepo.yaml</p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Customize uptool behavior</li> <li>Integrations - Learn about supported ecosystems</li> <li>GitHub Action Usage - Automate dependency updates</li> <li>Plugin Development - Add custom integrations</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions for uptool.</p>"},{"location":"troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":"<pre><code># Run with verbose logging\nuptool scan --verbose\n\n# Check version\nuptool --version\n\n# Verify manifest files exist\nls package.json Chart.yaml mise.toml .tool-versions\n</code></pre>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#no-manifests-detected","title":"No manifests detected","text":"<p>Check: Run from correct directory, verify manifest files exist, check <code>.gitignore</code></p> <pre><code>pwd &amp;&amp; ls -la package.json Chart.yaml\nuptool scan --verbose\n</code></pre>"},{"location":"troubleshooting/#registry-query-failed","title":"Registry query failed","text":"<p>Causes: Network issues, rate limiting, authentication</p> <p>Solutions:</p> <ul> <li>Test connectivity: <code>curl -I https://registry.npmjs.org</code></li> <li>For private packages: Configure <code>.npmrc</code> (npm) or <code>helm repo add</code> (helm)</li> <li>Check rate limits: Use <code>GITHUB_TOKEN</code> env var</li> </ul>"},{"location":"troubleshooting/#manifest-parsing-failed","title":"Manifest parsing failed","text":"<p>Check: Validate syntax with <code>yamllint</code>, <code>jq</code>, or online validators</p> <pre><code>yamllint Chart.yaml\njq . package.json\n</code></pre>"},{"location":"troubleshooting/#permission-denied","title":"Permission denied","text":"<p>Solutions:</p> <pre><code># Fix binary permissions\nchmod +x /usr/local/bin/uptool\n\n# Or install to user directory\ngo install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"troubleshooting/#command-not-found","title":"Command not found","text":"<p>Check PATH:</p> <pre><code>echo $PATH\nwhich uptool\n\n# Add to PATH\nexport PATH=\"$PATH:/usr/local/bin\"\n</code></pre>"},{"location":"troubleshooting/#installation-script-fails","title":"Installation script fails","text":"<p>Alternatives:</p> <pre><code># Download binary directly\ncurl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-$(uname -s)-$(uname -m)\n\n# Or build from source\ngit clone https://github.com/santosr2/uptool\ncd uptool &amp;&amp; mise run build\n</code></pre>"},{"location":"troubleshooting/#integration-specific","title":"Integration-Specific","text":""},{"location":"troubleshooting/#npm","title":"npm","text":"<p>Lockfile out of sync: Run <code>npm install</code> after uptool updates Peer dependency conflict: Check <code>npm install</code> output for warnings</p>"},{"location":"troubleshooting/#helm","title":"Helm","text":"<p>Repository not found: Add repository: <code>helm repo add &lt;name&gt; &lt;url&gt;</code> API version mismatch: Update Helm client to compatible version</p>"},{"location":"troubleshooting/#terraform","title":"Terraform","text":"<p>Provider constraint invalid: Check <code>.tf</code> syntax with <code>terraform validate</code> Provider not available: Run <code>terraform init</code> after updates</p>"},{"location":"troubleshooting/#miseasdf","title":"mise/asdf","text":"<p>Tool not installed: Run <code>mise install</code> or <code>asdf install</code> after updates</p>"},{"location":"troubleshooting/#performance","title":"Performance","text":""},{"location":"troubleshooting/#slow-scans","title":"Slow scans","text":"<ul> <li>Use <code>--only</code> flag to limit integrations</li> <li>Check network latency to registries</li> <li>Increase timeout: <code>--timeout=60s</code></li> </ul>"},{"location":"troubleshooting/#high-memory-usage","title":"High memory usage","text":"<ul> <li>Scan one integration at a time: <code>--only=npm</code></li> <li>Reduce concurrency in large monorepos</li> </ul>"},{"location":"troubleshooting/#debug-mode","title":"Debug Mode","text":""},{"location":"troubleshooting/#environment-variables","title":"Environment Variables","text":"<pre><code># Enable debug logging\nexport UPTOOL_LOG_LEVEL=debug\n\n# Increase timeout\nexport UPTOOL_TIMEOUT=60\n\n# Use GitHub token (higher rate limits)\nexport GITHUB_TOKEN=ghp_xxxx\n</code></pre>"},{"location":"troubleshooting/#verbose-output","title":"Verbose Output","text":"<pre><code># All commands support -v flag\nuptool scan -v\nuptool plan --verbose\nuptool update -v --dry-run\n</code></pre>"},{"location":"troubleshooting/#configuration-issues","title":"Configuration Issues","text":""},{"location":"troubleshooting/#config-not-loaded","title":"Config not loaded","text":"<p>Check: File must be named <code>uptool.yaml</code> (not <code>.yml</code>) in repository root</p>"},{"location":"troubleshooting/#integration-not-running","title":"Integration not running","text":"<p>Verify:</p> <ul> <li><code>enabled: true</code> in config</li> <li>No CLI overrides (<code>--exclude</code>)</li> <li>File patterns match: <code>uptool scan -v</code></li> </ul>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<ol> <li>Check logs: Run with <code>--verbose</code></li> <li>Search issues: GitHub Issues</li> <li>Ask questions: GitHub Discussions</li> <li>Report bugs: Include <code>uptool --version</code>, logs, and manifest example</li> </ol>"},{"location":"troubleshooting/#useful-information-for-bug-reports","title":"Useful Information for Bug Reports","text":"<pre><code># System info\nuptool --version\ngo version\nuname -a\n\n# Verbose output\nuptool scan --verbose &gt; debug.log 2&gt;&amp;1\n\n# Configuration\ncat uptool.yaml\n</code></pre>"},{"location":"troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Config file options</li> <li>Integration Guides - Integration-specific docs</li> <li>CLI Reference - Command usage</li> </ul>"},{"location":"versioning/","title":"Version Management","text":"<p>Automated semantic versioning via conventional commits and GitHub Actions.</p>"},{"location":"versioning/#overview","title":"Overview","text":"<ol> <li>Conventional commits determine version bumps</li> <li>GitHub Actions calculate and apply versions</li> <li><code>bump-my-version</code> updates all files</li> <li><code>internal/version/VERSION</code> is the single source of truth</li> </ol>"},{"location":"versioning/#conventional-commits","title":"Conventional Commits","text":"Type Bump Example <code>feat:</code> Minor (0.1.0 \u2192 0.2.0) <code>feat: add Python integration</code> <code>fix:</code> Patch (0.1.0 \u2192 0.1.1) <code>fix: handle empty manifests</code> <code>feat!:</code> or <code>BREAKING CHANGE:</code> Major (0.1.0 \u2192 1.0.0) <code>feat!: redesign API</code> <code>docs:</code>, <code>chore:</code>, <code>test:</code> None <code>docs: update README</code> <p>Format: <code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></p> <p>Breaking changes: Use <code>feat!:</code> or add <code>BREAKING CHANGE:</code> footer</p>"},{"location":"versioning/#local-development","title":"Local Development","text":"<pre><code># Show current version\nmise run version-show\n\n# Bump for testing only (don't commit to PRs)\nmise run version-bump-patch   # 0.1.0 \u2192 0.1.1\nmise run version-bump-minor   # 0.1.0 \u2192 0.2.0\nmise run version-bump-major   # 0.1.0 \u2192 1.0.0\n</code></pre> <p>Production releases are automated via GitHub Actions.</p>"},{"location":"versioning/#release-process","title":"Release Process","text":""},{"location":"versioning/#pre-release","title":"Pre-Release","text":"<ol> <li>Maintainer triggers pre-release workflow</li> <li>System calculates version from commits</li> <li>Approval gate (designated reviewers)</li> <li>Creates pre-release (e.g., <code>v0.2.0-rc1</code>, <code>v0.2.0-beta3</code>, <code>v0.2.0-alpha20250708</code>)</li> <li>Builds artifacts</li> </ol>"},{"location":"versioning/#stable-release","title":"Stable Release","text":"<ol> <li>Maintainer triggers promote workflow</li> <li>Extracts stable version (<code>v0.2.0-rc1</code> \u2192 <code>v0.2.0</code>)</li> <li>Approval gate (multiple reviewers)</li> <li>Promotes artifacts</li> <li>Updates CHANGELOG</li> </ol> <p>See environments.md for approval gate setup.</p>"},{"location":"versioning/#version-tags","title":"Version Tags","text":"<p>Immutable (never change):</p> <ul> <li>Stable: <code>v0.1.0</code>, <code>v0.2.0</code>, <code>v1.13.0</code></li> <li>Pre-release: <code>v0.2.0-rc1</code>, <code>v1.0.0-beta3</code>, <code>v1.13.0-alpha20250708</code></li> </ul> <p>Mutable (auto-updated for GitHub Actions):</p> <ul> <li><code>v0</code> \u2192 latest <code>v0.x.x</code> stable</li> <li><code>v0.1</code> \u2192 latest <code>v0.1.x</code> patch</li> <li><code>v0-rc</code>, <code>v0-beta</code>, <code>v0-alpha</code> \u2192 latest <code>v0.x.x</code> pre-release of each type</li> </ul> <p>Usage:</p> <pre><code># Recommended\n- uses: santosr2/uptool@v0\n\n# Pin to minor\n- uses: santosr2/uptool@v0.1\n\n# Pin to exact version\n- uses: santosr2/uptool@v0.1.0\n</code></pre>"},{"location":"versioning/#files-updated-automatically","title":"Files Updated Automatically","text":"<p>When versions change, <code>bump-my-version</code> updates:</p> <ul> <li><code>internal/version/VERSION</code> - Source of truth</li> <li><code>README.md</code> - Action version examples</li> <li><code>SECURITY.md</code> - Supported versions</li> <li><code>docs/action-usage.md</code> - Usage examples</li> </ul>"},{"location":"versioning/#configuration","title":"Configuration","text":"<p>Location: <code>.bumpversion.toml</code></p> <p>Defines version format, files to update, and search/replace patterns.</p>"},{"location":"versioning/#workflows","title":"Workflows","text":"<ul> <li><code>.github/workflows/pre-release.yml</code> - Create RC/beta/alpha releases</li> <li><code>.github/workflows/promote-release.yml</code> - Promote to stable</li> <li><code>.github/workflows/patch-release.yml</code> - Security/bugfix patches</li> <li><code>.github/workflows/create-release-branch.yml</code> - Branch for patches</li> </ul>"},{"location":"versioning/#best-practices","title":"Best Practices","text":"<ol> <li>Contributors: Write conventional commits, don't bump versions manually</li> <li>Maintainers: Use workflows, never push version tags directly</li> <li>Testing: Use local bump commands, don't commit version changes</li> <li>Pre-releases: Test thoroughly before promoting to stable</li> </ol>"},{"location":"versioning/#see-also","title":"See Also","text":"<ul> <li>CONTRIBUTING.md - Conventional commit guidelines</li> <li>environments.md - Approval gate configuration</li> <li>Conventional Commits</li> <li>Semantic Versioning</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#scripts","title":"scripts","text":"<pre><code>import \"github.com/santosr2/uptool/scripts\"\n</code></pre> <p>Command gen_integrations generates the all.go file that imports all integrations. This ensures that adding a new integration doesn't require manual updates.</p> <p>Usage:</p> <pre><code>go run scripts/gen_integrations.go\n</code></pre> <p>Or via go generate:</p> <pre><code>go generate ./internal/integrations\n</code></pre>"},{"location":"api/#index","title":"Index","text":""},{"location":"api/#uptool","title":"uptool","text":"<pre><code>import \"github.com/santosr2/uptool/cmd/uptool\"\n</code></pre> <p>uptool is a manifest-first dependency updater for multiple ecosystems. It scans repositories for dependency manifest files \\(package.json, Chart.yaml, .pre\\-commit\\-config.yaml, etc.\\), checks for available updates, and rewrites manifests with new versions while preserving formatting.</p>"},{"location":"api/#index_1","title":"Index","text":""},{"location":"api/#datasource","title":"datasource","text":"<pre><code>import \"github.com/santosr2/uptool/internal/datasource\"\n</code></pre> <p>Package datasource provides a unified interface for querying package registries. This abstraction allows multiple integrations to share the same registry client.</p>"},{"location":"api/#index_2","title":"Index","text":"<ul> <li>func List() []string</li> <li>func Register\\(ds Datasource\\)</li> <li>type Datasource</li> <li>func Get\\(name string\\) \\(Datasource, error\\)</li> <li>type GitHubDatasource</li> <li>func NewGitHubDatasource() *GitHubDatasource</li> <li>func \\(d \\*GitHubDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) Name() string</li> <li>type HelmDatasource</li> <li>func NewHelmDatasource() *HelmDatasource</li> <li>func \\(d \\*HelmDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*HelmDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*HelmDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*HelmDatasource\\) Name() string</li> <li>type NPMDatasource</li> <li>func NewNPMDatasource() *NPMDatasource</li> <li>func \\(d \\*NPMDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*NPMDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*NPMDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*NPMDatasource\\) Name() string</li> <li>type PackageInfo</li> <li>type TerraformDatasource</li> <li>func NewTerraformDatasource() *TerraformDatasource</li> <li>func \\(d \\*TerraformDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) Name() string</li> <li>type VersionInfo</li> </ul>"},{"location":"api/#func-list","title":"func List","text":"<pre><code>func List() []string\n</code></pre> <p>List returns all registered datasource names.</p> <p></p>"},{"location":"api/#func-register","title":"func Register","text":"<pre><code>func Register(ds Datasource)\n</code></pre> <p>Register adds a datasource to the global registry.</p> <p></p>"},{"location":"api/#type-datasource","title":"type Datasource","text":"<p>Datasource represents a package registry or version source.</p> <pre><code>type Datasource interface {\n    // Name returns the datasource identifier (e.g., \"npm\", \"pypi\", \"github-releases\")\n    Name() string\n\n    // GetLatestVersion returns the latest stable version for a package.\n    GetLatestVersion(ctx context.Context, pkg string) (string, error)\n\n    // GetVersions returns all available versions for a package.\n    GetVersions(ctx context.Context, pkg string) ([]string, error)\n\n    // GetPackageInfo returns detailed information about a package.\n    GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n}\n</code></pre> <p></p>"},{"location":"api/#func-get","title":"func Get","text":"<pre><code>func Get(name string) (Datasource, error)\n</code></pre> <p>Get returns a datasource by name.</p> <p></p>"},{"location":"api/#type-githubdatasource","title":"type GitHubDatasource","text":"<p>GitHubDatasource implements the Datasource interface for GitHub Releases.</p> <pre><code>type GitHubDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgithubdatasource","title":"func NewGitHubDatasource","text":"<pre><code>func NewGitHubDatasource() *GitHubDatasource\n</code></pre> <p>NewGitHubDatasource creates a new GitHub datasource.</p> <p></p>"},{"location":"api/#func-githubdatasource-getlatestversion","title":"func \\(\\*GitHubDatasource\\) GetLatestVersion","text":"<pre><code>func (d *GitHubDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable release for a GitHub repository.</p> <p></p>"},{"location":"api/#func-githubdatasource-getpackageinfo","title":"func \\(\\*GitHubDatasource\\) GetPackageInfo","text":"<pre><code>func (d *GitHubDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a GitHub repository's releases.</p> <p></p>"},{"location":"api/#func-githubdatasource-getversions","title":"func \\(\\*GitHubDatasource\\) GetVersions","text":"<pre><code>func (d *GitHubDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available releases for a GitHub repository.</p> <p></p>"},{"location":"api/#func-githubdatasource-name","title":"func \\(\\*GitHubDatasource\\) Name","text":"<pre><code>func (d *GitHubDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-helmdatasource","title":"type HelmDatasource","text":"<p>HelmDatasource implements the Datasource interface for Helm chart repositories.</p> <pre><code>type HelmDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newhelmdatasource","title":"func NewHelmDatasource","text":"<pre><code>func NewHelmDatasource() *HelmDatasource\n</code></pre> <p>NewHelmDatasource creates a new Helm datasource.</p> <p></p>"},{"location":"api/#func-helmdatasource-getlatestversion","title":"func \\(\\*HelmDatasource\\) GetLatestVersion","text":"<pre><code>func (d *HelmDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-getpackageinfo","title":"func \\(\\*HelmDatasource\\) GetPackageInfo","text":"<pre><code>func (d *HelmDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-getversions","title":"func \\(\\*HelmDatasource\\) GetVersions","text":"<pre><code>func (d *HelmDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-name","title":"func \\(\\*HelmDatasource\\) Name","text":"<pre><code>func (d *HelmDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-npmdatasource","title":"type NPMDatasource","text":"<p>NPMDatasource implements the Datasource interface for the npm registry.</p> <pre><code>type NPMDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newnpmdatasource","title":"func NewNPMDatasource","text":"<pre><code>func NewNPMDatasource() *NPMDatasource\n</code></pre> <p>NewNPMDatasource creates a new npm datasource.</p> <p></p>"},{"location":"api/#func-npmdatasource-getlatestversion","title":"func \\(\\*NPMDatasource\\) GetLatestVersion","text":"<pre><code>func (d *NPMDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-getpackageinfo","title":"func \\(\\*NPMDatasource\\) GetPackageInfo","text":"<pre><code>func (d *NPMDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-getversions","title":"func \\(\\*NPMDatasource\\) GetVersions","text":"<pre><code>func (d *NPMDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-name","title":"func \\(\\*NPMDatasource\\) Name","text":"<pre><code>func (d *NPMDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-packageinfo","title":"type PackageInfo","text":"<p>PackageInfo contains metadata about a package.</p> <pre><code>type PackageInfo struct {\n    Name        string\n    Description string\n    Homepage    string\n    Repository  string\n    Versions    []VersionInfo\n}\n</code></pre> <p></p>"},{"location":"api/#type-terraformdatasource","title":"type TerraformDatasource","text":"<p>TerraformDatasource implements the Datasource interface for the Terraform Registry.</p> <pre><code>type TerraformDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newterraformdatasource","title":"func NewTerraformDatasource","text":"<pre><code>func NewTerraformDatasource() *TerraformDatasource\n</code></pre> <p>NewTerraformDatasource creates a new Terraform datasource.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getlatestversion","title":"func \\(\\*TerraformDatasource\\) GetLatestVersion","text":"<pre><code>func (d *TerraformDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getpackageinfo","title":"func \\(\\*TerraformDatasource\\) GetPackageInfo","text":"<pre><code>func (d *TerraformDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getversions","title":"func \\(\\*TerraformDatasource\\) GetVersions","text":"<pre><code>func (d *TerraformDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-name","title":"func \\(\\*TerraformDatasource\\) Name","text":"<pre><code>func (d *TerraformDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-versioninfo","title":"type VersionInfo","text":"<p>VersionInfo contains metadata about a specific version.</p> <pre><code>type VersionInfo struct {\n    Version      string\n    PublishedAt  string\n    IsPrerelease bool\n    Deprecated   bool\n}\n</code></pre>"},{"location":"api/#engine","title":"engine","text":"<pre><code>import \"github.com/santosr2/uptool/internal/engine\"\n</code></pre> <p>Package engine provides the core orchestration layer for uptool. It manages integration registration, manifest scanning, update planning, and update application. The Engine coordinates concurrent operations across multiple integrations while handling errors and logging.</p> <p>Package engine provides the core orchestration layer for uptool's dependency scanning and updating. It defines the fundamental types and interfaces used across all integrations, including Manifest, Dependency, UpdatePlan, and the Integration interface.</p>"},{"location":"api/#index_3","title":"Index","text":"<ul> <li>type ApplyResult</li> <li>type Dependency</li> <li>type Engine</li> <li>func NewEngine\\(logger \\*slog.Logger\\) *Engine</li> <li>func \\(e \\*Engine\\) GetIntegration\\(name string\\) \\(Integration, bool\\)</li> <li>func \\(e \\*Engine\\) ListIntegrations() []string</li> <li>func \\(e \\*Engine\\) Plan\\(ctx context.Context, manifests \\[\\]\\*Manifest\\) \\(\\*PlanResult, error\\)</li> <li>func \\(e \\*Engine\\) Register\\(integration Integration\\)</li> <li>func \\(e \\*Engine\\) Scan\\(ctx context.Context, repoRoot string, only, exclude \\[\\]string\\) \\(\\*ScanResult, error\\)</li> <li>func \\(e \\*Engine\\) Update\\(ctx context.Context, plans \\[\\]\\*UpdatePlan, dryRun bool\\) \\(\\*UpdateResult, error\\)</li> <li>type Impact</li> <li>type Integration</li> <li>type IntegrationPolicy</li> <li>type Manifest</li> <li>type PlanResult</li> <li>type ScanResult</li> <li>type Update</li> <li>type UpdatePlan</li> <li>type UpdateResult</li> </ul>"},{"location":"api/#type-applyresult","title":"type ApplyResult","text":"<p>ApplyResult contains the outcome of applying updates.</p> <pre><code>type ApplyResult struct {\n    Manifest     *Manifest `json:\"manifest\"`\n    ManifestDiff string    `json:\"manifest_diff,omitempty\"`\n    LockfileDiff string    `json:\"lockfile_diff,omitempty\"`\n    Errors       []string  `json:\"errors,omitempty\"`\n    Applied      int       `json:\"applied\"`\n    Failed       int       `json:\"failed\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependency","title":"type Dependency","text":"<p>Dependency represents a single dependency in a manifest.</p> <pre><code>type Dependency struct {\n    Name           string `json:\"name\"`\n    CurrentVersion string `json:\"current_version\"`\n    Constraint     string `json:\"constraint,omitempty\"`\n    Type           string `json:\"type\"` // direct, dev, peer, optional\n    Registry       string `json:\"registry,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-engine","title":"type Engine","text":"<p>Engine orchestrates the scan, plan, and update operations.</p> <pre><code>type Engine struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newengine","title":"func NewEngine","text":"<pre><code>func NewEngine(logger *slog.Logger) *Engine\n</code></pre> <p>NewEngine creates a new engine with the given integrations.</p> <p></p>"},{"location":"api/#func-engine-getintegration","title":"func \\(\\*Engine\\) GetIntegration","text":"<pre><code>func (e *Engine) GetIntegration(name string) (Integration, bool)\n</code></pre> <p>GetIntegration retrieves a registered integration by name.</p> <p></p>"},{"location":"api/#func-engine-listintegrations","title":"func \\(\\*Engine\\) ListIntegrations","text":"<pre><code>func (e *Engine) ListIntegrations() []string\n</code></pre> <p>ListIntegrations returns all registered integration names.</p> <p></p>"},{"location":"api/#func-engine-plan","title":"func \\(\\*Engine\\) Plan","text":"<pre><code>func (e *Engine) Plan(ctx context.Context, manifests []*Manifest) (*PlanResult, error)\n</code></pre> <p>Plan generates update plans for all manifests.</p> <p></p>"},{"location":"api/#func-engine-register","title":"func \\(\\*Engine\\) Register","text":"<pre><code>func (e *Engine) Register(integration Integration)\n</code></pre> <p>Register adds an integration to the engine.</p> <p></p>"},{"location":"api/#func-engine-scan","title":"func \\(\\*Engine\\) Scan","text":"<pre><code>func (e *Engine) Scan(ctx context.Context, repoRoot string, only, exclude []string) (*ScanResult, error)\n</code></pre> <p>Scan discovers all manifests across registered integrations.</p> <p></p>"},{"location":"api/#func-engine-update","title":"func \\(\\*Engine\\) Update","text":"<pre><code>func (e *Engine) Update(ctx context.Context, plans []*UpdatePlan, dryRun bool) (*UpdateResult, error)\n</code></pre> <p>Update applies update plans.</p> <p></p>"},{"location":"api/#type-impact","title":"type Impact","text":"<p>Impact describes the severity of an update.</p> <pre><code>type Impact string\n</code></pre> <p>Impact levels for update severity</p> <pre><code>const (\n    ImpactNone  Impact = \"none\"\n    ImpactPatch Impact = \"patch\"\n    ImpactMinor Impact = \"minor\"\n    ImpactMajor Impact = \"major\"\n)\n</code></pre> <p></p>"},{"location":"api/#type-integration","title":"type Integration","text":"<p>Integration defines the interface for ecosystem integrations.</p> <pre><code>type Integration interface {\n    // Name returns the integration identifier\n    Name() string\n\n    // Detect finds manifest files for this integration\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n\n    // Plan determines available updates for a manifest\n    Plan(ctx context.Context, manifest *Manifest) (*UpdatePlan, error)\n\n    // Apply executes the update plan\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n\n    // Validate checks if changes are valid (optional)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p></p>"},{"location":"api/#type-integrationpolicy","title":"type IntegrationPolicy","text":"<p>IntegrationPolicy contains policy settings that apply to a specific integration.</p> <pre><code>type IntegrationPolicy struct {\n    Custom          map[string]interface{} `yaml:\",inline\" json:\"custom,omitempty\"`\n    Update          string                 `yaml:\"update\" json:\"update\"`\n    Cadence         string                 `yaml:\"cadence,omitempty\" json:\"cadence,omitempty\"`\n    Enabled         bool                   `yaml:\"enabled\" json:\"enabled\"`\n    AllowPrerelease bool                   `yaml:\"allow_prerelease\" json:\"allow_prerelease\"`\n    Pin             bool                   `yaml:\"pin\" json:\"pin\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-manifest","title":"type Manifest","text":"<p>Manifest represents a dependency manifest file.</p> <pre><code>type Manifest struct {\n    Metadata     map[string]interface{} `json:\"metadata,omitempty\"`\n    Path         string                 `json:\"path\"`\n    Type         string                 `json:\"type\"`\n    Dependencies []Dependency           `json:\"dependencies\"`\n    Content      []byte                 `json:\"-\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-planresult","title":"type PlanResult","text":"<p>PlanResult aggregates all update plans.</p> <pre><code>type PlanResult struct {\n    Plans     []*UpdatePlan `json:\"plans\"`\n    Timestamp time.Time     `json:\"timestamp\"`\n    Errors    []string      `json:\"errors,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-scanresult","title":"type ScanResult","text":"<p>ScanResult aggregates all discovered manifests.</p> <pre><code>type ScanResult struct {\n    Manifests []*Manifest `json:\"manifests\"`\n    Timestamp time.Time   `json:\"timestamp\"`\n    RepoRoot  string      `json:\"repo_root\"`\n    Errors    []string    `json:\"errors,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-update","title":"type Update","text":"<p>Update represents a planned update for a dependency.</p> <pre><code>type Update struct {\n    Dependency    Dependency `json:\"dependency\"`\n    TargetVersion string     `json:\"target_version\"`\n    Impact        string     `json:\"impact\"` // patch, minor, major\n    ChangelogURL  string     `json:\"changelog_url,omitempty\"`\n    Breaking      bool       `json:\"breaking\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updateplan","title":"type UpdatePlan","text":"<p>UpdatePlan describes planned updates for a manifest.</p> <pre><code>type UpdatePlan struct {\n    Manifest *Manifest `json:\"manifest\"`\n    Strategy string    `json:\"strategy\"`\n    Updates  []Update  `json:\"updates\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updateresult","title":"type UpdateResult","text":"<p>UpdateResult aggregates all apply results.</p> <pre><code>type UpdateResult struct {\n    Results   []*ApplyResult `json:\"results\"`\n    Timestamp time.Time      `json:\"timestamp\"`\n    Errors    []string       `json:\"errors,omitempty\"`\n}\n</code></pre>"},{"location":"api/#integrations","title":"integrations","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations\"\n</code></pre> <p>Package integrations provides metadata about available integrations.</p> <p>Package integrations provides a central registry for all integration implementations. Integrations can be built-in \\(compiled into the binary\\) or external \\(loaded as plugins\\).</p> <p>Package integrations provides shared utilities for integration implementations.</p>"},{"location":"api/#index_4","title":"Index","text":"<ul> <li>func ClearCache()</li> <li>func Count() int</li> <li>func Get\\(name string\\) \\(engine.Integration, error\\)</li> <li>func GetAll() map[string]engine.Integration</li> <li>func GetLazy() map[string]func() engine.Integration</li> <li>func IsDisabled\\(name string\\) bool</li> <li>func IsExperimental\\(name string\\) bool</li> <li>func List() []string</li> <li>func ListByCategory\\(category string\\) \\(map\\[string\\]Metadata, error\\)</li> <li>func ListIntegrations() \\(map\\[string\\]Metadata, error\\)</li> <li>func Register\\(name string, constructor func\\(\\) engine.Integration)</li> <li>func ReloadPlugins() error</li> <li>func ValidateFilePath\\(path string\\) error</li> <li>type CategoryMetadata</li> <li>type DatasourceMetadata</li> <li>type Metadata</li> <li>func GetMetadata\\(name string\\) \\(\\*Metadata, error\\)</li> <li>type RegistryMetadata</li> <li>func LoadMetadata() \\(\\*RegistryMetadata, error\\)</li> </ul>"},{"location":"api/#func-clearcache","title":"func ClearCache","text":"<pre><code>func ClearCache()\n</code></pre> <p>ClearCache clears all cached instances, forcing reinitialization on next access. Useful for testing or when integrations need to be refreshed.</p> <p></p>"},{"location":"api/#func-count","title":"func Count","text":"<pre><code>func Count() int\n</code></pre> <p>Count returns the number of registered integrations.</p> <p></p>"},{"location":"api/#func-get_1","title":"func Get","text":"<pre><code>func Get(name string) (engine.Integration, error)\n</code></pre> <p>Get returns a single integration by name, creating it lazily if needed. This is more efficient than GetAll() when you only need specific integrations.</p> <p></p>"},{"location":"api/#func-getall","title":"func GetAll","text":"<pre><code>func GetAll() map[string]engine.Integration\n</code></pre> <p>GetAll returns a map of all registered integrations. Uses lazy loading - only creates instances for integrations that haven't been created yet.</p> <p></p>"},{"location":"api/#func-getlazy","title":"func GetLazy","text":"<pre><code>func GetLazy() map[string]func() engine.Integration\n</code></pre> <p>GetLazy returns a map of constructors \\(not instances\\). Use this when you want to defer instantiation until actual use.</p> <p></p>"},{"location":"api/#func-isdisabled","title":"func IsDisabled","text":"<pre><code>func IsDisabled(name string) bool\n</code></pre> <p>IsDisabled checks if an integration is disabled in the registry.</p> <p></p>"},{"location":"api/#func-isexperimental","title":"func IsExperimental","text":"<pre><code>func IsExperimental(name string) bool\n</code></pre> <p>IsExperimental checks if an integration is marked as experimental.</p> <p></p>"},{"location":"api/#func-list_1","title":"func List","text":"<pre><code>func List() []string\n</code></pre> <p>List returns a sorted list of all registered integration names.</p> <p></p>"},{"location":"api/#func-listbycategory","title":"func ListByCategory","text":"<pre><code>func ListByCategory(category string) (map[string]Metadata, error)\n</code></pre> <p>ListByCategory returns integrations grouped by category.</p> <p></p>"},{"location":"api/#func-listintegrations","title":"func ListIntegrations","text":"<pre><code>func ListIntegrations() (map[string]Metadata, error)\n</code></pre> <p>ListIntegrations returns a list of all integration names with their metadata.</p> <p></p>"},{"location":"api/#func-register_1","title":"func Register","text":"<pre><code>func Register(name string, constructor func() engine.Integration)\n</code></pre> <p>Register adds an integration constructor to the global registry. This is typically called from init() functions in integration packages.</p> <p>Example:</p> <pre><code>func init() {\n    integrations.Register(\"npm\", New)\n}\n</code></pre> <p></p>"},{"location":"api/#func-reloadplugins","title":"func ReloadPlugins","text":"<pre><code>func ReloadPlugins() error\n</code></pre> <p>ReloadPlugins clears the plugin loaded flag and reloads all plugins. This allows hot-reloading of plugins without restarting the application.</p> <p></p>"},{"location":"api/#func-validatefilepath","title":"func ValidateFilePath","text":"<pre><code>func ValidateFilePath(path string) error\n</code></pre> <p>ValidateFilePath validates that a file path is safe to read/write. It checks for directory traversal attempts to prevent security vulnerabilities.</p> <p></p>"},{"location":"api/#type-categorymetadata","title":"type CategoryMetadata","text":"<p>CategoryMetadata contains information about an integration category.</p> <pre><code>type CategoryMetadata struct {\n    Name        string `yaml:\"name\"`\n    Description string `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-datasourcemetadata","title":"type DatasourceMetadata","text":"<p>DatasourceMetadata contains information about a datasource.</p> <pre><code>type DatasourceMetadata struct {\n    Name        string `yaml:\"name\"`\n    URL         string `yaml:\"url\"`\n    Type        string `yaml:\"type\"`\n    Description string `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-metadata","title":"type Metadata","text":"<p>Metadata contains information about an integration.</p> <pre><code>type Metadata struct {\n    DisplayName  string   `yaml:\"displayName\"`\n    Description  string   `yaml:\"description\"`\n    URL          string   `yaml:\"url\"`\n    Category     string   `yaml:\"category\"`\n    FilePatterns []string `yaml:\"filePatterns\"`\n    Datasources  []string `yaml:\"datasources\"`\n    Experimental bool     `yaml:\"experimental\"`\n    Disabled     bool     `yaml:\"disabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-getmetadata","title":"func GetMetadata","text":"<pre><code>func GetMetadata(name string) (*Metadata, error)\n</code></pre> <p>GetMetadata returns metadata for a specific integration.</p> <p></p>"},{"location":"api/#type-registrymetadata","title":"type RegistryMetadata","text":"<p>RegistryMetadata represents the full integrations.yaml structure.</p> <pre><code>type RegistryMetadata struct {\n    Integrations map[string]Metadata           `yaml:\"integrations\"`\n    Datasources  map[string]DatasourceMetadata `yaml:\"datasources\"`\n    Categories   map[string]CategoryMetadata   `yaml:\"categories\"`\n    Version      string                        `yaml:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-loadmetadata","title":"func LoadMetadata","text":"<pre><code>func LoadMetadata() (*RegistryMetadata, error)\n</code></pre> <p>LoadMetadata loads integration metadata from the integrations.yaml file.</p>"},{"location":"api/#policy","title":"policy","text":"<pre><code>import \"github.com/santosr2/uptool/internal/policy\"\n</code></pre> <p>Package policy handles configuration file parsing and policy management. It defines the structure for uptool.yaml configuration files, including integration-specific policies, update strategies, and organization-level governance settings.</p>"},{"location":"api/#index_5","title":"Index","text":"<ul> <li>func ValidateIntegrationPolicy\\(p \\*engine.IntegrationPolicy\\) error</li> <li>type AutoMergeConfig</li> <li>type Config</li> <li>func DefaultConfig() *Config</li> <li>func LoadConfig\\(path string\\) \\(\\*Config, error\\)</li> <li>func \\(c \\*Config\\) EnabledIntegrations() []string</li> <li>func \\(c \\*Config\\) ToPolicyMap() map[string]engine.IntegrationPolicy</li> <li>func \\(c \\*Config\\) Validate() error</li> <li>type IntegrationConfig</li> <li>type MatchConfig</li> <li>type OrgPolicy</li> <li>type SigningConfig</li> </ul>"},{"location":"api/#func-validateintegrationpolicy","title":"func ValidateIntegrationPolicy","text":"<pre><code>func ValidateIntegrationPolicy(p *engine.IntegrationPolicy) error\n</code></pre> <p>ValidateIntegrationPolicy checks that an integration policy is valid.</p> <p></p>"},{"location":"api/#type-automergeconfig","title":"type AutoMergeConfig","text":"<p>AutoMergeConfig controls automatic PR merging.</p> <pre><code>type AutoMergeConfig struct {\n    Guards  []string `yaml:\"guards\"`\n    Enabled bool     `yaml:\"enabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-config","title":"type Config","text":"<p>Config represents the uptool.yaml configuration file.</p> <pre><code>type Config struct {\n    OrgPolicy    *OrgPolicy          `yaml:\"org_policy,omitempty\"`\n    Integrations []IntegrationConfig `yaml:\"integrations\"`\n    Version      int                 `yaml:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-defaultconfig","title":"func DefaultConfig","text":"<pre><code>func DefaultConfig() *Config\n</code></pre> <p>DefaultConfig returns a default configuration with sensible defaults.</p> <p></p>"},{"location":"api/#func-loadconfig","title":"func LoadConfig","text":"<pre><code>func LoadConfig(path string) (*Config, error)\n</code></pre> <p>LoadConfig reads and parses the configuration file.</p> <p></p>"},{"location":"api/#func-config-enabledintegrations","title":"func \\(\\*Config\\) EnabledIntegrations","text":"<pre><code>func (c *Config) EnabledIntegrations() []string\n</code></pre> <p>EnabledIntegrations returns the IDs of all enabled integrations.</p> <p></p>"},{"location":"api/#func-config-topolicymap","title":"func \\(\\*Config\\) ToPolicyMap","text":"<pre><code>func (c *Config) ToPolicyMap() map[string]engine.IntegrationPolicy\n</code></pre> <p>ToPolicyMap converts the configuration into a map of integration policies.</p> <p></p>"},{"location":"api/#func-config-validate","title":"func \\(\\*Config\\) Validate","text":"<pre><code>func (c *Config) Validate() error\n</code></pre> <p>Validate checks that the configuration is valid.</p> <p></p>"},{"location":"api/#type-integrationconfig","title":"type IntegrationConfig","text":"<p>IntegrationConfig defines configuration for a specific integration.</p> <pre><code>type IntegrationConfig struct {\n    Match   *MatchConfig             `yaml:\"match,omitempty\"`\n    ID      string                   `yaml:\"id\"`\n    Policy  engine.IntegrationPolicy `yaml:\"policy\"`\n    Enabled bool                     `yaml:\"enabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-matchconfig","title":"type MatchConfig","text":"<p>MatchConfig specifies file patterns for integration detection.</p> <pre><code>type MatchConfig struct {\n    Files []string `yaml:\"files\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-orgpolicy","title":"type OrgPolicy","text":"<p>OrgPolicy contains organization-level policies and governance settings.</p> <pre><code>type OrgPolicy struct {\n    Signing            *SigningConfig   `yaml:\"signing,omitempty\"`\n    AutoMerge          *AutoMergeConfig `yaml:\"auto_merge,omitempty\"`\n    RequireSignoffFrom []string         `yaml:\"require_signoff_from,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-signingconfig","title":"type SigningConfig","text":"<p>SigningConfig controls artifact signing verification.</p> <pre><code>type SigningConfig struct {\n    CosignVerify bool `yaml:\"cosign_verify\"`\n}\n</code></pre>"},{"location":"api/#registry","title":"registry","text":"<pre><code>import \"github.com/santosr2/uptool/internal/registry\"\n</code></pre> <p>Package registry provides HTTP clients for querying package registries and release APIs. It includes clients for npm Registry, Terraform Registry, GitHub Releases, and Helm repositories, enabling version lookups and constraint-based version resolution.</p>"},{"location":"api/#index_6","title":"Index","text":"<ul> <li>func IsOCIRepository\\(repository string\\) bool</li> <li>func ParseGitHubURL\\(url string\\) \\(owner, repo string, err error\\)</li> <li>type ChartIndex</li> <li>type ChartIndexEntry</li> <li>type GitHubClient</li> <li>func NewGitHubClient\\(token string\\) *GitHubClient</li> <li>func \\(c \\*GitHubClient\\) FindBestRelease\\(ctx context.Context, owner, repo, constraint string, allowPrerelease bool\\) \\(string, error\\)</li> <li>func \\(c \\*GitHubClient\\) GetAllReleases\\(ctx context.Context, owner, repo string\\) \\(\\[\\]Release, error\\)</li> <li>func \\(c \\*GitHubClient\\) GetLatestRelease\\(ctx context.Context, owner, repo string\\) \\(string, error\\)</li> <li>type HelmClient</li> <li>func NewHelmClient() *HelmClient</li> <li>func \\(c \\*HelmClient\\) FindBestChartVersion\\(ctx context.Context, repository, chartName, constraint string\\) \\(string, error\\)</li> <li>func \\(c \\*HelmClient\\) GetChartVersionDetails\\(ctx context.Context, repository, chartName string\\) \\(\\[\\]ChartIndexEntry, error\\)</li> <li>func \\(c \\*HelmClient\\) GetChartVersions\\(ctx context.Context, repository, chartName string\\) \\(\\[\\]string, error\\)</li> <li>func \\(c \\*HelmClient\\) GetLatestChartVersion\\(ctx context.Context, repository, chartName string\\) \\(string, error\\)</li> <li>type Module</li> <li>type ModuleVersion</li> <li>type ModuleVersions</li> <li>type NPMClient</li> <li>func NewNPMClient() *NPMClient</li> <li>func \\(c \\*NPMClient\\) FindBestVersion\\(ctx context.Context, packageName, constraint string, allowPrerelease bool\\) \\(string, error\\)</li> <li>func \\(c \\*NPMClient\\) GetLatestVersion\\(ctx context.Context, packageName string\\) \\(string, error\\)</li> <li>func \\(c \\*NPMClient\\) GetPackageInfo\\(ctx context.Context, packageName string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(c \\*NPMClient\\) GetVersions\\(ctx context.Context, packageName string\\) \\(\\[\\]string, error\\)</li> <li>type PackageInfo</li> <li>type ProviderVersion</li> <li>type ProviderVersions</li> <li>type Release</li> <li>type TerraformClient</li> <li>func NewTerraformClient() *TerraformClient</li> <li>func \\(c \\*TerraformClient\\) FindBestProviderVersion\\(ctx context.Context, source, constraint string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetLatestModuleVersion\\(ctx context.Context, source string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetLatestProviderVersion\\(ctx context.Context, source string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetModuleVersions\\(ctx context.Context, source string\\) \\(\\[\\]ModuleVersion, error\\)</li> </ul>"},{"location":"api/#func-isocirepository","title":"func IsOCIRepository","text":"<pre><code>func IsOCIRepository(repository string) bool\n</code></pre> <p>IsOCIRepository checks if a repository URL is an OCI registry.</p> <p></p>"},{"location":"api/#func-parsegithuburl","title":"func ParseGitHubURL","text":"<pre><code>func ParseGitHubURL(url string) (owner, repo string, err error)\n</code></pre> <p>ParseGitHubURL extracts owner and repo from a GitHub URL. Supports: - https://github.com/owner/repo - github.com/owner/repo - owner/repo</p> <p></p>"},{"location":"api/#type-chartindex","title":"type ChartIndex","text":"<p>ChartIndex represents the index.yaml structure from a Helm repository.</p> <pre><code>type ChartIndex struct {\n    Entries    map[string][]ChartIndexEntry `yaml:\"entries\"`\n    APIVersion string                       `yaml:\"apiVersion\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-chartindexentry","title":"type ChartIndexEntry","text":"<p>ChartIndexEntry represents a single chart version entry.</p> <pre><code>type ChartIndexEntry struct {\n    Created     time.Time `yaml:\"created\"`\n    Name        string    `yaml:\"name\"`\n    Version     string    `yaml:\"version\"`\n    AppVersion  string    `yaml:\"appVersion\"`\n    Description string    `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-githubclient","title":"type GitHubClient","text":"<p>GitHubClient queries GitHub API for release information.</p> <pre><code>type GitHubClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgithubclient","title":"func NewGitHubClient","text":"<pre><code>func NewGitHubClient(token string) *GitHubClient\n</code></pre> <p>NewGitHubClient creates a new GitHub API client. Token is optional but recommended to avoid rate limiting.</p> <p></p>"},{"location":"api/#func-githubclient-findbestrelease","title":"func \\(\\*GitHubClient\\) FindBestRelease","text":"<pre><code>func (c *GitHubClient) FindBestRelease(ctx context.Context, owner, repo, constraint string, allowPrerelease bool) (string, error)\n</code></pre> <p>FindBestRelease finds the best release matching a constraint.</p> <p></p>"},{"location":"api/#func-githubclient-getallreleases","title":"func \\(\\*GitHubClient\\) GetAllReleases","text":"<pre><code>func (c *GitHubClient) GetAllReleases(ctx context.Context, owner, repo string) ([]Release, error)\n</code></pre> <p>GetAllReleases fetches all releases for a repository.</p> <p></p>"},{"location":"api/#func-githubclient-getlatestrelease","title":"func \\(\\*GitHubClient\\) GetLatestRelease","text":"<pre><code>func (c *GitHubClient) GetLatestRelease(ctx context.Context, owner, repo string) (string, error)\n</code></pre> <p>GetLatestRelease fetches the latest non-prerelease release for a repository.</p> <p></p>"},{"location":"api/#type-helmclient","title":"type HelmClient","text":"<p>HelmClient queries Helm chart repositories.</p> <pre><code>type HelmClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newhelmclient","title":"func NewHelmClient","text":"<pre><code>func NewHelmClient() *HelmClient\n</code></pre> <p>NewHelmClient creates a new Helm chart repository client.</p> <p></p>"},{"location":"api/#func-helmclient-findbestchartversion","title":"func \\(\\*HelmClient\\) FindBestChartVersion","text":"<pre><code>func (c *HelmClient) FindBestChartVersion(ctx context.Context, repository, chartName, constraint string) (string, error)\n</code></pre> <p>FindBestChartVersion finds the best chart version matching a constraint.</p> <p></p>"},{"location":"api/#func-helmclient-getchartversiondetails","title":"func \\(\\*HelmClient\\) GetChartVersionDetails","text":"<pre><code>func (c *HelmClient) GetChartVersionDetails(ctx context.Context, repository, chartName string) ([]ChartIndexEntry, error)\n</code></pre> <p>GetChartVersionDetails returns all available versions with metadata for a chart from a repository.</p> <p></p>"},{"location":"api/#func-helmclient-getchartversions","title":"func \\(\\*HelmClient\\) GetChartVersions","text":"<pre><code>func (c *HelmClient) GetChartVersions(ctx context.Context, repository, chartName string) ([]string, error)\n</code></pre> <p>GetChartVersions returns all available versions for a chart.</p> <p></p>"},{"location":"api/#func-helmclient-getlatestchartversion","title":"func \\(\\*HelmClient\\) GetLatestChartVersion","text":"<pre><code>func (c *HelmClient) GetLatestChartVersion(ctx context.Context, repository, chartName string) (string, error)\n</code></pre> <p>GetLatestChartVersion fetches the latest version for a chart from a repository. repository: the base URL of the chart repository \\(e.g., \"https://charts.bitnami.com/bitnami\"\\) chartName: the name of the chart \\(e.g., \"postgresql\"\\)</p> <p></p>"},{"location":"api/#type-module","title":"type Module","text":"<p>Module represents a module with its versions.</p> <pre><code>type Module struct {\n    Source   string          `json:\"source\"`\n    Versions []ModuleVersion `json:\"versions\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-moduleversion","title":"type ModuleVersion","text":"<p>ModuleVersion represents a single module version.</p> <pre><code>type ModuleVersion struct {\n    Version string `json:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-moduleversions","title":"type ModuleVersions","text":"<p>ModuleVersions represents the response from /v1/modules/{namespace}/{name}/{provider}/versions.</p> <pre><code>type ModuleVersions struct {\n    Modules []Module `json:\"modules\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-npmclient","title":"type NPMClient","text":"<p>NPMClient queries the npm registry for package information.</p> <pre><code>type NPMClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newnpmclient","title":"func NewNPMClient","text":"<pre><code>func NewNPMClient() *NPMClient\n</code></pre> <p>NewNPMClient creates a new npm registry client.</p> <p></p>"},{"location":"api/#func-npmclient-findbestversion","title":"func \\(\\*NPMClient\\) FindBestVersion","text":"<pre><code>func (c *NPMClient) FindBestVersion(ctx context.Context, packageName, constraint string, allowPrerelease bool) (string, error)\n</code></pre> <p>FindBestVersion finds the best version matching a constraint.</p> <p></p>"},{"location":"api/#func-npmclient-getlatestversion","title":"func \\(\\*NPMClient\\) GetLatestVersion","text":"<pre><code>func (c *NPMClient) GetLatestVersion(ctx context.Context, packageName string) (string, error)\n</code></pre> <p>GetLatestVersion fetches the latest version for a package.</p> <p></p>"},{"location":"api/#func-npmclient-getpackageinfo","title":"func \\(\\*NPMClient\\) GetPackageInfo","text":"<pre><code>func (c *NPMClient) GetPackageInfo(ctx context.Context, packageName string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo fetches full package information from npm registry.</p> <p></p>"},{"location":"api/#func-npmclient-getversions","title":"func \\(\\*NPMClient\\) GetVersions","text":"<pre><code>func (c *NPMClient) GetVersions(ctx context.Context, packageName string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a package.</p> <p></p>"},{"location":"api/#type-packageinfo_1","title":"type PackageInfo","text":"<p>PackageInfo contains npm package metadata.</p> <pre><code>type PackageInfo struct {\n    Versions map[string]map[string]interface{} `json:\"versions\"`\n    DistTags map[string]string                 `json:\"dist-tags\"`\n    Time     map[string]string                 `json:\"time\"`\n    Name     string                            `json:\"name\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerversion","title":"type ProviderVersion","text":"<p>ProviderVersion represents a single provider version.</p> <pre><code>type ProviderVersion struct {\n    Version   string   `json:\"version\"`\n    Platforms []string `json:\"platforms\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerversions","title":"type ProviderVersions","text":"<p>ProviderVersions represents the response from /v1/providers/{namespace}/{type}/versions.</p> <pre><code>type ProviderVersions struct {\n    Versions []ProviderVersion `json:\"versions\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-release","title":"type Release","text":"<p>Release represents a GitHub release.</p> <pre><code>type Release struct {\n    TagName     string `json:\"tag_name\"`\n    Name        string `json:\"name\"`\n    CreatedAt   string `json:\"created_at\"`\n    PublishedAt string `json:\"published_at\"`\n    Draft       bool   `json:\"draft\"`\n    Prerelease  bool   `json:\"prerelease\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-terraformclient","title":"type TerraformClient","text":"<p>TerraformClient queries the Terraform Registry API.</p> <pre><code>type TerraformClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newterraformclient","title":"func NewTerraformClient","text":"<pre><code>func NewTerraformClient() *TerraformClient\n</code></pre> <p>NewTerraformClient creates a new Terraform Registry client.</p> <p></p>"},{"location":"api/#func-terraformclient-findbestproviderversion","title":"func \\(\\*TerraformClient\\) FindBestProviderVersion","text":"<pre><code>func (c *TerraformClient) FindBestProviderVersion(ctx context.Context, source, constraint string) (string, error)\n</code></pre> <p>FindBestProviderVersion finds the best provider version matching a constraint.</p> <p></p>"},{"location":"api/#func-terraformclient-getlatestmoduleversion","title":"func \\(\\*TerraformClient\\) GetLatestModuleVersion","text":"<pre><code>func (c *TerraformClient) GetLatestModuleVersion(ctx context.Context, source string) (string, error)\n</code></pre> <p>GetLatestModuleVersion fetches the latest version for a module. source format: \"namespace/name/provider\" \\(e.g., \"terraform\\-aws\\-modules/vpc/aws\"\\)</p> <p></p>"},{"location":"api/#func-terraformclient-getlatestproviderversion","title":"func \\(\\*TerraformClient\\) GetLatestProviderVersion","text":"<pre><code>func (c *TerraformClient) GetLatestProviderVersion(ctx context.Context, source string) (string, error)\n</code></pre> <p>GetLatestProviderVersion fetches the latest version for a provider. source format: \"namespace/name\" \\(e.g., \"hashicorp/aws\"\\)</p> <p></p>"},{"location":"api/#func-terraformclient-getmoduleversions","title":"func \\(\\*TerraformClient\\) GetModuleVersions","text":"<pre><code>func (c *TerraformClient) GetModuleVersions(ctx context.Context, source string) ([]ModuleVersion, error)\n</code></pre> <p>GetModuleVersions returns all available versions for a module. source format: \"namespace/name/provider\" \\(e.g., \"terraform\\-aws\\-modules/vpc/aws\"\\)</p>"},{"location":"api/#resolve","title":"resolve","text":"<pre><code>import \"github.com/santosr2/uptool/internal/resolve\"\n</code></pre> <p>Package resolve provides semantic version resolution and selection logic. It implements version constraint checking, policy-based version selection, and semantic version impact calculation \\(patch/minor/major\\).</p>"},{"location":"api/#index_7","title":"Index","text":"<ul> <li>func CompareVersions\\(v1, v2 string\\) \\(int, error\\)</li> <li>func IsValidSemver\\(version string\\) bool</li> <li>func SelectVersion\\(currentVersion string, availableVersions \\[\\]string, policy engine.IntegrationPolicy\\) \\(string, engine.Impact, error\\)</li> </ul>"},{"location":"api/#func-compareversions","title":"func CompareVersions","text":"<pre><code>func CompareVersions(v1, v2 string) (int, error)\n</code></pre> <p>CompareVersions returns -1 if v1 \\&lt; v2, 0 if v1 == v2, 1 if v1 &gt; v2.</p> <p></p>"},{"location":"api/#func-isvalidsemver","title":"func IsValidSemver","text":"<pre><code>func IsValidSemver(version string) bool\n</code></pre> <p>IsValidSemver checks if a string is a valid semver version.</p> <p></p>"},{"location":"api/#func-selectversion","title":"func SelectVersion","text":"<pre><code>func SelectVersion(currentVersion string, availableVersions []string, policy engine.IntegrationPolicy) (string, engine.Impact, error)\n</code></pre> <p>SelectVersion chooses the best version from a list based on policy. It filters versions by update strategy and prerelease policy, then returns the latest.</p>"},{"location":"api/#rewrite","title":"rewrite","text":"<pre><code>import \"github.com/santosr2/uptool/internal/rewrite\"\n</code></pre> <p>Package rewrite provides utilities for rewriting structured files while preserving formatting. It includes functions for YAML manipulation, unified diff generation, and patch creation, enabling integrations to update configuration files without destroying formatting or comments.</p>"},{"location":"api/#index_8","title":"Index","text":"<ul> <li>func CountChanges\\(diff string\\) \\(additions, deletions int\\)</li> <li>func GeneratePatch\\(filename, oldContent, newContent string\\) \\(string, error\\)</li> <li>func GenerateUnifiedDiff\\(filename, oldContent, newContent string\\) \\(string, error\\)</li> <li>func ReplaceYAMLValue\\(content string, path \\[\\]string, oldValue, newValue string, matcher func\\(\\*yaml.Node\\) bool) \\(string, error\\)</li> <li>func UpdateYAMLField\\(content string, path \\[\\]string, newValue string\\) \\(string, error\\)</li> </ul>"},{"location":"api/#func-countchanges","title":"func CountChanges","text":"<pre><code>func CountChanges(diff string) (additions, deletions int)\n</code></pre> <p>CountChanges returns the number of additions and deletions in a diff.</p> <p></p>"},{"location":"api/#func-generatepatch","title":"func GeneratePatch","text":"<pre><code>func GeneratePatch(filename, oldContent, newContent string) (string, error)\n</code></pre> <p>GeneratePatch creates a git-style patch with timestamps.</p> <p></p>"},{"location":"api/#func-generateunifieddiff","title":"func GenerateUnifiedDiff","text":"<pre><code>func GenerateUnifiedDiff(filename, oldContent, newContent string) (string, error)\n</code></pre> <p>GenerateUnifiedDiff creates a unified diff between old and new content.</p> <p></p>"},{"location":"api/#func-replaceyamlvalue","title":"func ReplaceYAMLValue","text":"<pre><code>func ReplaceYAMLValue(content string, path []string, oldValue, newValue string, matcher func(*yaml.Node) bool) (string, error)\n</code></pre> <p>ReplaceYAMLValue replaces a specific value in a YAML document while preserving formatting. path specifies the location \\(e.g., \\[\"repos\", \"\\*\", \"rev\"\\]\\) where * matches any element. matcher is an optional function to further filter which nodes to update.</p> <p></p>"},{"location":"api/#func-updateyamlfield","title":"func UpdateYAMLField","text":"<pre><code>func UpdateYAMLField(content string, path []string, newValue string) (string, error)\n</code></pre> <p>UpdateYAMLField updates a specific field in a YAML document.</p>"},{"location":"api/#secureio","title":"secureio","text":"<pre><code>import \"github.com/santosr2/uptool/internal/secureio\"\n</code></pre> <p>Package secureio provides secure file I/O operations with path validation.</p>"},{"location":"api/#index_9","title":"Index","text":"<ul> <li>func Create\\(path string\\) \\(\\*os.File, error\\)</li> <li>func ReadFile\\(path string\\) \\(\\[\\]byte, error\\)</li> <li>func ValidateFilePath\\(path string\\) error</li> <li>func WriteFile\\(path string, data \\[\\]byte, perm os.FileMode\\) error</li> </ul>"},{"location":"api/#func-create","title":"func Create","text":"<pre><code>func Create(path string) (*os.File, error)\n</code></pre> <p>Create safely creates a file after validating the path</p> <p></p>"},{"location":"api/#func-readfile","title":"func ReadFile","text":"<pre><code>func ReadFile(path string) ([]byte, error)\n</code></pre> <p>ReadFile safely reads a file after validating the path</p> <p></p>"},{"location":"api/#func-validatefilepath_1","title":"func ValidateFilePath","text":"<pre><code>func ValidateFilePath(path string) error\n</code></pre> <p>ValidateFilePath validates that a file path is safe to read/write</p> <p></p>"},{"location":"api/#func-writefile","title":"func WriteFile","text":"<pre><code>func WriteFile(path string, data []byte, perm os.FileMode) error\n</code></pre> <p>WriteFile safely writes a file after validating the path</p>"},{"location":"api/#version","title":"version","text":"<pre><code>import \"github.com/santosr2/uptool/internal/version\"\n</code></pre> <p>Package version provides version information for uptool. The version is embedded from the VERSION file at the repository root.</p>"},{"location":"api/#index_10","title":"Index","text":"<ul> <li>func Get() string</li> </ul>"},{"location":"api/#func-get_2","title":"func Get","text":"<pre><code>func Get() string\n</code></pre> <p>Get returns the current uptool version.</p>"},{"location":"api/#cmd","title":"cmd","text":"<pre><code>import \"github.com/santosr2/uptool/cmd/uptool/cmd\"\n</code></pre> <p>Package cmd implements the command-line interface for uptool. It provides commands for scanning, planning, and updating dependency manifests across multiple ecosystems \\(npm, Helm, Terraform, pre\\-commit, asdf, mise, tflint\\).</p> <p>The CLI is built using Cobra and provides the following commands:</p> <ul> <li>scan: Discover all manifests in a repository</li> <li>plan: Generate an update plan showing available dependency updates</li> <li>update: Apply updates to manifest files</li> <li>list: List all supported integrations and their status</li> <li>completion: Generate shell completion scripts</li> </ul> <p>Global flags available across all commands:</p> <ul> <li>-v, --verbose: Enable verbose debug output</li> <li>-q, --quiet: Suppress informational output \\(errors only\\)</li> </ul> <p>Example usage:</p> <pre><code># Scan repository for manifests\nuptool scan\n\n# Generate update plan\nuptool plan\n\n# Apply updates (dry-run first)\nuptool update --dry-run --diff\nuptool update\n\n# Update only specific integrations\nuptool update --only=npm,helm\n</code></pre> <p>See individual command documentation for detailed usage and options.</p>"},{"location":"api/#index_11","title":"Index","text":"<ul> <li>func Execute() error</li> <li>func GetLogLevel() slog.Level</li> </ul>"},{"location":"api/#func-execute","title":"func Execute","text":"<pre><code>func Execute() error\n</code></pre> <p>Execute runs the root command</p> <p></p>"},{"location":"api/#func-getloglevel","title":"func GetLogLevel","text":"<pre><code>func GetLogLevel() slog.Level\n</code></pre> <p>GetLogLevel returns the current log level based on flags</p>"},{"location":"api/#python","title":"python","text":"<pre><code>import \"github.com/santosr2/uptool/examples/plugins/python\"\n</code></pre> <p>Package main implements an uptool plugin for Python requirements.txt dependencies. This plugin demonstrates the external plugin architecture for uptool.</p>"},{"location":"api/#index_12","title":"Index","text":"<ul> <li>func New() engine.Integration</li> <li>func ParseRequirements\\(content string\\) \\(\\[\\]\\*engine.Dependency, error\\)</li> <li>func RegisterWith\\(register func\\(name string, constructor func\\(\\) engine.Integration))</li> <li>type Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type PyPIClient</li> <li>func NewPyPIClient() *PyPIClient</li> <li>func \\(c \\*PyPIClient\\) GetLatestVersion\\(ctx context.Context, packageName string\\) \\(string, error\\)</li> <li>type PyPIResponse</li> </ul>"},{"location":"api/#func-new","title":"func New","text":"<pre><code>func New() engine.Integration\n</code></pre> <p>New creates a new Python integration instance.</p> <p></p>"},{"location":"api/#func-parserequirements","title":"func ParseRequirements","text":"<pre><code>func ParseRequirements(content string) ([]*engine.Dependency, error)\n</code></pre> <p>ParseRequirements parses a requirements.txt file and extracts dependencies. It handles: - Simple version pins \\(package==1.0.0\\) - Version constraints \\(package\\&gt;=1.0.0\\) - Comments \\(\\# comment\\) - Blank lines - Extras \\(package\\[extra\\]==1.0.0\\)</p> <p></p>"},{"location":"api/#func-registerwith","title":"func RegisterWith","text":"<pre><code>func RegisterWith(register func(name string, constructor func() engine.Integration))\n</code></pre> <p>RegisterWith is called by uptool to register this plugin's integrations. This function MUST be exported and have this exact signature for the plugin to work.</p> <p>uptool will call this function and pass its Register function, which the plugin should call to register each integration it provides.</p> <p></p>"},{"location":"api/#type-integration_1","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for Python requirements.txt.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-integration-apply","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update plan by rewriting requirements.txt.</p> <p></p>"},{"location":"api/#func-integration-detect","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds requirements.txt files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for a requirements.txt file.</p> <p></p>"},{"location":"api/#func-integration-validate","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if a requirements.txt file is valid.</p> <p></p>"},{"location":"api/#type-pypiclient","title":"type PyPIClient","text":"<p>PyPIClient queries the PyPI JSON API for package information.</p> <pre><code>type PyPIClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newpypiclient","title":"func NewPyPIClient","text":"<pre><code>func NewPyPIClient() *PyPIClient\n</code></pre> <p>NewPyPIClient creates a new PyPI client.</p> <p></p>"},{"location":"api/#func-pypiclient-getlatestversion","title":"func \\(\\*PyPIClient\\) GetLatestVersion","text":"<pre><code>func (c *PyPIClient) GetLatestVersion(ctx context.Context, packageName string) (string, error)\n</code></pre> <p>GetLatestVersion fetches the latest stable version for a package from PyPI.</p> <p></p>"},{"location":"api/#type-pypiresponse","title":"type PyPIResponse","text":"<p>PyPIResponse represents the PyPI JSON API response.</p> <pre><code>type PyPIResponse struct {\n    Info struct {\n        Name    string `json:\"name\"`\n        Version string `json:\"version\"`\n    }   `json:\"info\"`\n    Releases map[string][]struct {\n        Yanked bool `json:\"yanked\"`\n    }   `json:\"releases\"`\n}\n</code></pre>"},{"location":"api/#all","title":"all","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/all\"\n</code></pre> <p>Package all imports all integration packages to trigger their self-registration. Import this package with a blank identifier to enable all integrations:</p> <pre><code>import _ \"github.com/santosr2/uptool/internal/integrations/all\"\n</code></pre>"},{"location":"api/#index_13","title":"Index","text":""},{"location":"api/#asdf","title":"asdf","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/asdf\"\n</code></pre> <p>Package asdf provides integration for asdf tool version manager. It detects and updates .tool-versions files.</p> <p>Status: EXPERIMENTAL - Version resolution not yet implemented</p>"},{"location":"api/#index_14","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-integration_2","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for asdf.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_1","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new asdf integration.</p> <p></p>"},{"location":"api/#func-integration-apply_1","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply applies updates to asdf manifest files.</p> <p>Note: Apply is not implemented for asdf. Use native asdf commands instead:</p> <ul> <li>asdf plugin update --all # Update all plugins</li> <li>asdf install \\&lt;tool&gt; latest # Install latest version of a tool</li> </ul> <p>To manually update versions in .tool-versions:</p> <ol> <li>Check available versions: asdf list all \\&lt;tool&gt;</li> <li>Edit .tool-versions with desired versions</li> <li>Install: asdf install</li> </ol> <p></p>"},{"location":"api/#func-integration-detect_1","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect scans for .tool-versions files.</p> <p></p>"},{"location":"api/#func-integration-name_1","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_1","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for asdf tools.</p> <p>Note: asdf integration is experimental. Version resolution is not implemented because each tool \\(.tool\\-versions can contain nodejs, python, ruby, terraform, etc.\\) has its own registry and update mechanism. This would require datasources for every possible runtime.</p> <p>Recommended approach: Use native asdf commands:</p> <ul> <li>asdf plugin update --all # Update plugin versions</li> <li>asdf latest --all # Show latest versions</li> <li>asdf install \\&lt;tool&gt; latest # Install latest version</li> </ul> <p>Future enhancement: Could implement version checking via tool-specific datasources \\(npm registry, python.org, ruby gems, etc.\\) or by calling asdf native commands.</p> <p></p>"},{"location":"api/#func-integration-validate_1","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate validates an asdf manifest.</p>"},{"location":"api/#helm","title":"helm","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/helm\"\n</code></pre> <p>Package helm implements the Helm chart integration for updating Chart.yaml dependencies. It detects Chart.yaml files, queries Helm chart repositories for version updates, and rewrites chart dependency versions while preserving YAML structure.</p>"},{"location":"api/#index_15","title":"Index","text":"<ul> <li>type Chart</li> <li>type Dependency</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-chart","title":"type Chart","text":"<p>Chart represents the structure of Chart.yaml.</p> <pre><code>type Chart struct {\n    Raw          map[string]any `yaml:\",inline\"`\n    APIVersion   string         `yaml:\"apiVersion\"`\n    Name         string         `yaml:\"name\"`\n    Description  string         `yaml:\"description\"`\n    Type         string         `yaml:\"type\"`\n    Version      string         `yaml:\"version\"`\n    AppVersion   string         `yaml:\"appVersion\"`\n    Dependencies []Dependency   `yaml:\"dependencies,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependency_1","title":"type Dependency","text":"<p>Dependency represents a chart dependency.</p> <pre><code>type Dependency struct {\n    Name       string `yaml:\"name\"`\n    Version    string `yaml:\"version\"`\n    Repository string `yaml:\"repository\"`\n    Condition  string `yaml:\"condition,omitempty\"`\n    Tags       string `yaml:\"tags,omitempty\"`\n    Alias      string `yaml:\"alias,omitempty\"`\n    Enabled    bool   `yaml:\"enabled,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_3","title":"type Integration","text":"<p>Integration implements helm chart updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_2","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new helm integration.</p> <p></p>"},{"location":"api/#func-integration-apply_2","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting Chart.yaml.</p> <p></p>"},{"location":"api/#func-integration-detect_2","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds Chart.yaml files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_2","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_2","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for helm chart dependencies.</p> <p></p>"},{"location":"api/#func-integration-validate_2","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the Chart.yaml is valid.</p>"},{"location":"api/#mise","title":"mise","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/mise\"\n</code></pre> <p>Package mise provides integration for mise tool version manager. It detects and updates mise.toml, .mise.toml, and optionally .tool-versions files. mise is backward-compatible with asdf's .tool-versions format.</p> <p>Status: EXPERIMENTAL - Version resolution not yet implemented</p>"},{"location":"api/#index_16","title":"Index","text":"<ul> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-config_1","title":"type Config","text":"<p>Config represents the structure of a mise.toml file.</p> <pre><code>type Config struct {\n    Tools map[string]interface{} `toml:\"tools\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_4","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for mise.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_3","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new mise integration.</p> <p></p>"},{"location":"api/#func-integration-apply_3","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply applies updates to mise manifest files.</p> <p>Note: Apply is not implemented for mise. Use native mise commands instead:</p> <ul> <li>mise upgrade # Upgrade all tools to latest</li> <li>mise use \\&lt;tool&gt;@latest # Pin specific tool to latest</li> </ul> <p>To manually update versions in mise.toml or .mise.toml:</p> <ol> <li>Check available versions: mise ls-remote \\&lt;tool&gt;</li> <li>Edit mise.toml with desired versions</li> <li>Install: mise install</li> </ol> <p></p>"},{"location":"api/#func-integration-detect_3","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect scans for mise.toml and .mise.toml files.</p> <p></p>"},{"location":"api/#func-integration-name_3","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_3","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for mise tools.</p> <p>Note: mise integration is experimental. Version resolution is not implemented because each tool \\(mise.toml can contain nodejs, python, ruby, terraform, etc.\\) has its own registry and update mechanism. This would require datasources for every possible runtime.</p> <p>Recommended approach: Use native mise commands:</p> <ul> <li>mise upgrade # Upgrade all tools to latest versions</li> <li>mise outdated # Show outdated tools</li> <li>mise use \\&lt;tool&gt;@latest # Pin to latest version</li> </ul> <p>Future enhancement: Could implement version checking via tool-specific datasources \\(npm registry, python.org, ruby gems, etc.\\) or by calling mise native commands.</p> <p></p>"},{"location":"api/#func-integration-validate_3","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate validates a mise manifest.</p>"},{"location":"api/#npm","title":"npm","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/npm\"\n</code></pre> <p>Package npm implements the npm integration for updating package.json dependencies. It detects package.json files, queries the npm registry for version updates, and rewrites dependency versions while preserving constraint prefixes \\(^, \\~, \\&gt;=\\).</p>"},{"location":"api/#index_17","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type PackageJSON</li> </ul>"},{"location":"api/#type-integration_5","title":"type Integration","text":"<p>Integration implements npm package.json updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_4","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new npm integration.</p> <p></p>"},{"location":"api/#func-integration-apply_4","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update plan by rewriting package.json.</p> <p></p>"},{"location":"api/#func-integration-detect_4","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds package.json files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_4","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_4","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for npm dependencies.</p> <p></p>"},{"location":"api/#func-integration-validate_4","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate runs npm validation \\(optional\\).</p> <p></p>"},{"location":"api/#type-packagejson","title":"type PackageJSON","text":"<p>PackageJSON represents the structure of package.json.</p> <pre><code>type PackageJSON struct {\n    Dependencies         map[string]string `json:\"dependencies,omitempty\"`\n    DevDependencies      map[string]string `json:\"devDependencies,omitempty\"`\n    PeerDependencies     map[string]string `json:\"peerDependencies,omitempty\"`\n    OptionalDependencies map[string]string `json:\"optionalDependencies,omitempty\"`\n    Name                 string            `json:\"name,omitempty\"`\n    Version              string            `json:\"version,omitempty\"`\n}\n</code></pre>"},{"location":"api/#precommit","title":"precommit","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/precommit\"\n</code></pre> <p>Package precommit implements the pre-commit integration using the native autoupdate command. It detects .pre-commit-config.yaml files, runs 'pre-commit autoupdate' to update hook versions, and parses the output to report changes. This follows the manifest-first philosophy by using the native tool that directly updates the configuration file.</p>"},{"location":"api/#index_18","title":"Index","text":"<ul> <li>type Config</li> <li>type Hook</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Repo</li> </ul>"},{"location":"api/#type-config_2","title":"type Config","text":"<p>Config represents the structure of .pre-commit-config.yaml.</p> <pre><code>type Config struct {\n    Repos []Repo `yaml:\"repos\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-hook","title":"type Hook","text":"<p>Hook represents a pre-commit hook.</p> <pre><code>type Hook struct {\n    ID string `yaml:\"id\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_6","title":"type Integration","text":"<p>Integration implements pre-commit hook updates using native autoupdate command.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_5","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new pre-commit integration.</p> <p></p>"},{"location":"api/#func-integration-apply_5","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update using native pre-commit autoupdate command.</p> <p></p>"},{"location":"api/#func-integration-detect_5","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .pre-commit-config.yaml files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_5","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_5","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for pre-commit hooks. For pre-commit, we use the native autoupdate command in dry-run mode.</p> <p></p>"},{"location":"api/#func-integration-validate_5","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate runs pre-commit validate-config.</p> <p></p>"},{"location":"api/#type-repo","title":"type Repo","text":"<p>Repo represents a pre-commit repository.</p> <pre><code>type Repo struct {\n    Repo  string `yaml:\"repo\"`\n    Rev   string `yaml:\"rev\"`\n    Hooks []Hook `yaml:\"hooks,omitempty\"`\n}\n</code></pre>"},{"location":"api/#terraform","title":"terraform","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/terraform\"\n</code></pre> <p>Package terraform implements the Terraform integration for updating module versions in .tf files. It detects Terraform configuration files, parses HCL to extract module and provider versions, queries the Terraform Registry for updates, and rewrites versions while preserving HCL formatting.</p>"},{"location":"api/#index_19","title":"Index","text":"<ul> <li>type Block</li> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type ModuleBlock</li> <li>type ProviderBlock</li> <li>type RequiredProvidersBlock</li> </ul>"},{"location":"api/#type-block","title":"type Block","text":"<p>Block represents a terraform configuration block.</p> <pre><code>type Block struct {\n    Remain            hcl.Body                `hcl:\",remain\"`\n    RequiredProviders *RequiredProvidersBlock `hcl:\"required_providers,block\"`\n    RequiredVersion   string                  `hcl:\"required_version,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-config_3","title":"type Config","text":"<p>Config represents terraform configuration structure.</p> <pre><code>type Config struct {\n    Remain    hcl.Body        `hcl:\",remain\"`\n    Terraform []Block         `hcl:\"terraform,block\"`\n    Modules   []ModuleBlock   `hcl:\"module,block\"`\n    Providers []ProviderBlock `hcl:\"provider,block\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_7","title":"type Integration","text":"<p>Integration implements terraform configuration updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_6","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new terraform integration.</p> <p></p>"},{"location":"api/#func-integration-apply_6","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting terraform files.</p> <p></p>"},{"location":"api/#func-integration-detect_6","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .tf files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_6","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_6","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for terraform providers and modules.</p> <p></p>"},{"location":"api/#func-integration-validate_6","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the terraform configuration is valid.</p> <p></p>"},{"location":"api/#type-moduleblock","title":"type ModuleBlock","text":"<p>ModuleBlock represents a module block.</p> <pre><code>type ModuleBlock struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Source  string   `hcl:\"source,optional\"`\n    Version string   `hcl:\"version,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerblock","title":"type ProviderBlock","text":"<p>ProviderBlock represents a provider block.</p> <pre><code>type ProviderBlock struct {\n    Remain hcl.Body `hcl:\",remain\"`\n    Name   string   `hcl:\"name,label\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-requiredprovidersblock","title":"type RequiredProvidersBlock","text":"<p>RequiredProvidersBlock represents the required_providers block.</p> <pre><code>type RequiredProvidersBlock struct {\n    Body hcl.Body `hcl:\",remain\"`\n}\n</code></pre>"},{"location":"api/#tflint","title":"tflint","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/tflint\"\n</code></pre> <p>Package tflint implements the tflint integration for updating plugin versions in .tflint.hcl files. It detects tflint configuration files, parses HCL to extract plugin versions, queries GitHub Releases for plugin updates, and rewrites versions while preserving HCL formatting.</p>"},{"location":"api/#index_20","title":"Index","text":"<ul> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Plugin</li> <li>type Rule</li> </ul>"},{"location":"api/#type-config_4","title":"type Config","text":"<p>Config represents .tflint.hcl structure.</p> <pre><code>type Config struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Plugins []Plugin `hcl:\"plugin,block\"`\n    Rules   []Rule   `hcl:\"rule,block\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_8","title":"type Integration","text":"<p>Integration implements tflint configuration updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_7","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new tflint integration.</p> <p></p>"},{"location":"api/#func-integration-apply_7","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting the HCL file.</p> <p></p>"},{"location":"api/#func-integration-detect_7","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .tflint.hcl files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_7","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_7","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for tflint plugins.</p> <p></p>"},{"location":"api/#func-integration-validate_7","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the HCL file is valid.</p> <p></p>"},{"location":"api/#type-plugin","title":"type Plugin","text":"<p>Plugin represents a tflint plugin block.</p> <pre><code>type Plugin struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Version string   `hcl:\"version,optional\"`\n    Source  string   `hcl:\"source,optional\"`\n    Enabled bool     `hcl:\"enabled,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-rule","title":"type Rule","text":"<p>Rule represents a tflint rule block.</p> <pre><code>type Rule struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Enabled bool     `hcl:\"enabled,optional\"`\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"cli/commands/","title":"CLI Commands","text":"<p>uptool is a manifest-first dependency updater for multiple ecosystems. It scans repositories for dependency manifest files (package.json, Chart.yaml, .pre-commit-config.yaml, etc.), checks for available updates, and rewrites manifests with new versions while preserving formatting.</p> <p>Usage:   uptool [command]</p> <p>Available Commands:   completion  Generate shell completion scripts   help        Help about any command   list        List available integrations   plan        Generate update plans   scan        Discover dependency manifests   update      Apply updates to manifests</p> <p>Flags:   -h, --help      help for uptool   -q, --quiet     suppress informational output (errors only)   -v, --verbose   enable verbose debug output       --version   version for uptool</p> <p>Use \"uptool [command] --help\" for more information about a command.</p>"},{"location":"integrations/","title":"Integration Guides","text":"<p>Detailed guides for each uptool integration.</p>"},{"location":"integrations/#available-integrations","title":"Available Integrations","text":"Integration Manifest Status Registry npm <code>package.json</code> \u2705 Stable npm Registry API helm <code>Chart.yaml</code> \u2705 Stable Helm chart repositories terraform <code>*.tf</code> \u2705 Stable Terraform Registry API tflint <code>.tflint.hcl</code> \u2705 Stable GitHub Releases precommit <code>.pre-commit-config.yaml</code> \u2705 Stable GitHub Releases asdf <code>.tool-versions</code> \u26a0\ufe0f Experimental GitHub Releases mise <code>mise.toml</code> \u26a0\ufe0f Experimental GitHub Releases"},{"location":"integrations/#by-category","title":"By Category","text":""},{"location":"integrations/#package-managers","title":"Package Managers","text":"<ul> <li>npm - JavaScript/Node.js dependencies</li> </ul>"},{"location":"integrations/#infrastructure-as-code","title":"Infrastructure as Code","text":"<ul> <li>helm - Kubernetes package manager</li> <li>terraform - Terraform modules</li> <li>tflint - Terraform linter plugins</li> </ul>"},{"location":"integrations/#development-tools","title":"Development Tools","text":"<ul> <li>precommit - Pre-commit hooks (uses native <code>pre-commit autoupdate</code>)</li> <li>asdf - asdf version manager</li> <li>mise - mise version manager (modern asdf alternative)</li> </ul>"},{"location":"integrations/#common-patterns","title":"Common Patterns","text":""},{"location":"integrations/#scan-specific-integration","title":"Scan Specific Integration","text":"<pre><code>uptool scan --only=npm\nuptool scan --only=terraform,tflint\n</code></pre>"},{"location":"integrations/#update-single-integration","title":"Update Single Integration","text":"<pre><code>uptool update --only=helm --diff\n</code></pre>"},{"location":"integrations/#exclude-integrations","title":"Exclude Integrations","text":"<pre><code>uptool update --exclude=precommit,terraform\n</code></pre>"},{"location":"integrations/#configuration","title":"Configuration","text":"<p>Control integrations via <code>uptool.yaml</code>:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\n\n  - id: terraform\n    enabled: false\n</code></pre> <p>See Configuration Guide for complete options.</p>"},{"location":"integrations/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Command documentation</li> <li>Configuration - Policy settings</li> <li>Template - Template for new integrations</li> </ul>"},{"location":"integrations/asdf/","title":"asdf Integration","text":"<p>Updates tool versions in <code>.tool-versions</code> files used by the asdf version manager.</p>"},{"location":"integrations/asdf/#overview","title":"Overview","text":"<p>Integration ID: <code>asdf</code></p> <p>Manifest Files: <code>.tool-versions</code></p> <p>Update Strategy: Line-based parsing and rewriting</p> <p>Registry: GitHub Releases (per tool via asdf plugin mapping)</p> <p>Status: \u26a0\ufe0f Experimental (85% test coverage, version resolution not yet implemented)</p>"},{"location":"integrations/asdf/#what-gets-updated","title":"What Gets Updated","text":"<p>Tool version entries in <code>.tool-versions</code>:</p> <ul> <li>Each line format: <code>tool_name version</code></li> <li>Comments and formatting preserved</li> <li>Multiple versions per tool supported (space-separated)</li> </ul>"},{"location":"integrations/asdf/#example","title":"Example","text":"<p>Before:</p> <pre><code># Development tools\ngo 1.23.0\nnodejs 20.10.0\nterraform 1.5.0\n\n# Build tools\npython 3.11.0\nruby 3.2.0\n</code></pre> <p>After:</p> <pre><code># Development tools\ngo 1.25.0\nnodejs 22.12.0\nterraform 1.10.5\n\n# Build tools\npython 3.13.1\nruby 3.3.6\n</code></pre>"},{"location":"integrations/asdf/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/asdf/#file-format","title":"File Format","text":"<p>Simple line-based format:</p> <pre><code>tool_name version [version2 version3...]  # Optional comment\n</code></pre> <p>uptool updates the first (primary) version for each tool.</p>"},{"location":"integrations/asdf/#tool-installation","title":"Tool Installation","text":"<p>uptool updates only <code>.tool-versions</code>. Run <code>asdf install</code> after to install new versions:</p> <pre><code>uptool update --only asdf\nasdf install\n</code></pre>"},{"location":"integrations/asdf/#github-rate-limits","title":"GitHub Rate Limits","text":"<p>Each tool queries GitHub Releases. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only asdf\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/asdf/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: asdf\n    enabled: true\n    policy:\n      update: patch        # Conservative for runtimes\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/asdf/#limitations","title":"Limitations","text":"<ol> <li>Experimental status: Version resolution not yet implemented. <code>uptool plan</code> returns empty update lists.</li> <li>Detection only: Currently only scans and detects <code>.tool-versions</code> files and their dependencies.</li> <li>No updates yet: Use native <code>asdf</code> commands for updates:</li> <li><code>asdf plugin update --all</code> - Update all plugins</li> <li><code>asdf list all &lt;tool&gt;</code> - Check available versions</li> <li><code>asdf install &lt;tool&gt; latest</code> - Install latest version</li> <li>Future implementation: Will query GitHub Releases per tool for version checking.</li> </ol>"},{"location":"integrations/asdf/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only asdf</code></li> <li>Configuration Guide - Policy settings</li> <li>asdf Documentation</li> <li>mise Integration - Modern alternative to asdf</li> </ul>"},{"location":"integrations/helm/","title":"Helm Integration","text":"<p>Updates Kubernetes Helm chart dependencies in <code>Chart.yaml</code> files.</p>"},{"location":"integrations/helm/#overview","title":"Overview","text":"<p>Integration ID: <code>helm</code></p> <p>Manifest Files: <code>Chart.yaml</code></p> <p>Update Strategy: YAML parsing and rewriting</p> <p>Registry: Helm chart repositories (<code>index.yaml</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/helm/#what-gets-updated","title":"What Gets Updated","text":"<p>Chart dependency versions in the <code>dependencies</code> list:</p> <ul> <li><code>dependencies[].version</code> - Version of each chart dependency</li> </ul> <p>Not updated: Chart <code>version</code> (your app version) or <code>appVersion</code> (packaged app version)</p>"},{"location":"integrations/helm/#example","title":"Example","text":"<p>Before:</p> <pre><code>apiVersion: v2\nname: my-application\nversion: 1.0.0\ndependencies:\n  - name: postgresql\n    version: 12.0.0\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 17.0.0\n    repository: https://charts.bitnami.com/bitnami\n</code></pre> <p>After:</p> <pre><code>apiVersion: v2\nname: my-application\nversion: 1.0.0     # Unchanged - your chart version\ndependencies:\n  - name: postgresql\n    version: 18.1.8  # Updated\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 23.2.12 # Updated\n    repository: https://charts.bitnami.com/bitnami\n</code></pre>"},{"location":"integrations/helm/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/helm/#repository-types","title":"Repository Types","text":"Type Example Support Public <code>https://charts.bitnami.com/bitnami</code> \u2705 Full Private <code>https://charts.company.internal</code> \u2705 With auth OCI Registry <code>oci://registry.example.com/charts</code> \u2705 With config"},{"location":"integrations/helm/#repository-authentication","title":"Repository Authentication","text":"<p>For private repositories, configure Helm authentication:</p> <pre><code>helm repo add myrepo https://charts.company.internal \\\n  --username=user \\\n  --password=pass\n</code></pre> <p>uptool respects Helm's repository configuration in <code>~/.config/helm/repositories.yaml</code>.</p>"},{"location":"integrations/helm/#chartlock-handling","title":"Chart.lock Handling","text":"<p>uptool updates only <code>Chart.yaml</code>. Run <code>helm dependency update</code> after to regenerate lockfile:</p> <pre><code>uptool update --only helm\nhelm dependency update charts/myapp\n</code></pre> <p>Monorepo: Each <code>Chart.yaml</code> updated independently.</p>"},{"location":"integrations/helm/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: helm\n    enabled: true\n    match:\n      files:\n        - \"Chart.yaml\"\n        - \"charts/*/Chart.yaml\"    # Monorepo pattern\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/helm/#limitations","title":"Limitations","text":"<ol> <li>No Chart.lock updates: Only <code>Chart.yaml</code> modified. Run <code>helm dependency update</code> after.</li> <li>No version constraint validation: Test with <code>helm lint</code> after updating.</li> <li>Repository must be configured: Ensure repositories added via <code>helm repo add</code>.</li> </ol>"},{"location":"integrations/helm/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only helm</code></li> <li>Configuration Guide - Policy settings</li> <li>Helm Chart Dependencies</li> <li>Helm Repositories</li> </ul>"},{"location":"integrations/mise/","title":"mise Integration","text":"<p>Updates development tool versions in <code>mise.toml</code> and <code>.mise.toml</code> files.</p>"},{"location":"integrations/mise/#overview","title":"Overview","text":"<p>Integration ID: <code>mise</code></p> <p>Manifest Files: <code>mise.toml</code>, <code>.mise.toml</code></p> <p>Update Strategy: TOML parsing and rewriting</p> <p>Registry: GitHub Releases (per tool)</p> <p>Status: \u26a0\ufe0f Experimental (86% test coverage, version resolution not yet implemented)</p>"},{"location":"integrations/mise/#what-gets-updated","title":"What Gets Updated","text":"<p>Tool versions in the <code>[tools]</code> section:</p> <ul> <li>String format: <code>tool = \"version\"</code></li> <li>Map format: <code>tool = { version = \"version\", ... }</code></li> <li>Preserves whichever format you use</li> </ul> <p>Monorepo support: Each <code>mise.toml</code> updated independently.</p>"},{"location":"integrations/mise/#example","title":"Example","text":"<p>Before:</p> <pre><code>[tools]\ngo = \"1.23\"\nnode = \"20\"\npython = \"3.11\"\nterraform = { version = \"1.5.0\" }\ngolangci-lint = \"2.6\"\n</code></pre> <p>After:</p> <pre><code>[tools]\ngo = \"1.25\"\nnode = \"22\"\npython = \"3.13\"\nterraform = { version = \"1.10.5\" }   # Preserves map format\ngolangci-lint = \"2.7\"\n</code></pre>"},{"location":"integrations/mise/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/mise/#version-formats","title":"Version Formats","text":"<p>mise supports two TOML formats:</p> Format Example Use Case String <code>go = \"1.25\"</code> Simple (recommended) Map <code>go = { version = \"1.25\", path = \".go-version\" }</code> With additional options <p>uptool preserves the format - map stays map, string stays string.</p>"},{"location":"integrations/mise/#partial-versions","title":"Partial Versions","text":"<p>mise allows partial version specifications that uptool updates:</p> <pre><code>go = \"1.23\"      # Updates to \"1.25\" (latest 1.x)\nnode = \"20\"      # Updates to \"22\" (latest)\npython = \"3.11\"  # Updates to \"3.13\" (latest 3.x)\n</code></pre>"},{"location":"integrations/mise/#tool-installation","title":"Tool Installation","text":"<p>uptool updates only <code>mise.toml</code>. Run <code>mise install</code> after updating to install new versions:</p> <pre><code>uptool update --only mise\nmise install\n</code></pre>"},{"location":"integrations/mise/#github-rate-limits","title":"GitHub Rate Limits","text":"<p>Each tool queries GitHub Releases. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only mise\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/mise/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: mise\n    enabled: true\n    match:\n      files:\n        - \"mise.toml\"\n        - \".mise.toml\"     # Hidden variant\n        - \"*/mise.toml\"    # Nested projects\n    policy:\n      update: patch        # Conservative for runtimes\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/mise/#limitations","title":"Limitations","text":"<ol> <li>Experimental status: Version resolution not yet implemented. <code>uptool plan</code> returns empty update lists.</li> <li>Detection only: Currently only scans and detects <code>mise.toml</code>/<code>.mise.toml</code> files and their dependencies.</li> <li>No updates yet: Use native <code>mise</code> commands for updates:</li> <li><code>mise upgrade</code> - Update all tools</li> <li><code>mise latest &lt;tool&gt;</code> - Check latest version</li> <li><code>mise install &lt;tool&gt;@latest</code> - Install latest version</li> <li>Future implementation: Will query GitHub Releases per tool for version checking.</li> </ol>"},{"location":"integrations/mise/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only mise</code></li> <li>Configuration Guide - Policy settings</li> <li>mise Documentation</li> <li>asdf Integration - Alternative runtime manager</li> </ul>"},{"location":"integrations/npm/","title":"npm Integration","text":"<p>Updates JavaScript/Node.js dependencies in <code>package.json</code> files.</p>"},{"location":"integrations/npm/#overview","title":"Overview","text":"<p>Integration ID: <code>npm</code></p> <p>Manifest Files: <code>package.json</code></p> <p>Update Strategy: Custom JSON rewriting with constraint preservation</p> <p>Registry: npm Registry API (<code>https://registry.npmjs.org</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/npm/#what-gets-updated","title":"What Gets Updated","text":"<p>All dependency types in <code>package.json</code>:</p> <ul> <li><code>dependencies</code> - Production dependencies</li> <li><code>devDependencies</code> - Development dependencies</li> <li><code>peerDependencies</code> - Peer dependencies</li> <li><code>optionalDependencies</code> - Optional dependencies</li> </ul> <p>Monorepo support: Each <code>package.json</code> updated independently.</p>"},{"location":"integrations/npm/#example","title":"Example","text":"<p>Before:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"lodash\": \"~4.17.20\",\n    \"axios\": \"&gt;=0.27.0\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.0.0\"\n  }\n}\n</code></pre> <p>After:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.19.2\",     // Preserves ^ constraint\n    \"lodash\": \"~4.17.21\",     // Preserves ~ constraint\n    \"axios\": \"&gt;=1.7.0\"        // Preserves &gt;= constraint\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.7.0\"\n  }\n}\n</code></pre>"},{"location":"integrations/npm/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/npm/#version-constraint-preservation","title":"Version Constraint Preservation","text":"<p>uptool preserves version constraint prefixes:</p> Constraint Meaning Before After <code>^</code> Compatible with <code>^4.18.0</code> <code>^4.19.2</code> <code>~</code> Approximately <code>~4.17.20</code> <code>~4.17.21</code> <code>&gt;=</code> Greater than or equal <code>&gt;=0.27.0</code> <code>&gt;=1.7.0</code> (none) Exact version <code>1.0.0</code> <code>1.5.0</code>"},{"location":"integrations/npm/#lockfile-handling","title":"Lockfile Handling","text":"<p>uptool updates only <code>package.json</code>. Run <code>npm install</code> after updating to sync lockfiles:</p> <pre><code>uptool update --only npm\nnpm install\n</code></pre>"},{"location":"integrations/npm/#private-registries","title":"Private Registries","text":"<p>Respects npm configuration from <code>.npmrc</code> or <code>npm config</code>. Configure authentication separately:</p> <pre><code>npm config set registry https://registry.company.com/\nnpm login --registry=https://registry.company.com/\n</code></pre>"},{"location":"integrations/npm/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    match:\n      files:\n        - \"package.json\"\n        - \"apps/*/package.json\"     # Monorepo paths\n        - \"packages/*/package.json\"\n    policy:\n      update: minor                 # none, patch, minor, major\n      allow_prerelease: false\n      pin: false                    # false = preserve constraints\n</code></pre>"},{"location":"integrations/npm/#limitations","title":"Limitations","text":"<ol> <li>No lockfile updates: <code>package-lock.json</code> not modified. Run <code>npm install</code> after updates.</li> <li>No peer dependency validation: Run <code>npm install</code> to see peer dependency warnings.</li> </ol>"},{"location":"integrations/npm/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only npm</code>, <code>uptool plan --only npm</code></li> <li>Configuration Guide - Policy settings</li> <li>npm Registry API</li> <li>Semantic Versioning</li> </ul>"},{"location":"integrations/precommit/","title":"Pre-Commit Integration","text":"<p>Updates pre-commit hook versions in <code>.pre-commit-config.yaml</code> files.</p>"},{"location":"integrations/precommit/#overview","title":"Overview","text":"<p>Integration ID: <code>precommit</code></p> <p>Manifest Files: <code>.pre-commit-config.yaml</code></p> <p>Update Strategy: Native command - Uses <code>pre-commit autoupdate</code></p> <p>Registry: GitHub Releases (per hook repository)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/precommit/#what-gets-updated","title":"What Gets Updated","text":"<p>Hook repository revisions in the <code>repos</code> list:</p> <ul> <li><code>repos[].rev</code> - Git tag or commit SHA of each hook repository</li> <li>Remote hooks only (local and meta hooks skipped)</li> </ul>"},{"location":"integrations/precommit/#example","title":"Example","text":"<p>Before:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: trailing-whitespace\n      - id: check-yaml\n\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n\n  - repo: local    # Not updated\n    hooks:\n      - id: custom-check\n</code></pre> <p>After:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v6.0.0      # Updated\n    hooks:\n      - id: trailing-whitespace\n      - id: check-yaml\n\n  - repo: https://github.com/psf/black\n    rev: 24.10.0     # Updated\n    hooks:\n      - id: black\n\n  - repo: local    # Unchanged\n    hooks:\n      - id: custom-check\n</code></pre>"},{"location":"integrations/precommit/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/precommit/#why-native-command","title":"Why Native Command?","text":"<p>uptool uses <code>pre-commit autoupdate</code> instead of custom rewriting because:</p> <ol> <li>Manifest-first: Updates <code>.pre-commit-config.yaml</code> directly \u2705</li> <li>Comprehensive: Handles all edge cases (local hooks, complex revisions)</li> <li>Maintained: pre-commit team owns the update logic</li> <li>Reliable: Battle-tested by entire pre-commit ecosystem</li> </ol> <p>This aligns with uptool's philosophy: use native commands when they update manifests.</p>"},{"location":"integrations/precommit/#hook-types","title":"Hook Types","text":"Type Example Updated? Remote <code>repo: https://github.com/...</code> \u2705 Yes Local <code>repo: local</code> \u274c No Meta <code>repo: meta</code> \u274c No"},{"location":"integrations/precommit/#github-rate-limits","title":"GitHub Rate Limits","text":"<p><code>pre-commit autoupdate</code> queries GitHub API for each hook. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only precommit\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/precommit/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: precommit\n    enabled: true\n    policy:\n      update: major        # Aggressive for dev tools (safe)\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/precommit/#requirements","title":"Requirements","text":"<ol> <li>pre-commit installed: Must be in <code>$PATH</code></li> <li>Git repository: pre-commit requires git</li> <li>Valid config: <code>.pre-commit-config.yaml</code> must be valid YAML</li> </ol> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\n# or\nbrew install pre-commit\n# or\nmise install pre-commit\n\n# Verify\npre-commit --version\n</code></pre>"},{"location":"integrations/precommit/#limitations","title":"Limitations","text":"<ol> <li>Requires pre-commit CLI: Must have <code>pre-commit</code> installed and in PATH.</li> <li>Git repository required: pre-commit needs a git repository to operate.</li> <li>Limited policy control: pre-commit decides what to update (up tool passes preferences where supported).</li> </ol>"},{"location":"integrations/precommit/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only precommit</code></li> <li>Configuration Guide - Policy settings</li> <li>pre-commit Documentation</li> <li>Supported Hooks</li> </ul>"},{"location":"integrations/terraform/","title":"Terraform Integration","text":"<p>Updates Terraform module versions in <code>*.tf</code> files.</p>"},{"location":"integrations/terraform/#overview","title":"Overview","text":"<p>Integration ID: <code>terraform</code></p> <p>Manifest Files: <code>*.tf</code></p> <p>Update Strategy: HCL parsing and rewriting via <code>hashicorp/hcl</code></p> <p>Registry: Terraform Registry API (<code>https://registry.terraform.io</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/terraform/#what-gets-updated","title":"What Gets Updated","text":"<p>Module versions in <code>module</code> blocks:</p> <ul> <li><code>module</code> block <code>version</code> attributes - Terraform Registry modules</li> </ul> <p>Not yet supported (future):</p> <ul> <li>Provider versions in <code>required_providers</code> blocks</li> <li>Git-based module source versions</li> </ul>"},{"location":"integrations/terraform/#example","title":"Example","text":"<p>Before:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"\n\n  name = \"my-vpc\"\n  cidr = \"10.0.0.0/16\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 4.0\"\n\n  name = \"my-sg\"\n}\n</code></pre> <p>After:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"5.13.0\"   # Updated\n\n  name = \"my-vpc\"\n  cidr = \"10.0.0.0/16\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 5.0\"   # Updated (preserves constraint)\n\n  name = \"my-sg\"\n}\n</code></pre>"},{"location":"integrations/terraform/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/terraform/#version-constraint-preservation","title":"Version Constraint Preservation","text":"<p>uptool preserves version constraint operators:</p> Constraint Meaning Before After (none) Exact <code>\"3.0.0\"</code> <code>\"5.13.0\"</code> <code>~&gt;</code> Pessimistic <code>\"~&gt; 4.0\"</code> <code>\"~&gt; 5.0\"</code> <code>&gt;=</code> Greater or equal <code>\"&gt;= 3.0\"</code> <code>\"&gt;= 5.13\"</code>"},{"location":"integrations/terraform/#terraform-init-required","title":"Terraform Init Required","text":"<p>uptool updates only <code>.tf</code> files. Run <code>terraform init</code> after to update lockfile:</p> <pre><code>uptool update --only terraform\nterraform init -upgrade\n</code></pre>"},{"location":"integrations/terraform/#module-sources","title":"Module Sources","text":"<p>Only Terraform Registry modules updated:</p> <pre><code># \u2705 Updated - Registry module\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"5.13.0\"\n}\n\n# \u274c Not updated - Git source\nmodule \"custom\" {\n  source = \"git::https://github.com/org/repo.git?ref=v1.0.0\"\n}\n\n# \u274c Not updated - Local path\nmodule \"local\" {\n  source = \"./modules/networking\"\n}\n</code></pre>"},{"location":"integrations/terraform/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: terraform\n    enabled: true\n    match:\n      files:\n        - \"*.tf\"\n        - \"**/*.tf\"              # All subdirectories\n    policy:\n      update: patch              # Conservative for infrastructure\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/terraform/#limitations","title":"Limitations","text":"<ol> <li>Registry modules only: Local and Git sources not supported.</li> <li>No provider updates: <code>required_providers</code> versions not yet updated.</li> <li>No lockfile updates: Run <code>terraform init -upgrade</code> after.</li> </ol>"},{"location":"integrations/terraform/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only terraform</code></li> <li>Configuration Guide - Policy settings</li> <li>Terraform Registry</li> <li>Terraform Module Sources</li> </ul>"},{"location":"integrations/tflint/","title":"tflint Integration","text":"<p>Updates tflint plugin versions in <code>.tflint.hcl</code> configuration files.</p>"},{"location":"integrations/tflint/#overview","title":"Overview","text":"<p>Integration ID: <code>tflint</code></p> <p>Manifest Files: <code>.tflint.hcl</code></p> <p>Update Strategy: HCL parsing and rewriting via <code>hashicorp/hcl</code></p> <p>Registry: GitHub Releases (per plugin)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/tflint/#what-gets-updated","title":"What Gets Updated","text":"<p>Plugin versions in <code>plugin</code> blocks:</p> <ul> <li><code>plugin</code> block <code>version</code> attributes - GitHub Releases versions</li> </ul>"},{"location":"integrations/tflint/#example","title":"Example","text":"<p>Before:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.20.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n</code></pre> <p>After:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.44.0\"   # Updated\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.28.0\"   # Updated\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n</code></pre>"},{"location":"integrations/tflint/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/tflint/#plugin-sources","title":"Plugin Sources","text":"<p>Updates plugins from GitHub sources:</p> <pre><code># \u2705 Updated - GitHub source\nplugin \"aws\" {\n  version = \"0.44.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\n# \u274c Not updated - Custom source\nplugin \"custom\" {\n  version = \"1.0.0\"\n  source  = \"example.com/custom-plugin\"\n}\n</code></pre>"},{"location":"integrations/tflint/#tflint-init-required","title":"tflint Init Required","text":"<p>uptool updates only <code>.tflint.hcl</code>. Run <code>tflint --init</code> after to install new plugin versions:</p> <pre><code>uptool update --only tflint\ntflint --init\n</code></pre>"},{"location":"integrations/tflint/#github-rate-limits","title":"GitHub Rate Limits","text":"<p>Each plugin queries GitHub Releases. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only tflint\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/tflint/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: tflint\n    enabled: true\n    policy:\n      update: major        # Aggressive for linters (safe)\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/tflint/#limitations","title":"Limitations","text":"<ol> <li>GitHub sources only: Custom plugin sources not supported.</li> <li>No plugin installation: Run <code>tflint --init</code> after updating.</li> </ol>"},{"location":"integrations/tflint/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only tflint</code></li> <li>Configuration Guide - Policy settings</li> <li>TFLint Documentation</li> <li>TFLint Rulesets</li> </ul>"}]}