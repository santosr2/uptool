{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to uptool","text":"<p>Universal, Manifest-First Dependency Updater</p> <p>uptool combines the ecosystem breadth of Topgrade, the precision of Dependabot, and the flexibility of Renovate \u2014 but with a manifest-first philosophy that works across ANY project toolchain defined in configuration files.</p>"},{"location":"#why-uptool","title":"Why uptool?","text":"<p>Modern projects use dozens of tools across multiple ecosystems:</p> <ul> <li>Language dependencies: npm, pip, go modules</li> <li>Infrastructure tools: Terraform, Helm</li> <li>Development tools: pre-commit, tflint</li> <li>Runtime version managers: asdf (<code>.tool-versions</code>), mise (<code>mise.toml</code>)</li> </ul> <p>Each ecosystem has its own update mechanism. Keeping them all current is tedious and error-prone.</p> <p>uptool provides a unified interface to scan, plan, and update dependencies across all your manifest files.</p>"},{"location":"#manifest-first-philosophy","title":"Manifest-First Philosophy","text":"<p>Unlike traditional dependency updaters that focus on lockfiles, uptool updates manifest files directly (package.json, Chart.yaml, *.tf files, etc.), preserving your intent while keeping dependencies current.</p>"},{"location":"#the-approach","title":"The Approach","text":"<ol> <li>Update manifests first: <code>package.json</code>, <code>Chart.yaml</code>, <code>*.tf</code> files</li> <li>Use native commands when they update manifests: <code>pre-commit autoupdate</code> updates <code>.pre-commit-config.yaml</code> \u2705</li> <li>Don't use commands that only update lockfiles: <code>npm update</code> only touches <code>package-lock.json</code> \u274c</li> <li>Then optionally run native lockfile updates: <code>npm install</code>, <code>terraform init</code>, etc.</li> </ol> <p>This ensures your declared dependencies stay current, not just resolved versions.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p> Multi-Ecosystem Support</p> <p>npm, Helm, Terraform, tflint, pre-commit, asdf, mise \u2014 all in one tool</p> </li> <li> <p> Manifest-First Updates</p> <p>Updates configuration files directly, preserving formatting and comments</p> </li> <li> <p> Intelligent Version Resolution</p> <p>Queries upstream registries (npm, Terraform Registry, Helm repos, GitHub Releases)</p> </li> <li> <p> Safe by Default</p> <p>Dry-run mode, diff generation, validation before applying changes</p> </li> <li> <p> Concurrent Execution</p> <p>Parallel scanning and planning with worker pools for fast performance</p> </li> <li> <p> GitHub Action Integration</p> <p>Use as a CLI tool locally or as a GitHub Action in CI/CD pipelines</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Scan for outdated dependencies\nuptool scan\n\n# Preview available updates\nuptool plan\n\n# Apply updates with diff preview\nuptool update --diff\n\n# Filter by integration\nuptool update --only npm,terraform\n</code></pre>"},{"location":"#supported-integrations","title":"Supported Integrations","text":"Integration Status Manifest Files Registry npm \u2705 Stable <code>package.json</code> npm Registry API Helm \u2705 Stable <code>Chart.yaml</code> Helm chart repositories pre-commit \u2705 Stable <code>.pre-commit-config.yaml</code> GitHub Releases Terraform \u2705 Stable <code>*.tf</code> Terraform Registry API tflint \u2705 Stable <code>.tflint.hcl</code> GitHub Releases asdf \u2705 Stable <code>.tool-versions</code> GitHub Releases (per tool) mise \u2705 Stable <code>mise.toml</code>, <code>.mise.toml</code> GitHub Releases (per tool)"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to get started? Choose your path:</p> <ul> <li> <p> Installation</p> <p>Install uptool via Go, pre-built binaries, or package managers</p> </li> <li> <p> Quick Start</p> <p>Get up and running in 5 minutes with a sample project</p> </li> <li> <p> User Guide</p> <p>Deep dive into configuration, environments, and advanced usage</p> </li> <li> <p> GitHub Action</p> <p>Automate dependency updates in your CI/CD pipelines</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: santosr2/uptool</li> <li>Issues: Report a bug</li> <li>Discussions: Ask questions</li> <li>Security: See our Security Policy</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Info</p> <p>uptool is under active development. The current focus is on:</p> <ul> <li>\u2705 Stabilizing core integrations (npm, Helm, Terraform, pre-commit, asdf, mise)</li> <li>\ud83d\udea7 Expanding test coverage (target: &gt;70%)</li> <li>\ud83d\udea7 Adding Python ecosystem support</li> <li>\ud83d\udcdd Improving documentation and examples</li> </ul>"},{"location":"#license","title":"License","text":"<p>uptool is released under the MIT License.</p> <p>Made with \u2764\ufe0f by the uptool contributors</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>View Full Changelog</p> <p>For the complete changelog with all releases and updates, please see:</p> <p>CHANGELOG.md on GitHub</p>"},{"location":"CHANGELOG/#about-the-changelog","title":"About the Changelog","text":"<p>The uptool changelog follows the Keep a Changelog format and adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#changelog-categories","title":"Changelog Categories","text":"<ul> <li>Added: New features</li> <li>Changed: Changes in existing functionality</li> <li>Deprecated: Soon-to-be removed features</li> <li>Removed: Removed features</li> <li>Fixed: Bug fixes</li> <li>Security: Security vulnerability fixes</li> </ul>"},{"location":"CHANGELOG/#why-visit-github","title":"Why Visit GitHub?","text":"<p>The CHANGELOG.md on GitHub is automatically generated from conventional commits and is always up-to-date with the latest releases.</p> <p>\u2192 Read the full CHANGELOG.md on GitHub</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>View Full Code of Conduct</p> <p>For the complete Code of Conduct, please see:</p> <p>CODE_OF_CONDUCT.md on GitHub</p>"},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":""},{"location":"CODE_OF_CONDUCT/#examples-of-positive-behavior","title":"Examples of Positive Behavior","text":"<ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes</li> <li>Focusing on what is best for the overall community</li> </ul>"},{"location":"CODE_OF_CONDUCT/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>The use of sexualized language or imagery, and sexual attention or advances</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>\u2192 Read the full CODE_OF_CONDUCT.md on GitHub</p>"},{"location":"CONTRIBUTING/","title":"Contributing to uptool","text":"<p>View Full Contributing Guide</p> <p>This page provides a brief overview. For the complete contributing guide, please see:</p> <p>CONTRIBUTING.md on GitHub</p>"},{"location":"CONTRIBUTING/#quick-links","title":"Quick Links","text":"<ul> <li>Development Setup: See the full guide</li> <li>Code Standards: See the full guide</li> <li>Pull Request Process: See the full guide</li> <li>Testing Requirements: See the full guide</li> </ul>"},{"location":"CONTRIBUTING/#why-visit-github","title":"Why Visit GitHub?","text":"<p>The CONTRIBUTING.md file on GitHub is the source of truth and may contain updates more recent than this documentation build. It also includes:</p> <ul> <li>Detailed development environment setup instructions</li> <li>Comprehensive coding standards and style guides</li> <li>Testing and CI/CD requirements</li> <li>Commit message conventions</li> <li>Release process details</li> </ul> <p>\u2192 Read the full CONTRIBUTING.md on GitHub</p>"},{"location":"GOVERNANCE/","title":"Project Governance","text":"<p>View Full Governance Document</p> <p>For the complete governance policy and decision-making process, please see:</p> <p>GOVERNANCE.md on GitHub</p>"},{"location":"GOVERNANCE/#overview","title":"Overview","text":"<p>uptool follows a trunk-based development workflow with transparent decision-making and community-first principles.</p>"},{"location":"GOVERNANCE/#key-principles","title":"Key Principles","text":"<ul> <li>Trunk-Based Development: All changes merge directly to <code>main</code> after review</li> <li>No Git Flow: Simple, fast-moving development process</li> <li>Community First: Open discussion and transparent decision-making</li> <li>Quality Standards: Comprehensive testing and code review requirements</li> </ul>"},{"location":"GOVERNANCE/#roles","title":"Roles","text":"<ul> <li>Maintainers: Core team members with write access</li> <li>Contributors: Community members who submit pull requests</li> <li>Users: Anyone using uptool in their projects</li> </ul>"},{"location":"GOVERNANCE/#decision-making","title":"Decision Making","text":"<ul> <li>Minor Changes: Approved by any maintainer</li> <li>Major Changes: Require discussion and consensus</li> <li>Breaking Changes: Require RFC and community feedback</li> </ul>"},{"location":"GOVERNANCE/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork and create a feature branch</li> <li>Make changes with tests</li> <li>Submit PR with clear description</li> <li>Address review feedback</li> <li>Maintainer merges after approval</li> </ol> <p>\u2192 Read the full GOVERNANCE.md on GitHub</p>"},{"location":"LICENSE/","title":"License","text":"<p>uptool is licensed under the MIT License.</p>"},{"location":"LICENSE/#mit-license","title":"MIT License","text":"<p>https://github.com/santosr2/uptool/blob/{{ extra.uptool_version }}/LICENSE</p>"},{"location":"LICENSE/#third-party-licenses","title":"Third-Party Licenses","text":"<p>uptool uses the following open-source libraries:</p>"},{"location":"LICENSE/#go-standard-library","title":"Go Standard Library","text":"<ul> <li>License: BSD-3-Clause</li> <li>Copyright: The Go Authors</li> <li>URL: https://golang.org/LICENSE</li> </ul>"},{"location":"LICENSE/#third-party-go-modules","title":"Third-Party Go Modules","text":"<p>To see a complete list of dependencies and their licenses, run:</p> <pre><code>go mod graph\n</code></pre> <p>Or generate a license report:</p> <pre><code># Install go-licenses\ngo install github.com/google/go-licenses@latest\n\n# Generate report\ngo-licenses report github.com/santosr2/uptool/cmd/uptool\n</code></pre>"},{"location":"LICENSE/#attribution","title":"Attribution","text":"<p>If you use uptool in your project, attribution is appreciated but not required.</p> <p>You may include a notice like:</p> <pre><code>This project uses uptool (https://github.com/santosr2/uptool),\nlicensed under the MIT License.\n</code></pre>"},{"location":"LICENSE/#contributing","title":"Contributing","text":"<p>By contributing to uptool, you agree that your contributions will be licensed under the MIT License.</p> <p>See CONTRIBUTING.md for contribution guidelines.</p>"},{"location":"LICENSE/#questions","title":"Questions","text":"<p>If you have questions about licensing, please open an issue on GitHub.</p>"},{"location":"SECURITY/","title":"Security Policy","text":"<p>Security Vulnerabilities</p> <p>If you discover a security vulnerability, please report it responsibly:</p> <p>Report a Security Vulnerability</p> <p>View Full Security Policy</p> <p>For the complete security policy, supported versions, and reporting guidelines, please see:</p> <p>SECURITY.md on GitHub</p>"},{"location":"SECURITY/#quick-overview","title":"Quick Overview","text":""},{"location":"SECURITY/#supported-versions","title":"Supported Versions","text":"<p>uptool follows a 6-month support window for security patches:</p> <ul> <li>Latest minor version: Full support (features, bug fixes, security patches)</li> <li>Previous minor version: Security patches only (6 months after next minor release)</li> <li>Older versions: No support</li> </ul>"},{"location":"SECURITY/#reporting-process","title":"Reporting Process","text":"<ol> <li>DO NOT create a public GitHub issue</li> <li>Use GitHub Security Advisories (private reporting)</li> <li>Provide detailed description and reproduction steps</li> <li>Allow time for investigation and patch development</li> </ol>"},{"location":"SECURITY/#response-timeline","title":"Response Timeline","text":"<ul> <li>Initial Response: Within 48 hours</li> <li>Severity Assessment: Within 1 week</li> <li>Patch Development: Varies by severity (1-4 weeks)</li> <li>Public Disclosure: After patch is available</li> </ul> <p>\u2192 Read the full SECURITY.md on GitHub</p>"},{"location":"action-usage/","title":"GitHub Action Usage Guide","text":"<p>This guide covers how to use uptool as a GitHub Action to automate dependency updates in your CI/CD workflows.</p>"},{"location":"action-usage/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Workflow Examples</li> <li>Inputs Reference</li> <li>Outputs Reference</li> <li>Permissions</li> <li>Common Patterns</li> <li>Troubleshooting</li> </ul>"},{"location":"action-usage/#quick-start","title":"Quick Start","text":""},{"location":"action-usage/#basic-weekly-update-workflow","title":"Basic Weekly Update Workflow","text":"<p>Create <code>.github/workflows/uptool.yml</code>:</p> <pre><code>name: Dependency Updates\n\non:\n  schedule:\n    - cron: '0 9 * * 1'  # Every Monday at 9 AM UTC\n  workflow_dispatch:      # Manual trigger\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0  # Recommended: latest stable\n        with:\n          command: update\n          create-pr: 'true'\n          token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Version Pinning Options:</p> <ul> <li><code>@v0</code> - Latest stable v0.x.x (recommended, auto-updates)</li> <li><code>@v0.1</code> - Latest v0.1.x patch (mutable)</li> <li><code>@v0.1.0</code> - Exact version (immutable, most secure)</li> </ul> <p>This workflow will:</p> <ol> <li>Run every Monday at 9 AM UTC</li> <li>Scan for dependency updates</li> <li>Create a pull request with changes</li> </ol>"},{"location":"action-usage/#workflow-examples","title":"Workflow Examples","text":""},{"location":"action-usage/#scan-and-report-only","title":"Scan and Report Only","text":"<p>Generate a scan report without making changes:</p> <pre><code>name: Dependency Scan\n\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0\n        with:\n          command: scan\n          format: json\n        id: scan\n\n      - name: Comment scan results\n        if: steps.scan.outputs.updates-available == 'true'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: 'Outdated dependencies detected. Run `uptool plan` to see details.'\n            })\n</code></pre>"},{"location":"action-usage/#plan-with-manual-approval","title":"Plan with Manual Approval","text":"<p>Show what would update, then wait for manual approval:</p> <pre><code>name: Dependency Update (Manual Approval)\n\non:\n  workflow_dispatch:\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  plan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Generate update plan\n        uses: santosr2/uptool@v0\n        with:\n          command: plan\n          format: table\n        id: plan\n\n      - name: Show plan\n        run: echo \"Updates available: ${{ steps.plan.outputs.updates-available }}\"\n\n  update:\n    needs: plan\n    runs-on: ubuntu-latest\n    environment: production  # Requires manual approval\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Apply updates\n        uses: santosr2/uptool@v0\n        with:\n          command: update\n          create-pr: 'true'\n          token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"action-usage/#integration-specific-updates","title":"Integration-Specific Updates","text":"<p>Run different integrations on different schedules:</p> <pre><code>name: npm Updates (Daily)\n\non:\n  schedule:\n    - cron: '0 2 * * *'  # Daily at 2 AM UTC\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  npm-update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0\n        with:\n          command: update\n          only: npm\n          create-pr: 'true'\n          pr-title: 'chore(deps): update npm dependencies'\n          pr-branch: 'uptool/npm-updates'\n          token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <pre><code>name: Terraform Updates (Weekly)\n\non:\n  schedule:\n    - cron: '0 9 * * 1'  # Monday at 9 AM UTC\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  terraform-update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0\n        with:\n          command: update\n          only: terraform,tflint\n          create-pr: 'true'\n          pr-title: 'chore(infra): update Terraform dependencies'\n          pr-branch: 'uptool/terraform-updates'\n          token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"action-usage/#dry-run-for-safety","title":"Dry-Run for Safety","text":"<p>Preview changes without creating PRs:</p> <pre><code>name: Dependency Update Dry-Run\n\non:\n  schedule:\n    - cron: '0 9 * * 1'\n\njobs:\n  dry-run:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Check for updates\n        uses: santosr2/uptool@v0\n        with:\n          command: update\n          dry-run: 'true'\n          diff: 'true'\n\n      - name: Post to Slack\n        if: always()\n        run: |\n          # Send notification about available updates\n          echo \"Updates available!\"\n</code></pre>"},{"location":"action-usage/#monorepo-pattern","title":"Monorepo Pattern","text":"<p>Update different parts of a monorepo separately:</p> <pre><code>name: Monorepo Updates\n\non:\n  schedule:\n    - cron: '0 9 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  frontend-deps:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ./frontend\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0\n        with:\n          command: update\n          only: npm\n          create-pr: 'true'\n          pr-title: 'chore(frontend): update dependencies'\n\n  backend-deps:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ./backend\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0\n        with:\n          command: update\n          only: npm\n          create-pr: 'true'\n          pr-title: 'chore(backend): update dependencies'\n</code></pre>"},{"location":"action-usage/#inputs-reference","title":"Inputs Reference","text":"Input Description Default Required <code>command</code> Command to run: <code>scan</code>, <code>plan</code>, or <code>update</code> <code>plan</code> No <code>format</code> Output format: <code>table</code> or <code>json</code> <code>table</code> No <code>only</code> Comma-separated integrations to include <code>''</code> No <code>exclude</code> Comma-separated integrations to exclude <code>''</code> No <code>dry-run</code> Show changes without applying (update only) <code>false</code> No <code>diff</code> Show diffs of changes (update only) <code>true</code> No <code>create-pr</code> Create a pull request with updates <code>false</code> No <code>pr-title</code> Title for the pull request <code>chore: update dependencies</code> No <code>pr-branch</code> Branch name for the PR <code>uptool/dependency-updates</code> No <code>token</code> GitHub token for API access and PR creation <code>${{ github.token }}</code> No"},{"location":"action-usage/#input-details","title":"Input Details","text":"<p><code>command</code>: The uptool command to run</p> <ul> <li><code>scan</code>: Discover manifests and dependencies</li> <li><code>plan</code>: Show available updates</li> <li><code>update</code>: Apply updates to manifests</li> </ul> <p><code>only</code>: Filter to specific integrations</p> <pre><code>only: npm              # Single integration\nonly: npm,helm         # Multiple integrations\nonly: npm,terraform,tflint\n</code></pre> <p><code>exclude</code>: Exclude specific integrations</p> <pre><code>exclude: precommit     # Skip pre-commit\nexclude: terraform,tflint\n</code></pre> <p><code>create-pr</code>: Automatically create a pull request</p> <ul> <li>Requires <code>command: update</code></li> <li>Requires appropriate permissions</li> </ul> <p><code>token</code>: GitHub authentication</p> <ul> <li>Use <code>${{ secrets.GITHUB_TOKEN }}</code> for auto-scoped token</li> <li>Can use PAT for additional permissions</li> </ul>"},{"location":"action-usage/#outputs-reference","title":"Outputs Reference","text":"Output Description Type <code>updates-available</code> Whether updates were found <code>true</code>/<code>false</code> <code>manifests-updated</code> Number of manifests with updates number <code>dependencies-updated</code> Total dependencies updated number"},{"location":"action-usage/#using-outputs","title":"Using Outputs","text":"<pre><code>steps:\n  - uses: santosr2/uptool@v0.1 # or v0.1.0 or v0 or commit hash\n    id: uptool\n    with:\n      command: plan\n\n  - name: Check if updates available\n    if: steps.uptool.outputs.updates-available == 'true'\n    run: |\n      echo \"Found updates in ${{ steps.uptool.outputs.manifests-updated }} manifests\"\n      echo \"Total dependencies to update: ${{ steps.uptool.outputs.dependencies-updated }}\"\n</code></pre>"},{"location":"action-usage/#permissions","title":"Permissions","text":""},{"location":"action-usage/#minimum-permissions","title":"Minimum Permissions","text":"<p>For <code>scan</code> and <code>plan</code> (read-only):</p> <pre><code>permissions:\n  contents: read\n</code></pre> <p>For <code>update</code> with <code>create-pr</code>:</p> <pre><code>permissions:\n  contents: write        # To create commits\n  pull-requests: write   # To create PRs\n</code></pre>"},{"location":"action-usage/#token-scopes","title":"Token Scopes","text":"<p><code>GITHUB_TOKEN</code> (recommended):</p> <ul> <li>Automatically provided by GitHub Actions</li> <li>Scoped to the current repository</li> <li>Expires after the workflow run</li> </ul> <p>Personal Access Token (PAT):</p> <ul> <li>Use when cross-repository access needed</li> <li>Required scopes: <code>repo</code>, <code>workflow</code> (if updating workflows)</li> <li>Store as repository secret</li> </ul>"},{"location":"action-usage/#common-patterns","title":"Common Patterns","text":""},{"location":"action-usage/#skip-ci-on-update-prs","title":"Skip CI on Update PRs","text":"<p>Add <code>[skip ci]</code> to PR commits:</p> <pre><code>- uses: santosr2/uptool@v0.1 # or v0.1.0 or v0 or commit hash\n  with:\n    command: update\n    create-pr: 'true'\n    pr-title: '[skip ci] chore: update dependencies'\n</code></pre>"},{"location":"action-usage/#auto-merge-patch-updates","title":"Auto-Merge Patch Updates","text":"<p>Automatically merge patch-level updates:</p> <pre><code>jobs:\n  update:\n    # ... update steps ...\n\n  auto-merge:\n    needs: update\n    if: needs.update.outputs.updates-available == 'true'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Enable auto-merge for patch updates\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          gh pr merge --auto --squash uptool/dependency-updates\n</code></pre>"},{"location":"action-usage/#notify-on-failures","title":"Notify on Failures","text":"<p>Send notifications when updates fail:</p> <pre><code>jobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0\n        with:\n          command: update\n          create-pr: 'true'\n        continue-on-error: true\n        id: uptool\n\n      - name: Notify on failure\n        if: failure()\n        uses: actions/github-script@v7\n        with:\n          script: |\n            github.rest.issues.create({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              title: 'Dependency update failed',\n              body: 'The automated dependency update workflow failed. Check the logs.'\n            })\n</code></pre>"},{"location":"action-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"action-usage/#pr-not-created","title":"PR Not Created","text":"<p>Problem: Workflow runs but no PR appears</p> <p>Solutions:</p> <ol> <li>Check permissions are set correctly</li> <li>Verify <code>create-pr: 'true'</code> (must be string)</li> <li>Ensure token has <code>pull-requests: write</code> scope</li> <li>Check if a PR already exists on that branch</li> </ol>"},{"location":"action-usage/#no-updates-found","title":"No Updates Found","text":"<p>Problem: uptool reports \"No updates available\" but dependencies are outdated</p> <p>Solutions:</p> <ol> <li>Check integration is enabled: <code>--only=&lt;integration&gt;</code></li> <li>Verify manifest files are in expected locations</li> <li>Test locally: <code>uptool scan</code> and <code>uptool plan</code></li> <li>Check registry connectivity (npm, Terraform, etc.)</li> </ol>"},{"location":"action-usage/#authentication-errors","title":"Authentication Errors","text":"<p>Problem: \"403 Forbidden\" or \"401 Unauthorized\"</p> <p>Solutions:</p> <ol> <li>For GitHub releases: May be rate-limited without auth</li> <li>Use <code>GITHUB_TOKEN</code>: <code>token: ${{ secrets.GITHUB_TOKEN }}</code></li> <li>For private registries: Configure credentials separately</li> </ol>"},{"location":"action-usage/#action-times-out","title":"Action Times Out","text":"<p>Problem: Workflow exceeds time limits</p> <p>Solutions:</p> <ol> <li>Use <code>--only</code> to run integrations separately</li> <li>Schedule different integrations at different times</li> <li>Increase timeout: <code>timeout-minutes: 30</code></li> </ol>"},{"location":"action-usage/#merge-conflicts","title":"Merge Conflicts","text":"<p>Problem: Update PR has conflicts</p> <p>Solutions:</p> <ol> <li>Close PR and let workflow create a fresh one</li> <li>Update the base branch: <code>git merge main</code></li> <li>Schedule updates when <code>main</code> is stable</li> </ol>"},{"location":"action-usage/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"action-usage/#custom-pr-body-template","title":"Custom PR Body Template","text":"<pre><code>- uses: santosr2/uptool@v0.1 # or v0.1.0 or v0 or commit hash\n  with:\n    command: update\n    create-pr: 'true'\n\n# Note: PR body is currently fixed, but this shows the structure\n# Future enhancement could allow custom templates\n</code></pre>"},{"location":"action-usage/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Run tests after update:</p> <pre><code>- uses: santosr2/uptool@v0.1 # or v0.1.0 or v0 or commit hash\n  with:\n    command: update\n\n- name: Run tests\n  run: npm test\n\n- name: Create PR if tests pass\n  if: success()\n  uses: peter-evans/create-pull-request@v6\n  with:\n    title: 'chore: update dependencies (tests passing)'\n</code></pre>"},{"location":"action-usage/#matrix-strategy-for-multiple-integrations","title":"Matrix Strategy for Multiple Integrations","text":"<pre><code>jobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        integration: [npm, helm, terraform]\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: santosr2/uptool@v0\n        with:\n          command: update\n          only: ${{ matrix.integration }}\n          create-pr: 'true'\n          pr-branch: uptool/${{ matrix.integration }}-updates\n</code></pre>"},{"location":"action-usage/#best-practices","title":"Best Practices","text":"<ol> <li>Pin the action version: Use <code>@v0</code> (recommended), <code>@v0.1</code>, or <code>@v0.1.0</code> - never <code>@main</code></li> <li>Test dry-run first: Validate behavior with <code>dry-run: 'true'</code></li> <li>Use specific integrations: Run <code>--only=npm</code> for targeted updates</li> <li>Schedule wisely: Avoid peak hours and weekends</li> <li>Review PRs: Always review before merging</li> <li>Monitor for failures: Set up notifications</li> <li>Keep permissions minimal: Only grant what's needed</li> </ol> <p>Questions? Open a Discussion!</p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>This document provides a comprehensive overview of uptool's architecture, design decisions, and internal components.</p>"},{"location":"architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Design Principles</li> <li>System Architecture</li> <li>Core Components</li> <li>Data Flow</li> <li>Integration Architecture</li> <li>Datasource Abstraction</li> <li>Manifest Rewriting</li> <li>Error Handling</li> <li>Performance Considerations</li> </ul>"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#1-manifest-first-philosophy","title":"1. Manifest-First Philosophy","text":"<p>Core Tenet: Always update configuration files (manifests) directly, never rely solely on lockfile updates.</p> <p>Rationale:</p> <ul> <li>Lockfiles can drift from manifests</li> <li>Manifests are the source of truth</li> <li>Better auditability and version control</li> <li>Consistent with developer workflows</li> </ul> <p>Implementation:</p> <ul> <li>Integrations parse and rewrite manifest files</li> <li>Native commands used only when they update manifests</li> <li>Manual rewriting when native tools don't support manifest updates</li> </ul>"},{"location":"architecture/#2-format-preservation","title":"2. Format Preservation","text":"<p>Goal: Maintain YAML comments, indentation, and structure when updating manifests.</p> <p>Challenges:</p> <ul> <li>Standard YAML parsers lose comments</li> <li>Indentation styles vary</li> <li>Custom formatting preferences</li> </ul> <p>Solution:</p> <ul> <li>Custom YAML rewriter in <code>internal/rewrite/yaml.go</code></li> <li>Line-by-line processing</li> <li>Preserves everything except the version string</li> </ul>"},{"location":"architecture/#3-extensibility","title":"3. Extensibility","text":"<p>Design: Plugin-based architecture for integrations.</p> <p>Benefits:</p> <ul> <li>Easy to add new package ecosystems</li> <li>Integrations are isolated</li> <li>Clear interfaces for testing</li> </ul> <p>Structure:</p> <pre><code>internal/integrations/\n\u251c\u2500\u2500 registry.go          # Integration registration system\n\u251c\u2500\u2500 npm/\n\u2502   \u2514\u2500\u2500 npm.go          # npm implementation\n\u251c\u2500\u2500 helm/\n\u2502   \u2514\u2500\u2500 helm.go         # Helm implementation\n\u2514\u2500\u2500 ...\n\ninternal/engine/\n\u2514\u2500\u2500 types.go            # Integration interface definition\n</code></pre>"},{"location":"architecture/#system-architecture","title":"System Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         CLI Layer                           \u2502\n\u2502                     (cmd/uptool)                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Engine Layer                         \u2502\n\u2502                   (internal/engine)                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502   Scan       \u2502  \u2502    Plan      \u2502  \u2502   Update     \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502            \u2502                 \u2502\n        \u25bc            \u25bc                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Integration\u2502  \u2502 Datasource \u2502  \u2502 Rewrite  \u2502\n\u2502  Layer    \u2502  \u2502   Layer    \u2502  \u2502  Layer   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u25bc\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2502  Registry    \u2502\n             \u2502   Clients    \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        External Systems              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502npm \u2502 \u2502PyPI\u2502 \u2502Helm\u2502 \u2502etc.\u2502         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#1-cli-layer-cmduptool","title":"1. CLI Layer (<code>cmd/uptool</code>)","text":"<p>Responsibility: Command-line interface and user interaction.</p> <p>Components:</p> <ul> <li>Command parsing (Cobra)</li> <li>Flag validation</li> <li>Output formatting (table, JSON)</li> <li>Error display</li> </ul> <p>Files:</p> <ul> <li><code>cmd/uptool/main.go</code> - Entry point</li> <li><code>cmd/uptool/cmd/root.go</code> - Root command</li> <li><code>cmd/uptool/cmd/scan.go</code> - Scan command</li> <li><code>cmd/uptool/cmd/plan.go</code> - Plan command</li> <li><code>cmd/uptool/cmd/update.go</code> - Update command</li> </ul>"},{"location":"architecture/#2-engine-layer-internalengine","title":"2. Engine Layer (<code>internal/engine</code>)","text":"<p>Responsibility: Orchestrate the update workflow.</p> <p>Core Functions:</p> <pre><code>// Scan discovers available updates\nfunc (e *Engine) Scan(ctx context.Context, opts ScanOptions) ([]Update, error)\n\n// Plan shows what would be updated\nfunc (e *Engine) Plan(ctx context.Context, opts PlanOptions) ([]Change, error)\n\n// Apply executes the updates\nfunc (e *Engine) Apply(ctx context.Context, opts ApplyOptions) error\n</code></pre> <p>Workflow:</p> <ol> <li>Load configuration from <code>uptool.yaml</code></li> <li>Discover integrations (auto-detect manifest files)</li> <li>Query registries for available versions</li> <li>Apply policy rules (allow major/minor/patch)</li> <li>Generate update plan</li> <li>Execute updates (if not dry-run)</li> </ol>"},{"location":"architecture/#3-integration-layer-internalintegrations","title":"3. Integration Layer (<code>internal/integrations</code>)","text":"<p>Responsibility: Implement package ecosystem logic.</p> <p>Interface:</p> <pre><code>type Integration interface {\n    // Name returns the integration identifier\n    Name() string\n\n    // Detect finds manifest files for this integration\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n\n    // Plan determines available updates for a manifest\n    Plan(ctx context.Context, manifest *Manifest) (*UpdatePlan, error)\n\n    // Apply executes the update plan\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n\n    // Validate checks if changes are valid (optional)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p>Implementations:</p> <ul> <li><code>npm</code> - package.json</li> <li><code>helm</code> - Chart.yaml</li> <li><code>terraform</code> - versions.tf, *.tf</li> <li><code>tflint</code> - .tflint.hcl</li> <li><code>precommit</code> - .pre-commit-config.yaml (native command)</li> <li><code>asdf</code> - .tool-versions</li> <li><code>mise</code> - mise.toml, .mise.toml</li> </ul>"},{"location":"architecture/#4-datasource-layer-internaldatasource","title":"4. Datasource Layer (<code>internal/datasource</code>)","text":"<p>Responsibility: Query package registries for available versions.</p> <p>Interface:</p> <pre><code>type Datasource interface {\n    // Name returns the datasource identifier\n    Name() string\n\n    // GetLatestVersion returns the latest stable version for a package\n    GetLatestVersion(ctx context.Context, pkg string) (string, error)\n\n    // GetVersions returns all available versions for a package\n    GetVersions(ctx context.Context, pkg string) ([]string, error)\n\n    // GetPackageInfo returns detailed information about a package\n    GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n}\n</code></pre> <p>Implementations:</p> <ul> <li><code>npm</code> - npm registry API</li> <li><code>helm</code> - Artifact Hub / Helm repository</li> <li><code>terraform</code> - Terraform Registry API</li> <li><code>github</code> - GitHub Releases API (for tools like pre-commit, tflint)</li> </ul> <p>Architecture: The datasource layer provides high-level abstractions that wrap low-level HTTP clients in <code>internal/registry/</code>. Each datasource (e.g., <code>internal/datasource/npm.go</code>) implements the <code>Datasource</code> interface by delegating to a registry client (e.g., <code>internal/registry/npm.go</code> with <code>NPMClient</code>).</p> <p>Caching: Future enhancement (not yet implemented).</p>"},{"location":"architecture/#5-rewrite-layer-internalrewrite","title":"5. Rewrite Layer (<code>internal/rewrite</code>)","text":"<p>Responsibility: Preserve formatting while updating files.</p> <p>Key Features:</p> <ul> <li>YAML comment preservation</li> <li>Line-by-line processing</li> <li>Minimal changes to file structure</li> <li>Diff generation</li> </ul> <p>Files:</p> <ul> <li><code>internal/rewrite/yaml.go</code> - YAML rewriter</li> <li><code>internal/rewrite/diff.go</code> - Diff generator</li> </ul>"},{"location":"architecture/#6-resolve-layer-internalresolve","title":"6. Resolve Layer (<code>internal/resolve</code>)","text":"<p>Responsibility: Semantic version resolution and comparison.</p> <p>Functions:</p> <ul> <li>Parse semantic versions</li> <li>Compare versions</li> <li>Filter by constraints (^1.0.0, ~2.3.0)</li> <li>Classify impact (major, minor, patch)</li> </ul> <p>Files:</p> <ul> <li><code>internal/resolve/semver.go</code></li> </ul>"},{"location":"architecture/#7-policy-layer-internalpolicy","title":"7. Policy Layer (<code>internal/policy</code>)","text":"<p>Responsibility: Load and apply update policies.</p> <p>Configuration Example:</p> <pre><code># uptool.yaml\nversion: 1\n\norg_policy:\n  signing:\n    cosign_verify: false\n  auto_merge:\n    enabled: false\n    guards: []\n  require_signoff_from: []\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      enabled: true\n      update: minor  # none, patch, minor, major\n      allow_prerelease: false\n      pin: true\n      cadence: weekly  # daily, weekly, monthly\n\n  - id: terraform\n    enabled: true\n    policy:\n      enabled: true\n      update: patch\n      allow_prerelease: false\n      pin: true\n</code></pre> <p>Files:</p> <ul> <li><code>internal/policy/config.go</code></li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#scan-command-flow","title":"Scan Command Flow","text":"<pre><code>User runs: uptool scan\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Load Config     \u2502  Read uptool.yaml\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. Detect Manifests\u2502  Find package.json, Chart.yaml, etc.\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. Parse Manifests \u2502  Extract dependencies\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. Query Registries\u2502  Get latest versions (parallel)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5. Apply Policy    \u2502  Filter by update rules\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 6. Format Output   \u2502  Table or JSON\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#update-command-flow","title":"Update Command Flow","text":"<pre><code>User runs: uptool update\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Scan (above)    \u2502  Get available updates\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. Generate Plan   \u2502  What will change\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. Backup Manifests\u2502  Create .bak files\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. Rewrite Files   \u2502  Update versions\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5. Validate        \u2502  Check syntax\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 6. Run Native Cmds \u2502  npm install, etc. (if configured)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#integration-architecture","title":"Integration Architecture","text":""},{"location":"architecture/#integration-lifecycle","title":"Integration Lifecycle","text":"<ol> <li>Detection: Integration discovers manifest files and extracts dependencies (via <code>Detect()</code>)</li> <li>Datasource Query: Fetch available versions from registries (via datasource layer)</li> <li>Planning: Determine what to update based on policy (via <code>Plan()</code>)</li> <li>Application: Rewrite manifests with new versions (via <code>Apply()</code>)</li> <li>Validation: Ensure updated manifests are valid (via <code>Validate()</code>)</li> <li>Post-Update: Run native commands (optional, integration-specific)</li> </ol>"},{"location":"architecture/#integration-types","title":"Integration Types","text":""},{"location":"architecture/#type-1-manifest-rewriting-npm-helm-asdf-mise","title":"Type 1: Manifest Rewriting (npm, Helm, asdf, mise)","text":"<p>Strategy: Parse manifest, rewrite in-place, preserve formatting.</p> <p>Example (npm):</p> <pre><code>// Before\n{\n  \"dependencies\": {\n    \"react\": \"^18.2.0\"  // Keep this comment\n  }\n}\n\n// After\n{\n  \"dependencies\": {\n    \"react\": \"^18.3.1\"  // Keep this comment\n  }\n}\n</code></pre>"},{"location":"architecture/#type-2-native-command-pre-commit","title":"Type 2: Native Command (pre-commit)","text":"<p>Strategy: Delegate to native tool when it updates manifests.</p> <p>Example:</p> <pre><code># pre-commit updates .pre-commit-config.yaml\npre-commit autoupdate\n</code></pre> <p>When to Use:</p> <ul> <li>Tool already updates manifests correctly</li> <li>Format preservation is guaranteed</li> <li>No need for custom parsing</li> </ul>"},{"location":"architecture/#type-3-hybrid-terraform","title":"Type 3: Hybrid (Terraform)","text":"<p>Strategy: Parse HCL, rewrite with custom logic, validate with <code>terraform fmt</code>.</p> <p>Challenges:</p> <ul> <li>HCL has complex syntax</li> <li>Multiple file locations (versions.tf, main.tf)</li> <li>Version constraints vary</li> </ul>"},{"location":"architecture/#datasource-abstraction","title":"Datasource Abstraction","text":""},{"location":"architecture/#design-pattern","title":"Design Pattern","text":"<p>Each datasource implements a common interface, allowing integrations to be registry-agnostic. Datasources wrap low-level HTTP registry clients to provide a unified API.</p> <p>Benefits:</p> <ul> <li>Support for private registries</li> <li>Caching at datasource level</li> <li>Consistent error handling</li> <li>Separation of concerns (high-level datasource logic vs low-level HTTP details)</li> </ul>"},{"location":"architecture/#datasource-implementations","title":"Datasource Implementations","text":""},{"location":"architecture/#npm-registry","title":"npm Registry","text":"<p>Endpoint: <code>https://registry.npmjs.org/&lt;package&gt;</code></p> <p>Response:</p> <pre><code>{\n  \"versions\": {\n    \"1.0.0\": {},\n    \"2.0.0\": {}\n  },\n  \"dist-tags\": {\n    \"latest\": \"2.0.0\"\n  }\n}\n</code></pre>"},{"location":"architecture/#helm-artifact-hub","title":"Helm (Artifact Hub)","text":"<p>Endpoint: <code>https://artifacthub.io/api/v1/packages/helm/&lt;repo&gt;/&lt;chart&gt;</code></p> <p>Challenge: Helm repositories are decentralized, need to query specific repos.</p>"},{"location":"architecture/#terraform-registry","title":"Terraform Registry","text":"<p>Endpoint: <code>https://registry.terraform.io/v1/providers/&lt;namespace&gt;/&lt;name&gt;/versions</code></p> <p>Response:</p> <pre><code>{\n  \"versions\": [\n    {\"version\": \"1.0.0\"},\n    {\"version\": \"2.0.0\"}\n  ]\n}\n</code></pre>"},{"location":"architecture/#manifest-rewriting","title":"Manifest Rewriting","text":""},{"location":"architecture/#yaml-rewriter-algorithm","title":"YAML Rewriter Algorithm","text":"<p>Goal: Update version strings while preserving everything else.</p> <p>Algorithm:</p> <pre><code>1. Read file line-by-line\n2. For each line:\n   a. Check if it contains a dependency key\n   b. If yes, extract current version\n   c. Replace with new version (exact string match)\n   d. Preserve indentation, comments, quotes\n3. Write modified lines to file\n</code></pre> <p>Example:</p> <pre><code># Input\ndependencies:\n  - name: nginx\n    version: 1.24.0  # Production version\n    repository: https://...\n\n# Update nginx to 1.25.0\n\n# Output (only version changed)\ndependencies:\n  - name: nginx\n    version: 1.25.0  # Production version\n    repository: https://...\n</code></pre>"},{"location":"architecture/#diff-generation","title":"Diff Generation","text":"<p>Purpose: Show users exactly what will change.</p> <p>Implementation:</p> <ul> <li>Unified diff format</li> <li>Color coding (green = additions, red = deletions)</li> <li>Context lines (3 before/after)</li> </ul> <p>Example:</p> <pre><code>--- Chart.yaml\n+++ Chart.yaml\n@@ -3,7 +3,7 @@\n name: myapp\n description: My application\n-version: 1.0.0\n+version: 1.1.0\n dependencies:\n   - name: postgresql\n-    version: 12.0.0\n+    version: 13.0.0\n</code></pre>"},{"location":"architecture/#error-handling","title":"Error Handling","text":""},{"location":"architecture/#error-categories","title":"Error Categories","text":"<ol> <li>User Errors (exit code 1)</li> <li>Invalid configuration</li> <li>Missing manifest files</li> <li> <p>Invalid version constraints</p> </li> <li> <p>Registry Errors (exit code 2)</p> </li> <li>Network failures</li> <li>API rate limits</li> <li> <p>Package not found</p> </li> <li> <p>Update Errors (exit code 3)</p> </li> <li>Manifest syntax errors after update</li> <li>Native command failures</li> <li>Permission issues</li> </ol>"},{"location":"architecture/#error-recovery","title":"Error Recovery","text":"<p>Strategy: Fail-safe operations.</p> <p>Mechanisms:</p> <ul> <li>Automatic backups before updates</li> <li>Atomic file writes (write to temp, then rename)</li> <li>Rollback on validation failure</li> <li>Detailed error messages with recovery suggestions</li> </ul>"},{"location":"architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/#current-state","title":"Current State","text":"<ul> <li>Sequential processing: One integration at a time</li> <li>No caching: Every run queries registries</li> <li>Blocking I/O: File operations are synchronous</li> </ul>"},{"location":"architecture/#future-optimizations","title":"Future Optimizations","text":"<ol> <li>Parallel Registry Queries</li> <li>Use goroutines for concurrent queries</li> <li> <p>Target: 5-10x speedup for large projects</p> </li> <li> <p>Caching Layer</p> </li> <li>In-memory cache for registry responses</li> <li>Disk cache with TTL</li> <li> <p>Target: 90% cache hit rate on repeated scans</p> </li> <li> <p>Incremental Scanning</p> </li> <li>Only check changed manifests</li> <li>Use file modification times</li> <li> <p>Target: Skip 80% of unchanged files</p> </li> <li> <p>Connection Pooling</p> </li> <li>Reuse HTTP connections to registries</li> <li>Target: Reduce connection overhead by 50%</li> </ol>"},{"location":"architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"architecture/#test-strategy","title":"Test Strategy","text":"<ol> <li>Unit Tests: Individual functions (target: 70% coverage)</li> <li>Integration Tests: End-to-end workflows with real files</li> <li>Golden File Tests: Compare output against expected results</li> <li>Benchmark Tests: Performance regression detection</li> </ol>"},{"location":"architecture/#test-fixtures","title":"Test Fixtures","text":"<p>Located in <code>testdata/</code>:</p> <ul> <li>Sample manifest files for each integration</li> <li>Expected outputs (golden files)</li> <li>Mock registry responses</li> </ul>"},{"location":"architecture/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/#threat-model","title":"Threat Model","text":"<ol> <li>Supply Chain Attacks</li> <li>Compromised registries</li> <li>Malicious package versions</li> <li> <p>MITM attacks</p> </li> <li> <p>File System Access</p> </li> <li>Permission issues</li> <li>Symlink attacks</li> <li>Path traversal</li> </ol>"},{"location":"architecture/#mitigations","title":"Mitigations","text":"<ul> <li>HTTPS for all registry communications</li> <li>Certificate pinning (future)</li> <li>File permission checks</li> <li>Input validation</li> <li>Dependency signing verification (future)</li> </ul>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<p>Want to add a new integration? See:</p> <ul> <li>Plugin Development Guide</li> <li>Integration Interface - Core types and Integration interface</li> <li>Integration Registry - Integration registration</li> </ul> <p>Want to add a new datasource? See:</p> <ul> <li>NPM Datasource - Example datasource implementation</li> <li>NPM Registry Client - Example low-level HTTP client</li> <li>Datasource Package - All datasources</li> <li>Registry Package - All registry HTTP clients</li> </ul>"},{"location":"architecture/#glossary","title":"Glossary","text":"<ul> <li>Manifest: Configuration file (package.json, Chart.yaml, etc.)</li> <li>Integration: Package ecosystem support (npm, Helm, etc.)</li> <li>Datasource: High-level abstraction for querying package versions</li> <li>Registry: Package repository (npm registry, Artifact Hub, etc.) or low-level HTTP client</li> <li>Dependency: External package required by the project</li> <li>Update: Changing a dependency version</li> <li>Policy: Rules controlling which updates are allowed</li> </ul> <p>Last updated: 2025-01-19</p>"},{"location":"configuration/","title":"Configuration Reference","text":"<p>uptool can be configured using a <code>uptool.yaml</code> file in your repository root. Configuration is optional \u2014 if no file exists, uptool runs all integrations with sensible defaults.</p>"},{"location":"configuration/#quick-start","title":"Quick Start","text":"<p>Create <code>uptool.yaml</code> in your repository root:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"configuration/#configuration-schema","title":"Configuration Schema","text":""},{"location":"configuration/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>version: 1                    # Configuration format version (required)\n\nintegrations:                 # List of integration configurations\n  - id: &lt;integration_id&gt;      # Integration identifier\n    enabled: true|false       # Enable/disable this integration\n    match:                    # Optional: File matching rules\n      files: [...]            # List of file patterns\n    policy:                   # Update policy for this integration\n      enabled: true|false\n      update: none|patch|minor|major\n      allow_prerelease: true|false\n      pin: true|false\n      cadence: daily|weekly|monthly\n\norg_policy:                   # Optional: Organization-wide settings\n  # Advanced settings (future)\n</code></pre>"},{"location":"configuration/#version","title":"version","text":"<p>Type: <code>integer</code> Required: Yes Default: N/A</p> <p>The configuration format version. Currently only <code>1</code> is supported.</p> <pre><code>version: 1\n</code></pre> <p>Future versions may introduce breaking changes to the configuration schema.</p>"},{"location":"configuration/#integrations","title":"integrations","text":"<p>Type: <code>array</code> Required: No Default: All integrations enabled with default policies</p> <p>List of integration configurations. Each integration can be individually configured.</p>"},{"location":"configuration/#integration-object","title":"Integration Object","text":"<pre><code>- id: npm                     # Integration identifier\n  enabled: true               # Enable this integration\n  match:                      # File matching (optional)\n    files:\n      - \"package.json\"\n      - \"apps/*/package.json\"\n  policy:                     # Update policy\n    enabled: true\n    update: minor\n    allow_prerelease: false\n    pin: true\n    cadence: weekly\n</code></pre>"},{"location":"configuration/#id","title":"id","text":"<p>Type: <code>string</code> Required: Yes Allowed values: <code>npm</code>, <code>helm</code>, <code>terraform</code>, <code>tflint</code>, <code>precommit</code>, <code>asdf</code>, <code>mise</code></p> <p>The integration identifier. Must match a registered integration.</p> <p>Example:</p> <pre><code>integrations:\n  - id: npm\n  - id: helm\n  - id: terraform\n</code></pre>"},{"location":"configuration/#enabled","title":"enabled","text":"<p>Type: <code>boolean</code> Required: No Default: <code>true</code></p> <p>Whether this integration should run.</p> <p>Example:</p> <pre><code># Enable npm updates\n- id: npm\n  enabled: true\n\n# Disable terraform updates\n- id: terraform\n  enabled: false\n</code></pre> <p>Note: CLI flags <code>--only</code> and <code>--exclude</code> override this setting.</p>"},{"location":"configuration/#match","title":"match","text":"<p>Type: <code>object</code> Required: No Default: Integration-specific defaults</p> <p>File matching rules for this integration. Overrides integration defaults.</p>"},{"location":"configuration/#matchfiles","title":"match.files","text":"<p>Type: <code>array</code> of <code>string</code> Required: No Default: Integration-specific patterns</p> <p>Glob patterns for files to include.</p> <p>Example:</p> <pre><code>- id: npm\n  match:\n    files:\n      - \"package.json\"           # Root package.json\n      - \"apps/*/package.json\"    # Monorepo packages\n      - \"packages/*/package.json\"\n</code></pre> <p>Default Patterns by Integration:</p> Integration Default Patterns npm <code>package.json</code> helm <code>Chart.yaml</code>, <code>*/Chart.yaml</code>, <code>charts/*/Chart.yaml</code> terraform <code>*.tf</code>, <code>**/*.tf</code> tflint <code>.tflint.hcl</code> precommit <code>.pre-commit-config.yaml</code> asdf <code>.tool-versions</code> mise <code>mise.toml</code>, <code>.mise.toml</code>"},{"location":"configuration/#policy","title":"policy","text":"<p>Type: <code>object</code> Required: No Default: See defaults below</p> <p>Update policy for this integration.</p> <pre><code>policy:\n  enabled: true\n  update: minor\n  allow_prerelease: false\n  pin: true\n  cadence: weekly\n</code></pre>"},{"location":"configuration/#policyenabled","title":"policy.enabled","text":"<p>Type: <code>boolean</code> Required: No Default: <code>true</code></p> <p>Whether to apply updates for this integration.</p> <pre><code># Scan and plan, but don't update\n- id: terraform\n  policy:\n    enabled: false\n</code></pre>"},{"location":"configuration/#policyupdate","title":"policy.update","text":"<p>Type: <code>string</code> Required: No Default: <code>minor</code> Allowed values: <code>none</code>, <code>patch</code>, <code>minor</code>, <code>major</code></p> <p>Maximum version bump to allow.</p> <p>Values:</p> <ul> <li><code>none</code>: No updates (scan/plan only)</li> <li><code>patch</code>: Only patch updates (1.2.3 \u2192 1.2.4)</li> <li><code>minor</code>: Patch and minor updates (1.2.3 \u2192 1.3.0)</li> <li><code>major</code>: All updates including major (1.2.3 \u2192 2.0.0)</li> </ul> <p>Example:</p> <pre><code>integrations:\n  # Conservative: only patch updates for runtime tools\n  - id: mise\n    policy:\n      update: patch\n\n  # Standard: minor updates for libraries\n  - id: npm\n    policy:\n      update: minor\n\n  # Aggressive: major updates for development tools\n  - id: precommit\n    policy:\n      update: major\n</code></pre> <p>Semantic Versioning Rules:</p> Current Patch Allows Minor Allows Major Allows 1.2.3 1.2.4 1.3.0 2.0.0 0.5.2 0.5.3 0.6.0 1.0.0 2.0.0 2.0.1 2.1.0 3.0.0"},{"location":"configuration/#policyallow_prerelease","title":"policy.allow_prerelease","text":"<p>Type: <code>boolean</code> Required: No Default: <code>false</code></p> <p>Whether to consider pre-release versions (alpha, beta, rc).</p> <p>Example:</p> <pre><code># Stable versions only\n- id: terraform\n  policy:\n    allow_prerelease: false\n\n# Include pre-releases for testing new features\n- id: helm\n  policy:\n    allow_prerelease: true\n</code></pre> <p>Pre-release formats recognized:</p> <ul> <li><code>1.2.3-alpha.1</code></li> <li><code>1.2.3-beta.2</code></li> <li><code>1.2.3-rc.1</code></li> <li><code>1.2.3-pre</code></li> </ul>"},{"location":"configuration/#policypin","title":"policy.pin","text":"<p>Type: <code>boolean</code> Required: No Default: Depends on integration</p> <p>Whether to write exact versions or ranges.</p> <p>Example:</p> <pre><code># Write exact versions\n- id: terraform\n  policy:\n    pin: true\n# Result: version = \"5.8.1\"\n\n# Write version ranges (where supported)\n- id: npm\n  policy:\n    pin: false\n# Result: \"express\": \"^4.19.2\"\n</code></pre> <p>Integration Support:</p> Integration pin: true pin: false npm <code>\"4.19.2\"</code> <code>\"^4.19.2\"</code> (preserves constraint) helm <code>12.0.0</code> <code>12.0.0</code> (always pinned) terraform <code>\"5.8.1\"</code> <code>\"&gt;= 5.8.1\"</code> (not yet implemented) tflint <code>\"0.44.0\"</code> <code>\"0.44.0\"</code> (always pinned) precommit <code>v6.0.0</code> <code>v6.0.0</code> (always pinned) asdf <code>1.25.0</code> <code>1.25.0</code> (always pinned) mise <code>\"1.25\"</code> <code>\"1.25\"</code> (always pinned)"},{"location":"configuration/#policycadence","title":"policy.cadence","text":"<p>Type: <code>string</code> Required: No Default: Not enforced Allowed values: <code>daily</code>, <code>weekly</code>, <code>monthly</code> Status: \u26a0\ufe0f Planned feature (not yet implemented)</p> <p>Recommended update frequency for CI/CD automation.</p> <p>Example:</p> <pre><code>- id: mise\n  policy:\n    cadence: weekly  # Update runtime tools weekly\n\n- id: npm\n  policy:\n    cadence: daily   # Update dependencies daily\n</code></pre> <p>This field is currently for documentation only. Future versions may enforce cadence in GitHub Actions.</p>"},{"location":"configuration/#org_policy","title":"org_policy","text":"<p>Type: <code>object</code> Required: No Default: None Status: \u26a0\ufe0f Planned feature (not yet implemented)</p> <p>Organization-wide policy settings for enterprise use.</p> <p>Planned features:</p> <pre><code>org_policy:\n  # Require sign-off for certain update types\n  require_signoff_from:\n    - \"platform-team@company.com\"\n    - \"security-team@company.com\"\n\n  # Artifact signing verification\n  signing:\n    cosign_verify: true\n    policy_url: \"https://company.com/signing-policy.json\"\n\n  # Auto-merge settings for GitHub Actions\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"\n      - \"codeowners-approve\"\n      - \"security-scan-pass\"\n</code></pre>"},{"location":"configuration/#complete-examples","title":"Complete Examples","text":""},{"location":"configuration/#conservative-configuration","title":"Conservative Configuration","text":"<p>For production systems requiring stability:</p> <pre><code>version: 1\n\nintegrations:\n  # Only patch updates for runtime dependencies\n  - id: mise\n    enabled: true\n    policy:\n      update: patch\n      allow_prerelease: false\n\n  - id: npm\n    enabled: true\n    policy:\n      update: patch\n      allow_prerelease: false\n\n  # Minor updates for infrastructure\n  - id: terraform\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  # Disable dev tools updates\n  - id: precommit\n    enabled: false\n\n  - id: tflint\n    enabled: false\n</code></pre>"},{"location":"configuration/#aggressive-configuration","title":"Aggressive Configuration","text":"<p>For development environments or testing:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: major\n      allow_prerelease: true\n\n  - id: helm\n    enabled: true\n    policy:\n      update: major\n      allow_prerelease: false\n\n  - id: terraform\n    enabled: true\n    policy:\n      update: major\n      allow_prerelease: false\n\n  - id: precommit\n    enabled: true\n    policy:\n      update: major\n      allow_prerelease: false\n\n  - id: tflint\n    enabled: true\n    policy:\n      update: major\n      allow_prerelease: false\n\n  - id: mise\n    enabled: true\n    policy:\n      update: minor  # Still conservative for runtime tools\n      allow_prerelease: false\n</code></pre>"},{"location":"configuration/#monorepo-configuration","title":"Monorepo Configuration","text":"<p>For monorepos with multiple package.json files:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    match:\n      files:\n        - \"package.json\"            # Root package.json\n        - \"apps/*/package.json\"     # App packages\n        - \"packages/*/package.json\" # Shared packages\n        - \"tools/*/package.json\"    # Tool packages\n    policy:\n      update: minor\n      allow_prerelease: false\n      pin: false  # Use ranges for npm\n\n  - id: terraform\n    enabled: true\n    match:\n      files:\n        - \"infrastructure/**/*.tf\"\n        - \"modules/**/*.tf\"\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"configuration/#selective-integration-configuration","title":"Selective Integration Configuration","text":"<p>Only update specific ecosystems:</p> <pre><code>version: 1\n\nintegrations:\n  # Enable only npm and Helm updates\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  # Explicitly disable others\n  - id: terraform\n    enabled: false\n\n  - id: tflint\n    enabled: false\n\n  - id: precommit\n    enabled: false\n\n  - id: mise\n    enabled: false\n</code></pre>"},{"location":"configuration/#configuration-precedence","title":"Configuration Precedence","text":"<p>Settings are applied in this order (later overrides earlier):</p> <ol> <li>Integration defaults (hardcoded in code)</li> <li><code>uptool.yaml</code> configuration (if exists)</li> <li>CLI flags (<code>--only</code>, <code>--exclude</code>)</li> </ol> <p>Example:</p> <pre><code># uptool.yaml\nintegrations:\n  - id: npm\n    enabled: false\n</code></pre> <pre><code># CLI overrides config file\nuptool update --only=npm  # npm WILL update despite enabled: false\n</code></pre>"},{"location":"configuration/#validation","title":"Validation","text":"<p>uptool validates configuration on startup:</p> <p>Valid:</p> <pre><code>version: 1\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\n</code></pre> <p>Invalid (logs warning, uses defaults):</p> <pre><code>version: 1\nintegrations:\n  - id: unknown_integration  # \u274c Unknown integration\n    enabled: true\n\n  - id: npm\n    policy:\n      update: invalid_value  # \u274c Invalid update value\n</code></pre> <p>Validation errors are logged:</p> <pre><code>WARN: Unknown integration 'unknown_integration' in config, skipping\nWARN: Invalid update policy 'invalid_value' for npm, using default 'minor'\n</code></pre>"},{"location":"configuration/#best-practices","title":"Best Practices","text":""},{"location":"configuration/#1-start-conservative","title":"1. Start Conservative","text":"<p>Begin with <code>patch</code> or <code>minor</code> updates:</p> <pre><code>version: 1\nintegrations:\n  - id: npm\n    policy:\n      update: minor  # Safe default\n</code></pre>"},{"location":"configuration/#2-separate-runtime-from-development-tools","title":"2. Separate Runtime from Development Tools","text":"<p>Use different update policies:</p> <pre><code>integrations:\n  # Conservative for runtime\n  - id: mise\n    policy:\n      update: patch\n\n  # Aggressive for dev tools\n  - id: precommit\n    policy:\n      update: major\n</code></pre>"},{"location":"configuration/#3-test-with-pre-releases-first","title":"3. Test with Pre-releases First","text":"<p>Enable pre-releases in development, disable in production:</p> <pre><code># dev-uptool.yaml\nintegrations:\n  - id: npm\n    policy:\n      allow_prerelease: true\n\n# prod-uptool.yaml\nintegrations:\n  - id: npm\n    policy:\n      allow_prerelease: false\n</code></pre>"},{"location":"configuration/#4-use-explicit-file-patterns-for-monorepos","title":"4. Use Explicit File Patterns for Monorepos","text":"<p>Avoid wildcards that match too broadly:</p> <pre><code># Good: Explicit paths\n- id: npm\n  match:\n    files:\n      - \"apps/api/package.json\"\n      - \"apps/web/package.json\"\n\n# Risky: May match too many\n- id: npm\n  match:\n    files:\n      - \"**/package.json\"  # Might match node_modules!\n</code></pre>"},{"location":"configuration/#5-document-policy-decisions","title":"5. Document Policy Decisions","text":"<p>Add comments explaining choices:</p> <pre><code>integrations:\n  # Only patch updates for Terraform to avoid breaking infrastructure changes\n  - id: terraform\n    policy:\n      update: patch  # Infrastructure stability critical\n\n  # Major updates OK for pre-commit hooks (non-breaking)\n  - id: precommit\n    policy:\n      update: major  # Hooks are isolated, safe to update aggressively\n</code></pre>"},{"location":"configuration/#integration-specific-notes","title":"Integration-Specific Notes","text":""},{"location":"configuration/#npm","title":"npm","text":"<ul> <li>Preserves constraint prefixes (<code>^</code>, <code>~</code>) when <code>pin: false</code></li> <li>Updates all dependency types (dependencies, devDependencies, peerDependencies, optionalDependencies)</li> <li>Respects package-lock.json after updates (run <code>npm install</code> to sync)</li> </ul>"},{"location":"configuration/#helm","title":"Helm","text":"<ul> <li>Updates chart dependencies in <code>dependencies</code> array</li> <li>Requires repository URL to be specified in Chart.yaml</li> <li>Always pins exact versions</li> </ul>"},{"location":"configuration/#terraform","title":"Terraform","text":"<ul> <li>Updates module versions in <code>module</code> blocks</li> <li>Provider updates coming soon</li> <li>Respects HCL syntax and formatting</li> </ul>"},{"location":"configuration/#precommit","title":"precommit","text":"<ul> <li>Uses native <code>pre-commit autoupdate</code> command</li> <li>Updates hook revisions in <code>.pre-commit-config.yaml</code></li> <li>Queries GitHub Releases for latest versions</li> </ul>"},{"location":"configuration/#tflint","title":"tflint","text":"<ul> <li>Updates plugin versions in <code>plugin</code> blocks</li> <li>Queries GitHub Releases for tflint rulesets</li> <li>Preserves HCL formatting</li> </ul>"},{"location":"configuration/#asdf","title":"asdf","text":"<ul> <li>Updates tool versions in <code>.tool-versions</code> file</li> <li>One tool per line format</li> <li>Currently supports detection; version resolution in development</li> </ul>"},{"location":"configuration/#mise","title":"mise","text":"<ul> <li>Updates tool versions in <code>mise.toml</code> or <code>.mise.toml</code></li> <li>Supports both string format (<code>go = \"1.25\"</code>) and map format (<code>go = { version = \"1.25\" }</code>)</li> <li>Preserves TOML structure and comments</li> </ul>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/#configuration-not-loading","title":"Configuration Not Loading","text":"<p>Problem: uptool ignores config file</p> <p>Causes:</p> <ol> <li>File not in repository root</li> <li>Filename typo (must be <code>uptool.yaml</code>, not <code>uptool.yml</code>)</li> <li>Invalid YAML syntax</li> </ol> <p>Solution:</p> <pre><code># Check file exists in root\nls uptool.yaml\n\n# Validate YAML syntax\nyamllint uptool.yaml\n\n# Run with verbose output\nuptool scan -v\n</code></pre>"},{"location":"configuration/#integration-not-running","title":"Integration Not Running","text":"<p>Problem: Integration doesn't run despite configuration</p> <p>Check:</p> <ol> <li>Is <code>enabled: true</code>?</li> <li>Are CLI flags overriding? (<code>--exclude=npm</code>)</li> <li>Are files matched by pattern?</li> </ol> <pre><code># Enable and verify file patterns\n- id: npm\n  enabled: true\n  match:\n    files:\n      - \"package.json\"  # Check this path is correct\n</code></pre>"},{"location":"configuration/#policy-not-applied","title":"Policy Not Applied","text":"<p>Problem: Updates bypass policy limits</p> <p>Remember: Policy only affects automatic updates, not manual selection</p> <pre><code># Policy applies\nuptool update\n\n# Policy BYPASSED (manual override)\nuptool update --only=npm  # Updates regardless of policy.enabled\n</code></pre>"},{"location":"configuration/#see-also","title":"See Also","text":"<ul> <li>Integration Details</li> <li>CLI Reference</li> <li>GitHub Action Configuration</li> <li>Example Configurations</li> </ul>"},{"location":"environments/","title":"GitHub Environments Setup","text":"<p>uptool uses GitHub Environments with approval gates to control releases. This provides an additional layer of security and creates an audit trail for all releases.</p>"},{"location":"environments/#overview","title":"Overview","text":"<p>Two environments are configured in the release workflows:</p> <ol> <li>pre-release - Used for creating pre-release versions (rc/beta/alpha)</li> <li>production - Used for promoting pre-releases to stable versions</li> </ol> <p>Both environments require manual approval from designated reviewers before the workflow can proceed with creating/promoting releases.</p>"},{"location":"environments/#environment-configuration","title":"Environment Configuration","text":""},{"location":"environments/#prerequisites","title":"Prerequisites","text":"<ul> <li>Repository administrator access</li> <li>Appropriate repository permissions (Settings \u2192 Environments)</li> </ul>"},{"location":"environments/#creating-environments","title":"Creating Environments","text":""},{"location":"environments/#1-navigate-to-environments","title":"1. Navigate to Environments","text":"<ol> <li>Go to your repository on GitHub</li> <li>Click Settings (top menu)</li> <li>In the left sidebar, click Environments</li> </ol>"},{"location":"environments/#2-create-pre-release-environment","title":"2. Create Pre-Release Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>pre-release</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve pre-releases</li> <li>Recommended: At least 1 reviewer</li> <li> <p>Prevents accidental pre-release creation</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes (no automatic delay)</li> <li> <p>Or add a delay if desired</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add rule: <code>main</code> branch only</li> <li>This ensures only main branch can create releases</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> <li>GitHub token is automatically provided</li> </ul> <p>Save the environment</p>"},{"location":"environments/#3-create-production-environment","title":"3. Create Production Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>production</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve stable releases</li> <li>Recommended: At least 2 reviewers for production</li> <li> <p>Requires multiple approvals for critical releases</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes for immediate review</li> <li> <p>Or set to 10-30 minutes for time to review changes</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add rule: <code>main</code> branch only</li> <li> <p>Ensures only main branch can promote to stable</p> </li> <li> <p>\u26a0\ufe0f Prevent self-review (recommended)</p> </li> <li>Enable this to require approval from someone other than the workflow trigger</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> </ul> <p>Save the environment</p>"},{"location":"environments/#approval-workflow","title":"Approval Workflow","text":""},{"location":"environments/#pre-release-creation","title":"Pre-Release Creation","text":"<p>When someone triggers the Pre-Release workflow:</p> <ol> <li>Workflow calculates version and updates files</li> <li>Tests run automatically</li> <li>Workflow pauses at the <code>build</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are built and pre-release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Pre-release version (e.g., <code>v0.2.0-rc.1</code>)</li> <li>Commit SHA being released</li> <li>Link to the release page (once approved)</li> <li>Comment field for approval notes</li> </ul>"},{"location":"environments/#stable-release-promotion","title":"Stable Release Promotion","text":"<p>When someone triggers the Promote to Stable Release workflow:</p> <ol> <li>Workflow validates pre-release tag exists</li> <li>Updates version files to stable</li> <li>Tests run automatically</li> <li>Workflow pauses at the <code>promote</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are promoted and stable release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Pre-release being promoted (e.g., <code>v0.2.0-rc.1</code>)</li> <li>Stable version (e.g., <code>v0.2.0</code>)</li> <li>Link to the stable release page (once approved)</li> </ul>"},{"location":"environments/#approving-a-deployment","title":"Approving a Deployment","text":""},{"location":"environments/#as-a-reviewer","title":"As a Reviewer","text":"<p>When you receive a deployment approval request:</p> <ol> <li>Check your email or GitHub notifications</li> <li>Go to Actions tab in the repository</li> <li>Find the workflow run waiting for approval</li> <li>Review the details:</li> <li>Check the version being released</li> <li>Review the commits included</li> <li>Verify tests passed</li> <li> <p>Check CHANGELOG updates</p> </li> <li> <p>Click Review deployments</p> </li> <li>Select the environment (<code>pre-release</code> or <code>production</code>)</li> <li>Add a comment (optional but recommended):</li> </ol> <pre><code>Approved: Version v0.2.0 includes security fixes\n</code></pre> <ol> <li>Click Approve and deploy or Reject</li> </ol>"},{"location":"environments/#review-checklist","title":"Review Checklist","text":"<p>Before approving a pre-release:</p> <ul> <li> Version number is correct</li> <li> All tests passed</li> <li> No breaking changes without documentation</li> <li> CHANGELOG is updated</li> <li> Commit messages follow conventional commits</li> </ul> <p>Before approving a stable release:</p> <ul> <li> Pre-release was tested successfully</li> <li> No critical issues reported</li> <li> Documentation is accurate</li> <li> Version matches what was tested</li> <li> All artifacts are present</li> </ul>"},{"location":"environments/#viewing-deployment-history","title":"Viewing Deployment History","text":"<p>GitHub tracks all deployments in the environment:</p> <ol> <li>Go to Settings \u2192 Environments</li> <li>Click on <code>pre-release</code> or <code>production</code></li> <li>View Deployment history:</li> <li>Who triggered the workflow</li> <li>Who approved/rejected</li> <li>When it was deployed</li> <li>Links to workflow runs</li> <li>Comments from reviewers</li> </ol> <p>This creates a complete audit trail for compliance.</p>"},{"location":"environments/#bypassing-approval-not-recommended","title":"Bypassing Approval (Not Recommended)","text":"<p>Warning: Only repository administrators can bypass environment protection rules.</p> <p>If you need to bypass approval (emergency only):</p> <ol> <li>Go to Settings \u2192 Environments</li> <li>Select the environment</li> <li>Temporarily remove Required reviewers</li> <li>Run the workflow</li> <li>Immediately re-enable required reviewers</li> </ol> <p>Better approach: Add yourself as an approved reviewer if needed.</p>"},{"location":"environments/#troubleshooting","title":"Troubleshooting","text":""},{"location":"environments/#workflow-stuck-on-waiting-for-approval","title":"Workflow Stuck on \"Waiting for approval\"","text":"<p>Problem: Workflow shows waiting for approval but no notification received</p> <p>Solutions:</p> <ol> <li>Check Actions tab for the workflow run</li> <li>Look for the \"Review deployments\" button</li> <li>Check your GitHub notification settings</li> <li>Verify you're listed as a required reviewer</li> </ol>"},{"location":"environments/#cannot-approve-deployment","title":"Cannot Approve Deployment","text":"<p>Problem: \"Approve and deploy\" button is disabled</p> <p>Causes:</p> <ol> <li>You're not listed as a required reviewer</li> <li>Solution: Ask repository admin to add you</li> <li>You triggered the workflow and self-review is prevented</li> <li>Solution: Ask another reviewer to approve</li> <li>Environment doesn't exist</li> <li>Solution: Follow setup instructions above</li> </ol>"},{"location":"environments/#environment-not-found","title":"Environment Not Found","text":"<p>Problem: Workflow fails with \"Environment not found\" error</p> <p>Solution:</p> <pre><code># Verify environment names in workflows match exactly\n# .github/workflows/pre-release.yml\nenvironment:\n  name: pre-release  # Must match GitHub environment name\n\n# .github/workflows/promote-release.yml\nenvironment:\n  name: production   # Must match GitHub environment name\n</code></pre> <p>Check Settings \u2192 Environments to confirm names.</p>"},{"location":"environments/#security-best-practices","title":"Security Best Practices","text":""},{"location":"environments/#required-reviewers","title":"Required Reviewers","text":"<p>Pre-release environment:</p> <ul> <li>Minimum: 1 reviewer</li> <li>Recommended: 1-2 reviewers</li> <li>Should include: Project maintainers</li> </ul> <p>Production environment:</p> <ul> <li>Minimum: 2 reviewers</li> <li>Recommended: 2-3 reviewers</li> <li>Should include: Senior maintainers, security lead</li> </ul>"},{"location":"environments/#branch-protection","title":"Branch Protection","text":"<p>Combine environment protection with branch protection:</p> <ol> <li>Go to Settings \u2192 Branches</li> <li>Add rule for <code>main</code> branch:</li> <li>\u2705 Require pull request reviews (at least 1)</li> <li>\u2705 Require status checks to pass</li> <li>\u2705 Require branches to be up to date</li> <li>\u2705 Include administrators</li> </ol> <p>This ensures:</p> <ul> <li>Code is reviewed before merging</li> <li>Tests pass before merging</li> <li>Releases require additional approval</li> </ul>"},{"location":"environments/#audit-trail","title":"Audit Trail","text":"<p>GitHub automatically logs:</p> <ul> <li>Who triggered the workflow</li> <li>Who approved/rejected</li> <li>When deployment occurred</li> <li>Environment variables used</li> <li>Workflow run details</li> </ul> <p>Export deployment logs regularly for compliance:</p> <ol> <li>Go to Settings \u2192 Environments \u2192 [Environment]</li> <li>View deployment history</li> <li>Document approvals in release notes</li> </ol>"},{"location":"environments/#example-full-release-flow","title":"Example: Full Release Flow","text":""},{"location":"environments/#scenario-releasing-v020","title":"Scenario: Releasing v0.2.0","text":"<p>Step 1: Pre-Release Creation</p> <pre><code># Developer commits features\ngit commit -m \"feat: add Python integration\"\ngit push origin main\n\n# Trigger pre-release workflow\n# Actions \u2192 Pre-Release \u2192 Run workflow \u2192 Type: rc\n</code></pre> <p>Step 2: Pre-Release Approval</p> <ul> <li>Workflow pauses at <code>build</code> job</li> <li>Reviewer checks commits and tests</li> <li>Reviewer approves deployment</li> <li>Pre-release <code>v0.2.0-rc.1</code> is created</li> </ul> <p>Step 3: Testing Phase</p> <ul> <li>Download and test pre-release artifacts</li> <li>Report any issues found</li> <li>Fix issues and create <code>v0.2.0-rc.2</code> if needed</li> <li>Repeat until stable</li> </ul> <p>Step 4: Stable Release Promotion</p> <pre><code># Trigger promote workflow\n# Actions \u2192 Promote to Stable Release \u2192 Run workflow\n# Input: v0.2.0-rc.1\n</code></pre> <p>Step 5: Production Approval</p> <ul> <li>Workflow pauses at <code>promote</code> job</li> <li>Reviewers confirm pre-release testing completed</li> <li>Multiple reviewers approve</li> <li>Stable release <code>v0.2.0</code> is created</li> <li>CHANGELOG is updated</li> </ul> <p>Step 6: Audit Trail</p> <ul> <li>All approvals logged in environment history</li> <li>Release notes include reviewer names</li> <li>Deployment history shows timeline</li> </ul>"},{"location":"environments/#see-also","title":"See Also","text":"<ul> <li>GitHub Environments Documentation</li> <li>Deployment Protection Rules</li> <li>Version Management Guide</li> <li>Contributing Guide</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This page covers various methods to install uptool on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25+ (if installing from source)</li> <li>Git (for version control)</li> <li>Internet connection (for downloading binaries or building from source)</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-go-install-recommended-for-go-users","title":"Method 1: Go Install (Recommended for Go users)","text":"<p>If you have Go 1.25+ installed:</p> <pre><code>go install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre> <p>This will install the latest version of uptool to your <code>$GOPATH/bin</code> directory.</p> <p>Add to PATH</p> <p>Ensure <code>$GOPATH/bin</code> is in your <code>$PATH</code>: <pre><code>export PATH=\"$PATH:$(go env GOPATH)/bin\"\n</code></pre></p>"},{"location":"installation/#method-2-pre-built-binaries","title":"Method 2: Pre-built Binaries","text":"<p>Download pre-compiled binaries from the GitHub Releases page.</p> Linux (AMD64) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-linux-amd64\nchmod +x uptool-linux-amd64\nsudo mv uptool-linux-amd64 /usr/local/bin/uptool\n</code></pre> Linux (ARM64) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-linux-arm64\nchmod +x uptool-linux-arm64\nsudo mv uptool-linux-arm64 /usr/local/bin/uptool\n</code></pre> macOS (Apple Silicon) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-darwin-arm64\nchmod +x uptool-darwin-arm64\nsudo mv uptool-darwin-arm64 /usr/local/bin/uptool\n</code></pre> macOS (Intel) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-darwin-amd64\nchmod +x uptool-darwin-amd64\nsudo mv uptool-darwin-amd64 /usr/local/bin/uptool\n</code></pre> Windows (AMD64) <pre><code># Download from GitHub Releases\nInvoke-WebRequest -Uri https://github.com/santosr2/uptool/releases/latest/download/uptool-windows-amd64.exe -OutFile uptool.exe\n\n# Move to a directory in your PATH\nMove-Item uptool.exe C:\\Windows\\System32\\uptool.exe\n</code></pre>"},{"location":"installation/#method-3-build-from-source","title":"Method 3: Build from Source","text":"<p>Clone the repository and build from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/santosr2/uptool.git\ncd uptool\n\n# Build the binary\nmise run build\n\n# Install to $GOPATH/bin\nmise run install\n\n# Or manually copy the binary\nsudo cp dist/uptool /usr/local/bin/\n</code></pre>"},{"location":"installation/#method-4-using-mise-development-environment","title":"Method 4: Using mise (Development Environment)","text":"<p>If you use mise for managing development tools:</p> <pre><code># Add to your mise.toml\necho 'uptool = \"latest\"' &gt;&gt; mise.toml\n\n# Install\nmise install\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify the installation by checking the version:</p> <pre><code>uptool version\n</code></pre> <p>Expected output:</p> <pre><code>uptool version 0.1.0\n</code></pre>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>After installation, you may want to configure uptool for your project. See the Configuration Guide for details.</p>"},{"location":"installation/#updating-uptool","title":"Updating uptool","text":""},{"location":"installation/#go-install","title":"Go Install","text":"<pre><code>go install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre>"},{"location":"installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release and replace your existing binary.</p>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>cd uptool\ngit pull origin main\nmise run build\nsudo cp dist/uptool /usr/local/bin/\n</code></pre>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":""},{"location":"installation/#go-install_1","title":"Go Install","text":"<pre><code>rm $(which uptool)\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<pre><code>sudo rm /usr/local/bin/uptool\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started with your first project</li> <li>Configuration - Learn about uptool configuration</li> <li>GitHub Action Usage - Use uptool in CI/CD</li> </ul>"},{"location":"manifests/","title":"Manifest Files Reference","text":"<p>uptool is a manifest-first dependency updater. This document catalogs all supported manifest file types across different ecosystems.</p>"},{"location":"manifests/#philosophy-manifest-first","title":"Philosophy: Manifest-First","text":"<p>uptool updates manifest files (source of truth) rather than lockfiles or resolved dependencies:</p> <ol> <li>Manifests declare intent - They specify which versions you want</li> <li>Lockfiles are generated - They record resolved versions</li> <li>Update manifests first - Changes propagate to lockfiles via native tools</li> </ol> <p>This ensures your declared dependencies stay current, not just resolved versions.</p>"},{"location":"manifests/#supported-manifest-types","title":"Supported Manifest Types","text":""},{"location":"manifests/#javascriptnodejs-npm","title":"JavaScript/Node.js (npm)","text":"<p>Integration: <code>npm</code></p> <p>Manifest Files:</p> <ul> <li><code>package.json</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>dependencies</code></li> <li><code>devDependencies</code></li> <li><code>peerDependencies</code></li> <li><code>optionalDependencies</code></li> </ul> <p>Update Strategy:</p> <ul> <li>Custom JSON rewriting</li> <li>Preserves version constraint prefixes (<code>^</code>, <code>~</code>, <code>&gt;=</code>, etc.)</li> <li>Preserves formatting and key order</li> </ul> <p>Example:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",     // Updated to \"^4.19.2\"\n    \"lodash\": \"~4.17.20\"       // Updated to \"~4.17.21\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"&gt;=29.0.0\"         // Updated to \"&gt;=29.7.0\"\n  }\n}\n</code></pre> <p>Registry: npm Registry API (<code>https://registry.npmjs.org</code>)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>package-lock.json</code> directly</li> <li>Run <code>npm install</code> after updating to regenerate lockfile</li> <li>Workspace support: Yes (monorepos with <code>workspaces</code> field)</li> </ul>"},{"location":"manifests/#kuberneteshelm","title":"Kubernetes/Helm","text":"<p>Integration: <code>helm</code></p> <p>Manifest Files:</p> <ul> <li><code>Chart.yaml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>dependencies[].version</code> - Chart dependencies</li> </ul> <p>Update Strategy:</p> <ul> <li>YAML parsing and rewriting</li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>apiVersion: v2\nname: my-app\ndependencies:\n  - name: postgresql\n    version: 12.0.0           # Updated to 18.1.8\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 17.0.0           # Updated to 23.2.12\n    repository: https://charts.bitnami.com/bitnami\n</code></pre> <p>Registry: Helm chart repositories (index.yaml)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>Chart.lock</code></li> <li>Run <code>helm dependency update</code> after to regenerate lockfile</li> <li>Only updates dependency versions, not chart metadata</li> </ul>"},{"location":"manifests/#terraform","title":"Terraform","text":"<p>Integration: <code>terraform</code></p> <p>Manifest Files:</p> <ul> <li><code>*.tf</code> (any Terraform file)</li> <li><code>main.tf</code>, <code>modules.tf</code>, <code>providers.tf</code>, etc.</li> </ul> <p>What Gets Updated:</p> <ul> <li><code>module</code> block <code>version</code> attributes</li> <li>Module source versions in git URLs (future)</li> <li>Provider versions (future)</li> </ul> <p>Update Strategy:</p> <ul> <li>HCL parsing and rewriting via <code>hashicorp/hcl</code></li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"           # Updated to \"5.13.0\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 4.0\"          # Updated to \"~&gt; 5.0\"\n}\n</code></pre> <p>Registry: Terraform Registry API (<code>https://registry.terraform.io</code>)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>.terraform.lock.hcl</code></li> <li>Run <code>terraform init -upgrade</code> after to regenerate lockfile</li> <li>Version constraints are preserved</li> </ul>"},{"location":"manifests/#tflint","title":"tflint","text":"<p>Integration: <code>tflint</code></p> <p>Manifest Files:</p> <ul> <li><code>.tflint.hcl</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>plugin</code> block <code>version</code> attributes</li> </ul> <p>Update Strategy:</p> <ul> <li>HCL parsing and rewriting</li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"          # Updated to \"0.44.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.20.0\"          # Updated to \"0.28.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n</code></pre> <p>Registry: GitHub Releases (for plugins)</p> <p>Notes:</p> <ul> <li>Plugin sources must be valid GitHub repository paths</li> <li>Follows semantic versioning</li> </ul>"},{"location":"manifests/#pre-commit-hooks","title":"Pre-Commit Hooks","text":"<p>Integration: <code>precommit</code></p> <p>Manifest Files:</p> <ul> <li><code>.pre-commit-config.yaml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>repos[].rev</code> - Hook repository revisions</li> </ul> <p>Update Strategy:</p> <ul> <li>Native command: <code>pre-commit autoupdate</code></li> <li>Uses pre-commit's built-in update mechanism</li> <li>This is because <code>pre-commit autoupdate</code> updates the manifest directly</li> </ul> <p>Example:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0               # Updated to v6.0.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n\n  - repo: https://github.com/psf/black\n    rev: 22.10.0              # Updated to 24.10.0\n    hooks:\n      - id: black\n</code></pre> <p>Registry: GitHub Releases (for hook repositories)</p> <p>Notes:</p> <ul> <li>Uses native <code>pre-commit autoupdate</code> command</li> <li>Respects minimum_pre_commit_version</li> <li>Does NOT create <code>.pre-commit-config.yaml.lock</code> (pre-commit doesn't use lockfiles)</li> </ul>"},{"location":"manifests/#asdf-version-manager","title":"asdf Version Manager","text":"<p>Integration: <code>asdf</code></p> <p>Manifest Files:</p> <ul> <li><code>.tool-versions</code></li> </ul> <p>What Gets Updated:</p> <ul> <li>Tool versions (e.g., <code>go 1.23.0</code> \u2192 <code>go 1.25.0</code>)</li> </ul> <p>Update Strategy:</p> <ul> <li>Line-based parsing and rewriting</li> <li>Preserves formatting and comments</li> </ul> <p>Example:</p> <pre><code># Development tools\ngo 1.23.0                     # Updated to 1.25.0\nnodejs 20.10.0                # Updated to 22.12.0\nterraform 1.5.0               # Updated to 1.10.5\n\n# Build tools\npython 3.11.0                 # Updated to 3.13.1\n</code></pre> <p>Registry: GitHub Releases (per tool via asdf plugin mapping)</p> <p>Notes:</p> <ul> <li>Does NOT update installed versions</li> <li>Run <code>asdf install</code> after to install new versions</li> <li>Supports multiple versions per tool (space-separated)</li> </ul>"},{"location":"manifests/#mise-version-manager","title":"mise Version Manager","text":"<p>Integration: <code>mise</code></p> <p>Manifest Files:</p> <ul> <li><code>mise.toml</code></li> <li><code>.mise.toml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>[tools]</code> section tool versions</li> </ul> <p>Update Strategy:</p> <ul> <li>TOML parsing and rewriting</li> <li>Supports both string format and map format</li> <li>Preserves comments and formatting</li> </ul> <p>Example (String Format):</p> <pre><code>[tools]\ngo = \"1.23\"                   # Updated to \"1.25\"\nnode = \"20\"                   # Updated to \"22\"\ngolangci-lint = \"2.6\"         # Updated to \"2.7\"\nterraform = \"1.5.0\"           # Updated to \"1.10.5\"\n</code></pre> <p>Example (Map Format):</p> <pre><code>[tools]\ngo = { version = \"1.23\" }     # Updated to { version = \"1.25\" }\nnode = { version = \"20\", path = \".nvmrc\" }\n</code></pre> <p>Registry: GitHub Releases (per tool)</p> <p>Notes:</p> <ul> <li>Does NOT install new versions automatically</li> <li>Run <code>mise install</code> after to install new versions</li> <li>Supports both mise.toml and .mise.toml (hidden file)</li> </ul>"},{"location":"manifests/#manifest-detection","title":"Manifest Detection","text":"<p>uptool automatically detects manifest files by:</p> <ol> <li>Filename matching: Exact matches like <code>package.json</code>, <code>Chart.yaml</code></li> <li>Pattern matching: Glob patterns like <code>*.tf</code>, <code>mise.toml</code></li> <li>Directory walking: Recursively scans from repository root</li> </ol>"},{"location":"manifests/#detection-order","title":"Detection Order","text":"<p>Each integration defines its own detection logic:</p> <pre><code>// Example: npm integration\nfunc Detect(ctx context.Context, repoRoot string) ([]*Manifest, error) {\n    // Look for package.json files\n    matches, err := filepath.Glob(filepath.Join(repoRoot, \"**/package.json\"))\n    // ...\n}\n</code></pre>"},{"location":"manifests/#ignored-directories","title":"Ignored Directories","text":"<p>By default, uptool skips:</p> <ul> <li><code>.git/</code></li> <li><code>node_modules/</code></li> <li><code>vendor/</code></li> <li><code>.terraform/</code></li> <li><code>dist/</code>, <code>build/</code></li> </ul>"},{"location":"manifests/#manifest-first-principles","title":"Manifest-First Principles","text":""},{"location":"manifests/#do-update-manifests","title":"\u2705 DO: Update Manifests","text":"<pre><code># Good: Updates package.json (manifest)\nuptool update --only=npm\n\n# Then regenerate lockfile\nnpm install\n</code></pre>"},{"location":"manifests/#dont-rely-on-lockfile-only-tools","title":"\u274c DON'T: Rely on Lockfile-Only Tools","text":"<pre><code># Bad: npm update only updates package-lock.json\nnpm update\n\n# package.json still has old versions!\n</code></pre>"},{"location":"manifests/#why-manifest-first","title":"Why Manifest-First?","text":"<ol> <li>Intent over resolution: Manifests declare what you want, lockfiles record what you got</li> <li>Portability: Manifests work across environments, lockfiles don't</li> <li>Auditability: Changes to manifests are explicit in version control</li> <li>Consistency: Everyone gets the same declared versions</li> </ol>"},{"location":"manifests/#native-commands-vs-custom-rewriting","title":"Native Commands vs Custom Rewriting","text":""},{"location":"manifests/#when-native-commands-are-used","title":"When Native Commands Are Used","text":"<p>uptool uses native commands only when they update the manifest:</p> Integration Native Command Reason <code>precommit</code> <code>pre-commit autoupdate</code> Updates <code>.pre-commit-config.yaml</code> directly"},{"location":"manifests/#when-custom-rewriting-is-used","title":"When Custom Rewriting Is Used","text":"<p>All other integrations use custom parsing/rewriting:</p> Integration Reason <code>npm</code> <code>npm update</code> only updates lockfile <code>helm</code> <code>helm dependency update</code> only updates Chart.lock <code>terraform</code> <code>terraform init -upgrade</code> only updates .terraform.lock.hcl <code>tflint</code> No native update command exists <code>asdf</code> <code>.tool-versions</code> is plain text, no native update <code>mise</code> <code>mise.toml</code> is TOML, custom parsing needed"},{"location":"manifests/#configuration","title":"Configuration","text":"<p>You can configure which manifests to process via <code>uptool.yaml</code>:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor              # Only minor/patch updates\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n\n  - id: terraform\n    enabled: false               # Disable Terraform updates\n</code></pre> <p>See configuration.md for complete reference.</p>"},{"location":"manifests/#troubleshooting","title":"Troubleshooting","text":""},{"location":"manifests/#manifest-not-detected","title":"Manifest Not Detected","text":"<p>Problem: uptool doesn't find your manifest file</p> <p>Solutions:</p> <ol> <li>Run <code>uptool scan</code> to see what's detected</li> <li>Check file is in repository root or subdirectory</li> <li>Verify filename matches exactly (e.g., <code>package.json</code> not <code>Package.json</code>)</li> <li>Use <code>--only=&lt;integration&gt;</code> to test specific integration</li> </ol>"},{"location":"manifests/#manifest-not-updated","title":"Manifest Not Updated","text":"<p>Problem: uptool detects manifest but doesn't update it</p> <p>Solutions:</p> <ol> <li>Run <code>uptool plan</code> to see if updates are available</li> <li>Check registry connectivity (npm, Terraform Registry, etc.)</li> <li>Verify version constraints allow updates</li> <li>Check integration policy in <code>uptool.yaml</code></li> </ol>"},{"location":"manifests/#format-preserved","title":"Format Preserved","text":"<p>uptool preserves:</p> <ul> <li>\u2705 Comments (YAML, HCL, TOML)</li> <li>\u2705 Formatting (indentation, spacing)</li> <li>\u2705 Key order (JSON, YAML)</li> <li>\u2705 Version constraint prefixes (<code>^</code>, <code>~</code>, <code>&gt;=</code>)</li> </ul> <p>If formatting is changed unexpectedly, please open an issue.</p>"},{"location":"manifests/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference</li> <li>Integration Details</li> <li>Version Management</li> </ul>"},{"location":"overview/","title":"uptool","text":"<p>Universal, Manifest-First Dependency Updater</p> <p><code>uptool</code> combines the ecosystem breadth of Topgrade, the precision of Dependabot, and the flexibility of Renovate \u2014 but with a manifest-first philosophy that works across ANY project toolchain defined in configuration files.</p> <p>Unlike traditional dependency updaters that focus on lockfiles, uptool updates manifest files directly (package.json, Chart.yaml, .tf files, etc.), preserving your intent while keeping dependencies current.</p>"},{"location":"overview/#why-uptool","title":"Why uptool?","text":"<p>The Problem: Modern projects use dozens of tools across multiple ecosystems:</p> <ul> <li>Language dependencies (npm, pip, go modules)</li> <li>Infrastructure tools (Terraform, Helm)</li> <li>Development tools (pre-commit, tflint)</li> <li>Runtime version managers (asdf with <code>.tool-versions</code>, mise with <code>mise.toml</code>)</li> </ul> <p>Each ecosystem has its own update mechanism. Keeping them all current is tedious and error-prone.</p> <p>The Solution: uptool provides a unified interface to scan, plan, and update dependencies across all your manifest files, whether you're managing JavaScript packages, Kubernetes charts, or Terraform modules.</p>"},{"location":"overview/#manifest-first-philosophy","title":"Manifest-First Philosophy","text":"<p>uptool updates manifests (source of truth), not just lockfiles:</p> <ol> <li>Update manifests first: package.json, Chart.yaml, *.tf files</li> <li>Use native commands when they update manifests: <code>pre-commit autoupdate</code> updates .pre-commit-config.yaml \u2705</li> <li>Don't use commands that only update lockfiles: <code>npm update</code> only touches package-lock.json \u274c</li> <li>Then optionally run native lockfile updates: <code>npm install</code>, <code>terraform init</code>, etc.</li> </ol> <p>This ensures your declared dependencies stay current, not just resolved versions.</p>"},{"location":"overview/#features","title":"Features","text":"<ul> <li>Multi-Ecosystem Support: npm, Helm, Terraform, tflint, pre-commit, asdf, mise \u2014 all in one tool</li> <li>Manifest-First Updates: Updates configuration files directly, preserving formatting and comments</li> <li>Dual Usage Modes: Use as a CLI tool locally or as a GitHub Action in CI/CD</li> <li>Intelligent Version Resolution: Queries upstream registries (npm, Terraform Registry, Helm repos, GitHub Releases)</li> <li>Safe by Default: Dry-run mode, diff generation, validation</li> <li>Concurrent Execution: Parallel scanning and planning with worker pools</li> <li>Flexible Filtering: Run specific integrations with <code>--only</code> or exclude with <code>--exclude</code></li> <li>Automated Versioning: Commit-based semantic versioning with GitHub Actions</li> <li>Clean Integration Interface: Easy to add support for new ecosystems</li> </ul>"},{"location":"overview/#supported-integrations","title":"Supported Integrations","text":"Integration Status Manifest Files Update Strategy Registry npm \u2705 Stable <code>package.json</code> Custom JSON rewriting npm Registry API Helm \u2705 Stable <code>Chart.yaml</code> YAML rewriting Helm chart repositories pre-commit \u2705 Stable <code>.pre-commit-config.yaml</code> Native <code>pre-commit autoupdate</code> GitHub Releases Terraform \u2705 Stable <code>*.tf</code> HCL parsing/rewriting Terraform Registry API tflint \u2705 Stable <code>.tflint.hcl</code> HCL parsing/rewriting GitHub Releases asdf \u2705 Stable <code>.tool-versions</code> Line-based parsing/rewriting GitHub Releases (per tool) mise \u2705 Stable <code>mise.toml</code>, <code>.mise.toml</code> TOML parsing/rewriting GitHub Releases (per tool)"},{"location":"overview/#roadmap","title":"Roadmap","text":"<ul> <li> Python (<code>pyproject.toml</code>, <code>requirements.txt</code>, <code>Pipfile</code>)</li> <li> Go modules (<code>go.mod</code>)</li> <li> Docker (<code>Dockerfile</code>, <code>compose.yml</code>, <code>docker-compose.yml</code>)</li> <li> GitHub Actions (workflow <code>.yml</code> files)</li> <li> Generic version matcher (custom YAML/TOML/JSON/HCL patterns)</li> </ul>"},{"location":"overview/#quick-start","title":"Quick Start","text":""},{"location":"overview/#installation","title":"Installation","text":"<pre><code># Install from source (requires Go 1.25+)\ngo install github.com/santosr2/uptool/cmd/uptool@latest\n\n# Or download pre-built binaries from releases\n# Linux (AMD64)\ncurl -LO https://github.com/santosr2/uptool/releases/download/v0.1.0/uptool-linux-amd64\nchmod +x uptool-linux-amd64\nsudo mv uptool-linux-amd64 /usr/local/bin/uptool\n\n# macOS (Apple Silicon)\ncurl -LO https://github.com/santosr2/uptool/releases/download/v0.1.0/uptool-darwin-arm64\nchmod +x uptool-darwin-arm64\nsudo mv uptool-darwin-arm64 /usr/local/bin/uptool\n\n# Or build from source\ngit clone https://github.com/santosr2/uptool.git\ncd uptool\nmise run build  # Binary will be in dist/uptool\n</code></pre>"},{"location":"overview/#cli-usage","title":"CLI Usage","text":"<pre><code># 1. Scan your repository for updateable dependencies\n$ uptool scan\n\nType                 Path                                   Dependencies\n--------------------------------------------------------------------------------\nnpm                  package.json                           4\nhelm                 charts/app/Chart.yaml                  3\nterraform            infra/terraform                        2\nprecommit            .pre-commit-config.yaml                2\nmise                 mise.toml                              7\n\nTotal: 5 manifests\n\n# 2. Generate an update plan\n$ uptool plan\n\npackage.json (npm):\nPackage          Current         Target          Impact\n--------------------------------------------------------\nexpress          ^4.18.0         ^4.19.2         minor\nlodash           ^4.17.20        ^4.17.21        patch\n\ncharts/app/Chart.yaml (helm):\nPackage          Current         Target          Impact\n--------------------------------------------------------\npostgresql       12.0.0          18.1.8          major\nredis            17.0.0          23.2.12         major\n\nmise.toml (mise):\nTool             Current         Target          Impact\n--------------------------------------------------------\ngo               1.23            1.25            minor\nnode             20              22              major\n\nTotal: 7 updates across 3 manifests\n\n# 3. Preview changes with dry-run\n$ uptool update --dry-run --diff\n\n# 4. Apply updates\n$ uptool update --diff\n\n# 5. Run specific integrations\n$ uptool update --only=npm,helm\n\n# 6. Exclude integrations\n$ uptool update --exclude=terraform\n</code></pre>"},{"location":"overview/#github-action-usage","title":"GitHub Action Usage","text":"<p>Create <code>.github/workflows/dependency-updates.yml</code>:</p> <pre><code>name: Dependency Updates\n\non:\n  schedule:\n    - cron: '0 9 * * 1'  # Every Monday at 9 AM UTC\n  workflow_dispatch:      # Manual trigger\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Update dependencies\n        uses: santosr2/uptool@v0  # Pin to major version (recommended)\n        with:\n          command: update\n          create-pr: 'true'\n          pr-title: 'chore(deps): update dependencies'\n          pr-branch: 'uptool/updates-${{ github.run_number }}'\n          token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"overview/#cli-reference","title":"CLI Reference","text":""},{"location":"overview/#global-flags","title":"Global Flags","text":"<p>All commands support these global flags:</p> <pre><code>-h, --help       Show help for command\n-v, --verbose    Enable verbose debug output\n-q, --quiet      Suppress informational output (errors only)\n--version        Show uptool version\n</code></pre>"},{"location":"overview/#uptool-scan","title":"<code>uptool scan</code>","text":"<p>Discover manifest files and extract current dependency versions.</p> <pre><code>uptool scan                      # Table output\nuptool scan --format=json        # JSON output for scripting\nuptool scan --only=npm,helm      # Only specific integrations\nuptool scan --exclude=terraform  # Exclude integrations\n</code></pre> <p>Flags:</p> <ul> <li><code>--format=FORMAT</code>: Output format (<code>table</code> or <code>json</code>)</li> <li><code>--only=INTEGRATIONS</code>: Comma-separated list of integrations to run</li> <li><code>--exclude=INTEGRATIONS</code>: Comma-separated list to skip</li> </ul> <p>Output: List of manifests with dependency counts</p>"},{"location":"overview/#uptool-plan","title":"<code>uptool plan</code>","text":"<p>Query upstream registries and generate an update plan.</p> <pre><code>uptool plan                      # Show available updates\nuptool plan --format=json        # JSON output\nuptool plan --out=plan.json      # Save to file\nuptool plan --only=npm           # Specific integrations\n</code></pre> <p>Flags:</p> <ul> <li><code>--format=FORMAT</code>: Output format (<code>table</code> or <code>json</code>)</li> <li><code>--out=FILE</code>: Save output to file</li> <li><code>--only=INTEGRATIONS</code>: Comma-separated integrations</li> <li><code>--exclude=INTEGRATIONS</code>: Comma-separated integrations to skip</li> </ul> <p>Output: Update plans showing current \u2192 target versions with impact assessment</p>"},{"location":"overview/#uptool-update","title":"<code>uptool update</code>","text":"<p>Apply updates to manifest files.</p> <pre><code>uptool update --dry-run --diff   # Preview changes without applying\nuptool update --diff             # Apply with diff output\nuptool update --only=npm,helm    # Update specific ecosystems\nuptool update --exclude=precommit\n</code></pre> <p>Flags:</p> <ul> <li><code>--dry-run</code>: Show what would change without modifying files</li> <li><code>--diff</code>: Display unified diffs of changes</li> <li><code>--only=INTEGRATIONS</code>: Comma-separated list of integrations to run</li> <li><code>--exclude=INTEGRATIONS</code>: Comma-separated list to skip</li> <li><code>--format=FORMAT</code>: Output format (<code>table</code> or <code>json</code>)</li> </ul>"},{"location":"overview/#uptool-list","title":"<code>uptool list</code>","text":"<p>List all available integrations and their status.</p> <pre><code>uptool list                          # List all integrations\nuptool list --category package-manager  # Filter by category\nuptool list --experimental            # Include experimental integrations\n</code></pre> <p>Flags:</p> <ul> <li><code>--category=CATEGORY</code>: Filter by category (e.g., <code>package-manager</code>, <code>infrastructure</code>, <code>tooling</code>)</li> <li><code>--experimental</code>: Include experimental integrations</li> </ul> <p>Output: Table showing integration ID, name, description, and status</p>"},{"location":"overview/#github-action","title":"GitHub Action","text":"<p>See ./action-usage.md for comprehensive GitHub Action documentation.</p>"},{"location":"overview/#version-pinning","title":"Version Pinning","text":"<p>uptool supports mutable tags for convenient version pinning:</p> <pre><code># Recommended: Pin to major version (gets latest minor/patch updates)\n- uses: santosr2/uptool@v0\n\n# Pin to minor version (gets latest patch updates only)\n- uses: santosr2/uptool@v0.1\n\n# Pin to exact version (no automatic updates)\n- uses: santosr2/uptool@v0.1.0\n</code></pre> <p>How it works:</p> <ul> <li><code>@v0</code> - Automatically updated to latest <code>v0.x.x</code> release</li> <li><code>@v0.1</code> - Automatically updated to latest <code>v0.1.x</code> patch</li> <li><code>@v0.1.0</code> - Fixed to exact release (never changes)</li> </ul> <p>Pre-release tags (for testing):</p> <ul> <li><code>@v0-rc</code> - Latest release candidate in v0</li> <li><code>@v0.1-rc</code> - Latest release candidate in v0.1</li> <li><code>@v0.1.0-rc.1</code> - Exact pre-release (immutable)</li> </ul>"},{"location":"overview/#inputs","title":"Inputs","text":"Input Description Default Required <code>command</code> Command to run: <code>scan</code>, <code>plan</code>, or <code>update</code> <code>plan</code> No <code>format</code> Output format: <code>table</code> or <code>json</code> <code>table</code> No <code>only</code> Comma-separated integrations to include <code>''</code> No <code>exclude</code> Comma-separated integrations to exclude <code>''</code> No <code>dry-run</code> Show changes without applying (update only) <code>false</code> No <code>diff</code> Show diffs of changes (update only) <code>true</code> No <code>create-pr</code> Create a pull request with updates <code>false</code> No <code>pr-title</code> Title for the pull request <code>chore: update dependencies</code> No <code>pr-branch</code> Branch name for the PR <code>uptool/dependency-updates</code> No <code>token</code> GitHub token for API access and PR creation <code>${{ github.token }}</code> No"},{"location":"overview/#outputs","title":"Outputs","text":"Output Description <code>updates-available</code> Whether updates were found (<code>true</code>/<code>false</code>) <code>manifests-updated</code> Number of manifests with updates applied <code>dependencies-updated</code> Total number of dependencies updated"},{"location":"overview/#required-permissions","title":"Required Permissions","text":"<pre><code>permissions:\n  contents: write          # To push commits\n  pull-requests: write     # To create PRs\n</code></pre>"},{"location":"overview/#integration-details","title":"Integration Details","text":"<p>For detailed integration guides, see ./integrations/.</p> <p>This section provides a quick overview. For comprehensive documentation including troubleshooting, examples, and best practices, refer to the individual integration guides.</p>"},{"location":"overview/#npm","title":"npm","text":"<p>Files: <code>package.json</code> Strategy: Custom JSON rewriting with constraint preservation Registry: npm Registry API (<code>https://registry.npmjs.org</code>)</p> <p>Updates all dependency types:</p> <ul> <li><code>dependencies</code></li> <li><code>devDependencies</code></li> <li><code>peerDependencies</code></li> <li><code>optionalDependencies</code></li> </ul> <p>Preserves version constraint prefixes (<code>^</code>, <code>~</code>, <code>&gt;=</code>, etc.).</p> <p>Example:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",  // Updates to \"^4.19.2\"\n    \"lodash\": \"~4.17.20\"   // Updates to \"~4.17.21\"\n  }\n}\n</code></pre>"},{"location":"overview/#helm","title":"Helm","text":"<p>Files: <code>Chart.yaml</code> Strategy: YAML rewriting Registry: Helm chart repositories (index.yaml)</p> <p>Updates chart dependencies while preserving structure and comments.</p> <p>Example:</p> <pre><code>dependencies:\n  - name: postgresql\n    version: 12.0.0  # Updates to 18.1.8\n    repository: https://charts.bitnami.com/bitnami\n</code></pre>"},{"location":"overview/#pre-commit","title":"pre-commit","text":"<p>Files: <code>.pre-commit-config.yaml</code> Strategy: Native <code>pre-commit autoupdate</code> command Registry: GitHub Releases (for hook repositories)</p> <p>Leverages pre-commit's built-in update mechanism since it updates the manifest directly.</p> <p>Example:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0  # Updates to v6.0.0\n</code></pre>"},{"location":"overview/#terraform","title":"Terraform","text":"<p>Files: <code>*.tf</code> Strategy: HCL parsing and rewriting Registry: Terraform Registry API (<code>https://registry.terraform.io</code>)</p> <p>Updates module versions in <code>module</code> blocks. Provider updates coming soon.</p> <p>Example:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"  # Updates to \"5.8.1\"\n}\n</code></pre>"},{"location":"overview/#tflint","title":"tflint","text":"<p>Files: <code>.tflint.hcl</code> Strategy: HCL parsing and rewriting Registry: GitHub Releases (for plugins)</p> <p>Updates tflint plugin versions.</p> <p>Example:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"  # Updates to \"0.44.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n</code></pre>"},{"location":"overview/#asdf","title":"asdf","text":"<p>Files: <code>.tool-versions</code> Strategy: Line-based parsing and rewriting Registry: GitHub Releases (per tool via asdf plugin mapping)</p> <p>Updates tool versions managed by asdf. Currently supports detection and parsing. Version resolution and updates in active development.</p> <p>Example:</p> <pre><code>go 1.23.0        # Updates to 1.25.0\nnodejs 20.10.0   # Updates to 22.0.0\nterraform 1.5.0  # Updates to 1.10.5\n</code></pre>"},{"location":"overview/#mise","title":"mise","text":"<p>Files: <code>mise.toml</code>, <code>.mise.toml</code> Strategy: TOML parsing and rewriting Registry: GitHub Releases (per tool)</p> <p>Updates tool versions managed by mise (formerly rtx). Supports both string format (<code>go = \"1.23\"</code>) and map format (<code>go = { version = \"1.23\" }</code>).</p> <p>Example:</p> <pre><code>[tools]\ngo = \"1.23\"              # Updates to \"1.25\"\nnode = \"20\"              # Updates to \"22\"\ngolangci-lint = \"2.6\"    # Updates to \"2.7\"\n</code></pre>"},{"location":"overview/#architecture","title":"Architecture","text":""},{"location":"overview/#project-structure","title":"Project Structure","text":"<pre><code>uptool/\n\u251c\u2500\u2500 cmd/uptool/              # CLI entry point\n\u2502   \u251c\u2500\u2500 main.go              # Main entry and integration registration\n\u2502   \u2514\u2500\u2500 cmd/                 # Cobra command handlers\n\u2502       \u251c\u2500\u2500 root.go          # Root command and global flags\n\u2502       \u251c\u2500\u2500 scan.go          # Scan command\n\u2502       \u251c\u2500\u2500 plan.go          # Plan command\n\u2502       \u2514\u2500\u2500 update.go        # Update command\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 version/             # Version embedding\n\u2502   \u2502   \u251c\u2500\u2500 VERSION          # Single source of truth for version\n\u2502   \u2502   \u2514\u2500\u2500 version.go       # Version package\n\u2502   \u251c\u2500\u2500 engine/              # Core orchestration\n\u2502   \u2502   \u251c\u2500\u2500 types.go         # Core types (Manifest, UpdatePlan, etc.)\n\u2502   \u2502   \u2514\u2500\u2500 engine.go        # Scan/Plan/Update orchestration\n\u2502   \u251c\u2500\u2500 registry/            # Registry API clients\n\u2502   \u2502   \u251c\u2500\u2500 npm.go           # npm Registry client\n\u2502   \u2502   \u251c\u2500\u2500 terraform.go     # Terraform Registry client\n\u2502   \u2502   \u251c\u2500\u2500 github.go        # GitHub Releases client\n\u2502   \u2502   \u2514\u2500\u2500 helm.go          # Helm repository client\n\u2502   \u251c\u2500\u2500 datasource/          # Version data sources\n\u2502   \u251c\u2500\u2500 policy/              # Update policy engine\n\u2502   \u251c\u2500\u2500 rewrite/             # Manifest rewriting\n\u2502   \u251c\u2500\u2500 resolve/             # Version resolution\n\u2502   \u2514\u2500\u2500 integrations/        # Ecosystem integrations\n\u2502       \u251c\u2500\u2500 npm/             # npm package.json\n\u2502       \u251c\u2500\u2500 helm/            # Helm Chart.yaml\n\u2502       \u251c\u2500\u2500 precommit/       # pre-commit hooks\n\u2502       \u251c\u2500\u2500 terraform/       # Terraform modules\n\u2502       \u251c\u2500\u2500 tflint/          # tflint plugins\n\u2502       \u251c\u2500\u2500 asdf/            # asdf .tool-versions\n\u2502       \u2514\u2500\u2500 mise/            # mise mise.toml\n\u251c\u2500\u2500 .github/\n\u2502   \u251c\u2500\u2500 workflows/           # GitHub Actions CI/CD\n\u2502   \u2502   \u251c\u2500\u2500 ci.yml           # Continuous Integration\n\u2502   \u2502   \u251c\u2500\u2500 pre-release.yml  # Automated pre-release creation\n\u2502   \u2502   \u2514\u2500\u2500 promote-release.yml  # Stable release promotion\n\u2502   \u2514\u2500\u2500 actions/             # Reusable actions\n\u2502       \u2514\u2500\u2500 setup-mise/      # mise setup action\n\u251c\u2500\u2500 testdata/                # Test fixtures for each integration\n\u251c\u2500\u2500 examples/                # Example configuration files\n\u251c\u2500\u2500 ./                    # Detailed documentation\n\u251c\u2500\u2500 action.yml               # GitHub Action definition\n\u251c\u2500\u2500 mise.toml                # Development tool versions\n\u2514\u2500\u2500 README.md                # This file\n</code></pre>"},{"location":"overview/#integration-interface","title":"Integration Interface","text":"<p>All integrations implement the same interface:</p> <pre><code>type Integration interface {\n    Name() string\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n    Plan(ctx context.Context, manifest *Manifest) (*UpdatePlan, error)\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p>Workflow:</p> <ol> <li>Detect: Scan repository tree for manifest files</li> <li>Plan: Query registries for available updates</li> <li>Apply: Rewrite manifests with new versions</li> <li>Validate: Check syntax and optionally run tool-specific validation</li> </ol>"},{"location":"overview/#concurrent-execution","title":"Concurrent Execution","text":"<p>uptool uses Go's concurrency primitives for performance:</p> <ul> <li>Concurrent scanning across integrations</li> <li>Parallel planning with semaphore-controlled worker pools</li> <li>Atomic file updates with diffs</li> </ul>"},{"location":"overview/#configuration","title":"Configuration","text":"<p>uptool supports optional configuration via a <code>uptool.yaml</code> file in your repository root. This allows you to control which integrations run and customize update policies per integration.</p> <p>See ./configuration.md for complete configuration reference.</p>"},{"location":"overview/#quick-configuration-example","title":"Quick Configuration Example","text":"<p>Create a <code>uptool.yaml</code> file:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false\n      pin: true\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: terraform\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: precommit\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: tflint\n    enabled: false             # Disable specific integrations\n    policy:\n      update: none\n</code></pre>"},{"location":"overview/#behavior","title":"Behavior","text":"<ul> <li>If <code>uptool.yaml</code> exists, only enabled integrations will run</li> <li>If no config file exists, all integrations run by default</li> <li>CLI flags (<code>--only</code>, <code>--exclude</code>) override configuration</li> <li>Invalid configuration will log a warning and use defaults</li> </ul>"},{"location":"overview/#example-configuration-files","title":"Example Configuration Files","text":"<p>The <code>examples/</code> directory contains sample configuration files for various integrations:</p> <ul> <li><code>uptool.yaml</code> - Complete uptool configuration with all integrations</li> <li><code>.tool-versions</code> - asdf runtime version manager configuration</li> <li><code>mise.toml</code> - mise tool version manager configuration (string format)</li> <li><code>.mise.toml</code> - mise configuration (hidden file variant with map format)</li> </ul>"},{"location":"overview/#version-management","title":"Version Management","text":"<p>uptool uses automated semantic versioning based on conventional commits. This eliminates manual version management and ensures consistent, predictable releases.</p>"},{"location":"overview/#how-it-works","title":"How It Works","text":"<ol> <li>Commits determine version bumps:</li> <li><code>feat:</code> commits \u2192 minor version bump (0.1.0 \u2192 0.2.0)</li> <li><code>fix:</code> commits \u2192 patch version bump (0.1.0 \u2192 0.1.1)</li> <li><code>BREAKING CHANGE:</code> \u2192 major version bump (0.1.0 \u2192 1.0.0)</li> <li> <p>Other types (<code>chore:</code>, <code>docs:</code>, etc.) \u2192 no version bump</p> </li> <li> <p>Pre-release workflow (automated with approval):</p> </li> <li>Trigger workflow with pre-release type (rc/beta/alpha)</li> <li>System calculates next version from commits</li> <li>Tests run automatically</li> <li>Approval gate: Designated reviewers must approve</li> <li>Creates pre-release (e.g., <code>v0.2.0-rc.1</code>)</li> <li>Updates VERSION file across codebase</li> <li> <p>Builds and publishes artifacts</p> </li> <li> <p>Stable release workflow (automated with approval):</p> </li> <li>Provide pre-release tag to promote</li> <li>System auto-detects stable version (v0.2.0-rc.1 \u2192 v0.2.0)</li> <li>Tests run automatically</li> <li>Approval gate: Multiple reviewers must approve</li> <li>Updates VERSION file</li> <li>Promotes artifacts</li> <li>Updates CHANGELOG</li> </ol>"},{"location":"overview/#local-development","title":"Local Development","text":"<pre><code># Show current version\nmise run version-show\n\n# Manually bump versions (for local testing only)\nmise run version-bump-patch   # 0.1.0 \u2192 0.1.1\nmise run version-bump-minor   # 0.1.0 \u2192 0.2.0\nmise run version-bump-major   # 0.1.0 \u2192 1.0.0\n</code></pre> <p>See ./versioning.md for complete documentation.</p>"},{"location":"overview/#development","title":"Development","text":""},{"location":"overview/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or later</li> <li>Git</li> <li>mise (for task runner and tool management)</li> <li>VS Code (recommended) - See .vscode/README.md for setup</li> </ul>"},{"location":"overview/#available-tasks","title":"Available Tasks","text":"<p>All development tasks are managed through mise. To see all available tasks:</p> <pre><code>mise tasks ls\n</code></pre> <p>Common tasks:</p> <ul> <li><code>mise run build</code> - Build the binary</li> <li><code>mise run test</code> - Run tests</li> <li><code>mise run check</code> - Run all quality checks</li> <li><code>mise run fmt</code> - Format code</li> <li><code>mise run lint</code> - Run linter</li> <li><code>mise run clean</code> - Clean build artifacts</li> </ul> <p>See <code>mise.toml</code> for the complete list of tasks.</p>"},{"location":"overview/#build-from-source","title":"Build from Source","text":"<pre><code>git clone https://github.com/santosr2/uptool.git\ncd uptool\n\n# Install tools and build (recommended)\nmise install\nmise run build\n\n# Built binary will be in dist/uptool\n</code></pre>"},{"location":"overview/#run-tests","title":"Run Tests","text":"<pre><code># Run all tests\nmise run test\n\n# Run with coverage\nmise run test-coverage\n\n# Run specific package tests\ngo test ./internal/integrations/npm/...\n\n# Run with race detector\ngo test -race ./...\n</code></pre>"},{"location":"overview/#code-quality","title":"Code Quality","text":"<pre><code># Format code\nmise run fmt\n\n# Run linter\nmise run lint\n\n# Run all checks (fmt + vet + complexity + lint + test)\nmise run check\n</code></pre>"},{"location":"overview/#run-locally-on-this-repository","title":"Run Locally on This Repository","text":"<pre><code># Build\nmise run build\n\n# Scan this repository\nmise run run-scan\n\n# Plan updates\nmise run run-plan\n\n# Dry-run\nmise run run-update\n</code></pre>"},{"location":"overview/#adding-a-new-integration","title":"Adding a New Integration","text":"<p>See CONTRIBUTING.md for detailed instructions.</p> <p>Quick overview:</p> <ol> <li>Create <code>internal/integrations/&lt;name&gt;/&lt;name&gt;.go</code></li> <li>Implement the <code>engine.Integration</code> interface</li> <li>Add registry client in <code>internal/registry/&lt;name&gt;.go</code> if needed</li> <li>Register in <code>internal/integrations/registry.go</code></li> <li>Add test fixtures in <code>testdata/&lt;name&gt;/</code></li> <li>Add integration tests in <code>internal/integrations/&lt;name&gt;/&lt;name&gt;_test.go</code></li> <li>Update documentation (README, ./integrations/.md) <li>Add example configuration in <code>examples/</code></li>"},{"location":"overview/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please read CONTRIBUTING.md for:</p> <ul> <li>Development setup</li> <li>Coding standards</li> <li>Testing requirements</li> <li>Trunk-based workflow</li> <li>Conventional commit guidelines</li> <li>Version management process</li> </ul> <p>Quick Start:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Make your changes with tests</li> <li>Run <code>mise run check</code> to validate</li> <li>Commit using conventional commits (<code>git commit -m 'feat: add amazing feature'</code>)</li> <li>Push (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"overview/#security","title":"Security","text":"<p>For security concerns, please see SECURITY.md.</p> <p>tl;dr: Report vulnerabilities via GitHub Security Advisories, not public issues.</p>"},{"location":"overview/#governance","title":"Governance","text":"<p>See GOVERNANCE.md for:</p> <ul> <li>Maintainer responsibilities</li> <li>Decision-making process</li> <li>PR review expectations</li> </ul> <p>Workflow: Trunk-based development (no Git Flow). All changes merge directly to <code>main</code> after review.</p>"},{"location":"overview/#license","title":"License","text":"<p>This project is licensed under the MIT License. See LICENSE for details.</p>"},{"location":"overview/#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Inspired by Topgrade, Dependabot, and Renovate</li> <li>Built with \u2764\ufe0f in Go</li> <li>Uses excellent libraries:</li> <li>semver for version comparison</li> <li>yaml.v3 for YAML parsing</li> <li>HCL for Terraform/tflint parsing</li> <li>Cobra for CLI interface</li> <li>go-toml for TOML parsing</li> </ul>"},{"location":"overview/#support-community","title":"Support &amp; Community","text":""},{"location":"overview/#documentation","title":"Documentation","text":"<ul> <li>Documentation Portal - Complete documentation index</li> <li>Configuration Guide - Complete <code>uptool.yaml</code> reference</li> <li>Manifest Files Reference - All supported manifest types</li> <li>Integration Guides - Detailed guides for each integration</li> <li>Examples - Example configurations for all integrations</li> <li>Plugin Development - Create external plugins</li> <li>Version Management - Automated versioning with conventional commits</li> <li>GitHub Environments - Approval gates for releases</li> <li>GitHub Action Usage - Using uptool in CI/CD</li> </ul>"},{"location":"overview/#community","title":"Community","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Changelog: CHANGELOG.md</li> <li>Contributing: CONTRIBUTING.md</li> <li>Security: SECURITY.md</li> </ul> <p>Questions? Open a discussion or reach out to the maintainers.</p>"},{"location":"patch-release-workflow/","title":"Patch Release Workflow Guide","text":"<p>This guide explains how to manage security patches and bug fixes for previous minor versions of uptool, in accordance with our Security Policy.</p>"},{"location":"patch-release-workflow/#overview","title":"Overview","text":"<p>uptool supports multiple minor versions simultaneously:</p> <ul> <li>Latest minor version (e.g., 0.2.x): Full support (features, bug fixes, security patches)</li> <li>Previous minor version (e.g., 0.1.x): Security patches only for 6 months after next minor release</li> <li>Older versions: No support</li> </ul>"},{"location":"patch-release-workflow/#workflow-files","title":"Workflow Files","text":""},{"location":"patch-release-workflow/#1-create-release-branch-create-release-branchyml","title":"1. Create Release Branch (<code>create-release-branch.yml</code>)","text":"<p>Purpose: Create a long-lived release branch for a minor version to enable backporting.</p> <p>When to use: After releasing a new minor version (e.g., after v0.2.0 is released, create <code>release-0.1</code> for backports).</p> <p>How to use:</p> <ol> <li>Go to Actions \u2192 Create Release Branch</li> <li>Click Run workflow</li> <li>Enter the minor version (e.g., <code>0.1</code>)</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Creates a <code>release-X.Y</code> branch from the latest <code>vX.Y.Z</code> tag</li> <li>Adds branch protection rules</li> <li>Creates a README explaining the branch purpose</li> </ul> <p>Example:</p> <pre><code>Input: 0.1\nResult: Creates branch `release-0.1` from tag `v0.1.0`\n</code></pre>"},{"location":"patch-release-workflow/#2-patch-release-patch-releaseyml","title":"2. Patch Release (<code>patch-release.yml</code>)","text":"<p>Purpose: Create a patch release (e.g., v0.1.1) from a release branch with security or bug fixes.</p> <p>When to use: After cherry-picking fixes to a release branch.</p> <p>How to use:</p> <ol> <li>Cherry-pick fixes to the release branch:</li> </ol> <pre><code>git checkout release-0.1\ngit cherry-pick &lt;commit-sha&gt;\ngit push origin release-0.1\n</code></pre> <ol> <li>Go to Actions \u2192 Patch Release</li> <li>Click Run workflow</li> <li>Configure:</li> <li>Release branch: <code>release-0.1</code></li> <li>Patch type: <code>security</code> or <code>bugfix</code></li> <li>Changelog notes (optional): Additional context</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Calculates the next patch version (e.g., 0.1.0 \u2192 0.1.1)</li> <li>Updates version files</li> <li>Builds and signs binaries for all platforms</li> <li>Generates SBOM</li> <li>Creates a GitHub release</li> <li>Updates the mutable minor tag (e.g., <code>v0.1</code> \u2192 <code>v0.1.1</code>)</li> </ul> <p>Example:</p> <pre><code>Branch: release-0.1\nCurrent: v0.1.0\nNext: v0.1.1 (security patch)\n</code></pre>"},{"location":"patch-release-workflow/#3-coordinate-security-patches-security-patchyml","title":"3. Coordinate Security Patches (<code>security-patch.yml</code>)","text":"<p>Purpose: Automate cherry-picking security fixes to multiple release branches.</p> <p>When to use: When a security vulnerability affects multiple versions.</p> <p>How to use:</p> <ol> <li> <p>Fix the vulnerability on <code>main</code> and note the commit SHA(s)</p> </li> <li> <p>Go to Actions \u2192 Coordinate Security Patches</p> </li> <li>Click Run workflow</li> <li>Configure:</li> <li>Advisory ID: <code>GHSA-xxxx-xxxx-xxxx</code> (if applicable)</li> <li>Affected versions: <code>0.1.x,0.2.x</code> (comma-separated)</li> <li>Severity: <code>critical</code>, <code>high</code>, <code>medium</code>, or <code>low</code></li> <li>Description: Brief explanation of the vulnerability</li> <li>Fix commits: <code>abc123,def456</code> (commit SHAs from main)</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Identifies which release branches need patches</li> <li>Creates patch branches for each affected version</li> <li>Cherry-picks the fix commits</li> <li>Creates PRs for each release branch</li> <li>If cherry-pick fails, creates an issue for manual backporting</li> </ul> <p>Example:</p> <pre><code>Affected: 0.1.x, 0.2.x\nCommits: abc123, def456\nResult:\n  - PR to release-0.1\n  - PR to release-0.2\n</code></pre>"},{"location":"patch-release-workflow/#complete-workflow-examples","title":"Complete Workflow Examples","text":""},{"location":"patch-release-workflow/#example-1-security-vulnerability-in-multiple-versions","title":"Example 1: Security Vulnerability in Multiple Versions","text":"<p>Scenario: Critical security vulnerability affects 0.1.x and 0.2.x</p> <p>Steps:</p> <ol> <li>Fix on main:</li> </ol> <pre><code>git checkout main\n# Fix the vulnerability\ngit commit -m \"fix(security): resolve CVE-2024-XXXXX\"\ngit push origin main\n# Note the commit SHA: abc123\n</code></pre> <ol> <li>Ensure release branches exist:</li> <li>Check if <code>release-0.1</code> and <code>release-0.2</code> exist</li> <li> <p>If not, use Create Release Branch workflow</p> </li> <li> <p>Coordinate patches:</p> </li> <li>Run Coordinate Security Patches workflow</li> <li>Affected versions: <code>0.1.x,0.2.x</code></li> <li>Fix commits: <code>abc123</code></li> <li> <p>Severity: <code>critical</code></p> </li> <li> <p>Review and merge PRs:</p> </li> <li>Review the automated PRs created for each branch</li> <li>Ensure tests pass</li> <li> <p>Merge PRs</p> </li> <li> <p>Create patch releases:</p> </li> <li>Run Patch Release workflow for <code>release-0.1</code></li> <li>Run Patch Release workflow for <code>release-0.2</code></li> <li> <p>Patch type: <code>security</code></p> </li> <li> <p>Announce:</p> </li> <li>Publish security advisory</li> <li>Notify users to upgrade</li> <li>Update affected versions in advisory</li> </ol>"},{"location":"patch-release-workflow/#example-2-manual-bug-fix-to-previous-version","title":"Example 2: Manual Bug Fix to Previous Version","text":"<p>Scenario: User reports critical bug in 0.1.x, but main is on 0.2.x</p> <p>Steps:</p> <ol> <li>Reproduce and fix:</li> </ol> <pre><code>git checkout main\n# Fix the bug\ngit commit -m \"fix: critical bug in dependency parsing\"\ngit push origin main\n# Note the commit SHA: def456\n</code></pre> <ol> <li>Cherry-pick to release branch:</li> </ol> <pre><code>git checkout release-0.1\ngit cherry-pick def456\ngit push origin release-0.1\n</code></pre> <ol> <li>Create patch release:</li> <li>Run Patch Release workflow</li> <li>Release branch: <code>release-0.1</code></li> <li>Patch type: <code>bugfix</code></li> </ol>"},{"location":"patch-release-workflow/#example-3-creating-a-new-release-branch","title":"Example 3: Creating a New Release Branch","text":"<p>Scenario: Just released v0.2.0, need to support 0.1.x for 6 months</p> <p>\u2728 Automated Approach (Recommended):</p> <p>When you run the Promote to Stable Release workflow for v0.2.0, it will automatically create the <code>release-0.1</code> branch. No manual action needed!</p> <p>Manual Approach (if needed):</p> <ol> <li>Verify latest stable tag:</li> </ol> <pre><code>git tag -l \"v0.1.*\" | grep -v '\\-' | sort -V | tail -n 1\n# Output: v0.1.0\n</code></pre> <ol> <li>Create release branch:</li> <li>Run Create Release Branch workflow</li> <li> <p>Version: <code>0.1</code></p> </li> <li> <p>Verify branch:</p> </li> </ol> <pre><code>git fetch origin\ngit checkout release-0.1\ncat .github/RELEASE_BRANCH_README.md\n</code></pre> <ol> <li>Set calendar reminder:</li> <li>6 months from v0.2.0 release date</li> <li>Archive <code>release-0.1</code> when support ends</li> </ol>"},{"location":"patch-release-workflow/#release-branch-management","title":"Release Branch Management","text":""},{"location":"patch-release-workflow/#branch-naming","title":"Branch Naming","text":"<ul> <li>Format: <code>release-X.Y</code></li> <li>Examples: <code>release-0.1</code>, <code>release-1.0</code>, <code>release-1.2</code></li> </ul>"},{"location":"patch-release-workflow/#branch-protection","title":"Branch Protection","text":"<p>Release branches have the same protection as <code>main</code>:</p> <ul> <li>Required status checks</li> <li>Required PR reviews</li> <li>No force pushes</li> <li>No deletions</li> </ul>"},{"location":"patch-release-workflow/#support-timeline","title":"Support Timeline","text":"<pre><code>Timeline: Support for release-0.1\n\n0.1.0 released \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 0.2.0 released \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 +6 months \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\n     \u2502                            \u2502                            \u2502\n     \u251c\u2500 Full support              \u251c\u2500 Security patches only     \u251c\u2500 Archive\n     \u2502                            \u2502                            \u2502\nrelease-0.1 created               \u2502                       End of support\n</code></pre>"},{"location":"patch-release-workflow/#end-of-support","title":"End of Support","text":"<p>When a release branch reaches end of support:</p> <ol> <li>Announce end of support (1 month before)</li> <li>Final patch release (if needed)</li> <li>Archive the branch:</li> </ol> <pre><code>git tag archive/release-0.1 release-0.1\ngit push origin archive/release-0.1\n</code></pre> <ol> <li>Update documentation</li> <li>Close remaining PRs/issues for that branch</li> </ol>"},{"location":"patch-release-workflow/#versioning","title":"Versioning","text":""},{"location":"patch-release-workflow/#version-tags","title":"Version Tags","text":"<ul> <li>Immutable tags: <code>v0.1.0</code>, <code>v0.1.1</code>, <code>v0.2.0</code> (never change)</li> <li>Mutable tags: <code>v0.1</code>, <code>v0.2</code>, <code>v0</code> (updated with each patch)</li> </ul>"},{"location":"patch-release-workflow/#tag-updates","title":"Tag Updates","text":"<p>When creating a patch release (e.g., v0.1.1):</p> <ol> <li>Create immutable tag: <code>v0.1.1</code></li> <li>Update mutable minor tag: <code>v0.1</code> \u2192 <code>v0.1.1</code></li> <li>Do NOT update major tag: <code>v0</code> stays at latest minor (e.g., <code>v0.2.0</code>)</li> </ol>"},{"location":"patch-release-workflow/#github-action-pinning","title":"GitHub Action Pinning","text":"<p>Users can pin to different levels:</p> <pre><code># Exact version (most secure, no automatic updates)\n- uses: santosr2/uptool@v0.1.0\n\n# Minor version (gets security patches automatically)\n- uses: santosr2/uptool@v0.1\n\n# Major version (gets all updates in v0.x)\n- uses: santosr2/uptool@v0\n</code></pre>"},{"location":"patch-release-workflow/#troubleshooting","title":"Troubleshooting","text":""},{"location":"patch-release-workflow/#cherry-pick-conflicts","title":"Cherry-pick Conflicts","text":"<p>If Coordinate Security Patches fails with conflicts:</p> <ol> <li>Check the created issue for manual backport instructions</li> <li>Manually resolve conflicts:</li> </ol> <pre><code>git checkout release-0.1\ngit cherry-pick abc123\n# Resolve conflicts\ngit add .\ngit cherry-pick --continue\ngit push origin release-0.1\n</code></pre> <ol> <li>Run Patch Release workflow</li> </ol>"},{"location":"patch-release-workflow/#missing-release-branch","title":"Missing Release Branch","text":"<p>If you try to patch a version without a release branch:</p> <ol> <li>Run Create Release Branch first</li> <li>Then proceed with patching</li> </ol>"},{"location":"patch-release-workflow/#failed-patch-release","title":"Failed Patch Release","text":"<p>If Patch Release workflow fails:</p> <ol> <li>Check workflow logs for errors</li> <li>Common issues:</li> <li>Version files not updated correctly</li> <li>Build failures</li> <li>Test failures</li> <li>Fix issues on the release branch</li> <li>Re-run workflow</li> </ol>"},{"location":"patch-release-workflow/#wrong-version-number","title":"Wrong Version Number","text":"<p>If the patch version is wrong:</p> <ol> <li>Delete the tag (if created):</li> </ol> <pre><code>git tag -d v0.1.1\ngit push origin :refs/tags/v0.1.1\n</code></pre> <ol> <li>Fix version files manually</li> <li>Re-run workflow</li> </ol>"},{"location":"patch-release-workflow/#best-practices","title":"Best Practices","text":""},{"location":"patch-release-workflow/#1-security-patches","title":"1. Security Patches","text":"<ul> <li>\u2705 Do: Use automated workflows for consistency</li> <li>\u2705 Do: Test patches thoroughly before release</li> <li>\u2705 Do: Announce security updates prominently</li> <li>\u274c Don't: Delay security patches</li> <li>\u274c Don't: Mix features with security fixes</li> </ul>"},{"location":"patch-release-workflow/#2-bug-fixes","title":"2. Bug Fixes","text":"<ul> <li>\u2705 Do: Only backport critical bugs</li> <li>\u2705 Do: Document why the backport is necessary</li> <li>\u274c Don't: Backport non-critical bugs</li> <li>\u274c Don't: Introduce new features in patches</li> </ul>"},{"location":"patch-release-workflow/#3-communication","title":"3. Communication","text":"<ul> <li>\u2705 Do: Update security advisories with fixed versions</li> <li>\u2705 Do: Notify users via GitHub releases</li> <li>\u2705 Do: Document in CHANGELOG.md</li> <li>\u274c Don't: Silently release security fixes</li> </ul>"},{"location":"patch-release-workflow/#4-version-management","title":"4. Version Management","text":"<ul> <li>\u2705 Do: Follow semantic versioning strictly</li> <li>\u2705 Do: Keep mutable tags updated</li> <li>\u2705 Do: Document support timelines</li> <li>\u274c Don't: Change immutable tags</li> <li>\u274c Don't: Extend support without announcement</li> </ul>"},{"location":"patch-release-workflow/#faq","title":"FAQ","text":""},{"location":"patch-release-workflow/#when-should-i-create-a-release-branch","title":"When should I create a release branch?","text":"<p>After releasing a new minor version. For example:</p> <ul> <li>Release v0.2.0 \u2192 Create <code>release-0.1</code> to support 0.1.x</li> </ul>"},{"location":"patch-release-workflow/#how-long-are-release-branches-supported","title":"How long are release branches supported?","text":"<p>Security patches only, for 6 months after the next minor release.</p>"},{"location":"patch-release-workflow/#can-i-backport-features","title":"Can I backport features?","text":"<p>No. Only security fixes and critical bug fixes. Features go to <code>main</code> only.</p>"},{"location":"patch-release-workflow/#what-if-a-security-fix-doesnt-apply-cleanly","title":"What if a security fix doesn't apply cleanly?","text":"<p>The Coordinate Security Patches workflow will create an issue with manual instructions.</p>"},{"location":"patch-release-workflow/#how-do-i-know-which-versions-need-patches","title":"How do I know which versions need patches?","text":"<p>Check the security advisory for affected versions. Example:</p> <ul> <li>Affected: &lt; 0.2.3</li> <li>Needs patches: 0.1.x (via release-0.1)</li> </ul>"},{"location":"patch-release-workflow/#should-i-update-mutable-tags-for-patches","title":"Should I update mutable tags for patches?","text":"<p>The workflow automatically updates the minor tag (e.g., <code>v0.1</code>). You don't need to manually update it.</p>"},{"location":"patch-release-workflow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Policy - Support timelines and reporting</li> <li>Contributing Guide - Development workflow</li> <li>Versioning Guide - Semantic versioning details</li> <li>Release Process - Main branch releases</li> </ul>"},{"location":"patch-release-workflow/#support","title":"Support","text":"<p>For questions about patch releases:</p> <ul> <li>GitHub Discussions: https://github.com/santosr2/uptool/discussions</li> <li>Security Issues: https://github.com/santosr2/uptool/security/advisories</li> </ul> <p>Last Updated: 2025-01-16 Maintained By: uptool maintainers</p>"},{"location":"plugin-development/","title":"Plugin Development Guide","text":"<p>This guide explains how to create external plugins for uptool, extending it with custom integrations without modifying the core codebase.</p>"},{"location":"plugin-development/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Built-in vs Plugin Integrations</li> <li>Plugin Architecture</li> <li>Creating a Plugin</li> <li>Plugin Discovery</li> <li>Building and Installing</li> <li>Testing Plugins</li> <li>Best Practices</li> <li>Example Plugins</li> </ul>"},{"location":"plugin-development/#overview","title":"Overview","text":"<p>uptool supports two types of integrations:</p> <ol> <li>Built-in Integrations - Compiled into the binary (npm, Helm, Terraform, etc.)</li> <li>Plugin Integrations - External shared libraries loaded at runtime</li> </ol> <p>Plugins allow you to:</p> <ul> <li>Add custom integrations without forking uptool</li> <li>Develop proprietary integrations</li> <li>Experiment with new ecosystems</li> <li>Share integrations with the community</li> </ul>"},{"location":"plugin-development/#built-in-vs-plugin-integrations","title":"Built-in vs Plugin Integrations","text":"Aspect Built-in Plugin Compile Time Compiled with uptool Compiled separately Distribution Bundled in binary Separate <code>.so</code> file Loading Always available Loaded at runtime Performance Slightly faster Minimal overhead Use Case Core integrations Custom/experimental Maintenance Part of uptool releases Independent versioning <p>When to use Built-in:</p> <ul> <li>Widely-used ecosystems (npm, Terraform, etc.)</li> <li>Part of uptool's core value proposition</li> <li>Ready for mainline support</li> </ul> <p>When to use Plugin:</p> <ul> <li>Company-specific tools</li> <li>Experimental integrations</li> <li>Niche ecosystems</li> <li>Proprietary manifest formats</li> </ul>"},{"location":"plugin-development/#plugin-architecture","title":"Plugin Architecture","text":""},{"location":"plugin-development/#plugin-interface","title":"Plugin Interface","text":"<p>Plugins must implement the standard <code>engine.Integration</code> interface:</p> <pre><code>type Integration interface {\n    Name() string\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n    Plan(ctx context.Context, manifest *Manifest) (*UpdatePlan, error)\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre>"},{"location":"plugin-development/#registration-pattern","title":"Registration Pattern","text":"<p>Plugins must export a <code>RegisterWith</code> function that uptool calls to register integrations:</p> <pre><code>// RegisterWith is called by uptool to register this plugin's integrations.\n// The provided register function should be called with the integration name and constructor.\nfunc RegisterWith(register func(name string, constructor func() engine.Integration)) {\n    register(\"yourintegration\", New)\n}\n</code></pre>"},{"location":"plugin-development/#plugin-discovery","title":"Plugin Discovery","text":"<p>uptool searches for plugins in these locations (in order):</p> <ol> <li><code>./plugins/</code> - Current directory</li> <li><code>~/.uptool/plugins/</code> - User's home directory</li> <li><code>/usr/local/lib/uptool/plugins/</code> - System-wide (Unix-like systems)</li> <li><code>$UPTOOL_PLUGIN_DIR</code> - Custom directory via environment variable</li> </ol>"},{"location":"plugin-development/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugin-development/#step-1-project-structure","title":"Step 1: Project Structure","text":"<p>Create a new Go module for your plugin:</p> <pre><code>mkdir uptool-plugin-example\ncd uptool-plugin-example\ngo mod init github.com/yourname/uptool-plugin-example\n</code></pre> <p>Project structure:</p> <pre><code>uptool-plugin-example/\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 go.sum\n\u251c\u2500\u2500 main.go              # Plugin entry point with RegisterWith\n\u251c\u2500\u2500 integration.go       # Integration implementation\n\u251c\u2500\u2500 registry.go          # Optional: Custom registry client\n\u251c\u2500\u2500 testdata/           # Test fixtures\n\u2502   \u2514\u2500\u2500 example.yaml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"plugin-development/#step-2-import-dependencies","title":"Step 2: Import Dependencies","text":"<pre><code>// go.mod\nmodule github.com/yourname/uptool-plugin-example\n\ngo 1.25\n\nrequire (\n    github.com/santosr2/uptool v0.1.0\n    // Add other dependencies as needed\n)\n</code></pre>"},{"location":"plugin-development/#step-3-implement-integration","title":"Step 3: Implement Integration","text":"<pre><code>// integration.go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n\n    \"github.com/santosr2/uptool/internal/engine\"\n)\n\nconst integrationName = \"example\"\n\n// Integration implements the engine.Integration interface for example manifests.\ntype Integration struct {\n    // Add any clients, configuration, etc.\n}\n\n// New creates a new integration instance.\nfunc New() engine.Integration {\n    return &amp;Integration{}\n}\n\n// Name returns the integration identifier.\nfunc (i *Integration) Name() string {\n    return integrationName\n}\n\n// Detect finds manifest files in the repository.\nfunc (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error) {\n    var manifests []*engine.Manifest\n\n    // Walk the repository looking for manifest files\n    err := filepath.Walk(repoRoot, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Skip directories and non-manifest files\n        if info.IsDir() || filepath.Base(path) != \"example.yaml\" {\n            return nil\n        }\n\n        // Read and parse manifest\n        content, err := os.ReadFile(path)\n        if err != nil {\n            return fmt.Errorf(\"reading %s: %w\", path, err)\n        }\n\n        // Parse dependencies from manifest\n        deps, err := i.parseDependencies(content)\n        if err != nil {\n            return fmt.Errorf(\"parsing %s: %w\", path, err)\n        }\n\n        // Create manifest\n        manifests = append(manifests, &amp;engine.Manifest{\n            Path:         path,\n            Integration:  integrationName,\n            Dependencies: deps,\n        })\n\n        return nil\n    })\n\n    if err != nil {\n        return nil, err\n    }\n\n    return manifests, nil\n}\n\n// Plan generates an update plan for a manifest.\nfunc (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error) {\n    var updates []*engine.DependencyUpdate\n\n    for _, dep := range manifest.Dependencies {\n        // Query registry for latest version\n        latestVersion, err := i.getLatestVersion(ctx, dep.Name)\n        if err != nil {\n            return nil, fmt.Errorf(\"querying %s: %w\", dep.Name, err)\n        }\n\n        // Check if update is needed\n        if dep.CurrentVersion != latestVersion {\n            updates = append(updates, &amp;engine.DependencyUpdate{\n                Name:           dep.Name,\n                CurrentVersion: dep.CurrentVersion,\n                TargetVersion:  latestVersion,\n                Impact:         engine.ImpactMinor, // Calculate impact\n            })\n        }\n    }\n\n    return &amp;engine.UpdatePlan{\n        Manifest: manifest,\n        Updates:  updates,\n    }, nil\n}\n\n// Apply executes the update plan.\nfunc (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error) {\n    // Read manifest file\n    content, err := os.ReadFile(plan.Manifest.Path)\n    if err != nil {\n        return nil, fmt.Errorf(\"reading manifest: %w\", err)\n    }\n\n    // Update versions in content\n    updated := string(content)\n    for _, update := range plan.Updates {\n        // Replace old version with new version\n        // Implementation depends on manifest format\n        updated = i.replaceVersion(updated, update)\n    }\n\n    // Write updated manifest\n    if err := os.WriteFile(plan.Manifest.Path, []byte(updated), 0644); err != nil {\n        return nil, fmt.Errorf(\"writing manifest: %w\", err)\n    }\n\n    return &amp;engine.ApplyResult{\n        Success: true,\n        Applied: len(plan.Updates),\n    }, nil\n}\n\n// Validate checks if a manifest is valid.\nfunc (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error {\n    // Optional: Validate manifest structure\n    return nil\n}\n\n// Helper methods\n\nfunc (i *Integration) parseDependencies(content []byte) ([]*engine.Dependency, error) {\n    // Parse manifest format and extract dependencies\n    // Implementation depends on your manifest format\n    return nil, nil\n}\n\nfunc (i *Integration) getLatestVersion(ctx context.Context, packageName string) (string, error) {\n    // Query your registry for latest version\n    // Implementation depends on your registry\n    return \"\", nil\n}\n\nfunc (i *Integration) replaceVersion(content string, update *engine.DependencyUpdate) string {\n    // Replace version in manifest\n    // Implementation depends on your manifest format\n    return content\n}\n</code></pre>"},{"location":"plugin-development/#step-4-add-plugin-entry-point","title":"Step 4: Add Plugin Entry Point","text":"<pre><code>// main.go\npackage main\n\nimport \"github.com/santosr2/uptool/internal/engine\"\n\n// RegisterWith is called by uptool to register this plugin's integrations.\n// This function MUST be exported and have this exact signature.\nfunc RegisterWith(register func(name string, constructor func() engine.Integration)) {\n    register(\"example\", New)\n}\n\n// main is not used when building as a plugin, but helps during development/testing\nfunc main() {\n    // Optional: Add standalone testing code here\n}\n</code></pre>"},{"location":"plugin-development/#step-5-build-plugin","title":"Step 5: Build Plugin","text":"<p>Build as a Go plugin (shared library):</p> <pre><code># Build plugin\ngo build -buildmode=plugin -o example.so .\n\n# Verify it's a valid shared library\nfile example.so\n# Output: example.so: Mach-O 64-bit dynamically linked shared library arm64\n</code></pre>"},{"location":"plugin-development/#plugin-discovery_1","title":"Plugin Discovery","text":""},{"location":"plugin-development/#installation-locations","title":"Installation Locations","text":""},{"location":"plugin-development/#local-development","title":"Local Development","text":"<pre><code># Project-specific plugins\nmkdir -p plugins\nmv example.so plugins/\n</code></pre>"},{"location":"plugin-development/#user-level","title":"User-Level","text":"<pre><code># User plugins (recommended for personal use)\nmkdir -p ~/.uptool/plugins\nmv example.so ~/.uptool/plugins/\n</code></pre>"},{"location":"plugin-development/#system-wide","title":"System-Wide","text":"<pre><code># System-wide plugins (requires sudo)\nsudo mkdir -p /usr/local/lib/uptool/plugins\nsudo mv example.so /usr/local/lib/uptool/plugins/\n</code></pre>"},{"location":"plugin-development/#custom-location","title":"Custom Location","text":"<pre><code># Use environment variable\nexport UPTOOL_PLUGIN_DIR=/opt/uptool/plugins\nmkdir -p $UPTOOL_PLUGIN_DIR\nmv example.so $UPTOOL_PLUGIN_DIR/\n</code></pre>"},{"location":"plugin-development/#verifying-plugin-loading","title":"Verifying Plugin Loading","text":"<pre><code># List all integrations (includes plugins)\nuptool list\n\n# Run with verbose logging to see plugin loading\nuptool scan -v\n</code></pre>"},{"location":"plugin-development/#building-and-installing","title":"Building and Installing","text":""},{"location":"plugin-development/#development-workflow","title":"Development Workflow","text":"<pre><code># 1. Build plugin\ngo build -buildmode=plugin -o example.so .\n\n# 2. Install to local plugins directory\nmkdir -p plugins\ncp example.so plugins/\n\n# 3. Test with uptool\nuptool scan --only=example -v\n\n# 4. Iterate on changes\n# Edit code...\ngo build -buildmode=plugin -o example.so .\ncp example.so plugins/\nuptool scan --only=example\n</code></pre>"},{"location":"plugin-development/#build-script","title":"Build Script","text":"<p>Create <code>build.sh</code>:</p> <pre><code>#!/bin/bash\nset -e\n\nPLUGIN_NAME=\"example\"\nVERSION=\"${VERSION:-dev}\"\n\necho \"Building ${PLUGIN_NAME} plugin...\"\n\n# Build plugin\ngo build -buildmode=plugin -o \"${PLUGIN_NAME}.so\" .\n\necho \"\u2713 Built ${PLUGIN_NAME}.so\"\n\n# Optionally install to user directory\nif [ \"$1\" == \"install\" ]; then\n    INSTALL_DIR=\"$HOME/.uptool/plugins\"\n    mkdir -p \"$INSTALL_DIR\"\n    cp \"${PLUGIN_NAME}.so\" \"$INSTALL_DIR/\"\n    echo \"\u2713 Installed to $INSTALL_DIR\"\nfi\n</code></pre> <p>Usage:</p> <pre><code>chmod +x build.sh\n./build.sh          # Build only\n./build.sh install  # Build and install\n</code></pre>"},{"location":"plugin-development/#mise-tasks","title":"mise Tasks","text":"<pre><code># mise.toml\n[tasks.build-plugin]\ndescription = \"Build the plugin\"\nrun = \"\"\"\necho \"Building example plugin...\"\ngo build -buildmode=plugin -o example.so .\necho \"\u2713 Plugin built\"\n\"\"\"\n\n[tasks.install-plugin]\ndescription = \"Install plugin to ~/.uptool/plugins\"\ndepends = [\"build-plugin\"]\nrun = \"\"\"\necho \"Installing to ~/.uptool/plugins...\"\nmkdir -p ~/.uptool/plugins\ncp example.so ~/.uptool/plugins/\necho \"\u2713 Plugin installed\"\n\"\"\"\n\n[tasks.clean-plugin]\ndescription = \"Clean plugin artifacts\"\nrun = \"rm -f example.so\"\n\n[tasks.test-plugin]\ndescription = \"Test the plugin\"\nrun = \"go test -v ./...\"\n</code></pre>"},{"location":"plugin-development/#testing-plugins","title":"Testing Plugins","text":""},{"location":"plugin-development/#unit-tests","title":"Unit Tests","text":"<pre><code>// integration_test.go\npackage main\n\nimport (\n    \"context\"\n    \"testing\"\n\n    \"github.com/santosr2/uptool/internal/engine\"\n)\n\nfunc TestDetect(t *testing.T) {\n    integration := New()\n\n    manifests, err := integration.Detect(context.Background(), \"testdata\")\n    if err != nil {\n        t.Fatalf(\"Detect() error: %v\", err)\n    }\n\n    if len(manifests) == 0 {\n        t.Error(\"Expected to find manifests\")\n    }\n}\n\nfunc TestPlan(t *testing.T) {\n    integration := New()\n\n    manifest := &amp;engine.Manifest{\n        Path:        \"testdata/example.yaml\",\n        Integration: \"example\",\n        Dependencies: []*engine.Dependency{\n            {Name: \"package1\", CurrentVersion: \"1.0.0\"},\n        },\n    }\n\n    plan, err := integration.Plan(context.Background(), manifest)\n    if err != nil {\n        t.Fatalf(\"Plan() error: %v\", err)\n    }\n\n    if plan == nil {\n        t.Error(\"Expected non-nil plan\")\n    }\n}\n</code></pre>"},{"location":"plugin-development/#integration-testing","title":"Integration Testing","text":"<p>Test with real uptool binary:</p> <pre><code># Build plugin\ngo build -buildmode=plugin -o example.so .\nmkdir -p plugins\ncp example.so plugins/\n\n# Create test repository\nmkdir -p testdata\ncat &gt; testdata/example.yaml &lt;&lt;EOF\ndependencies:\n  package1: 1.0.0\n  package2: 2.0.0\nEOF\n\n# Test scan\nuptool scan --only=example\n\n# Test plan\nuptool plan --only=example\n\n# Test update (dry-run)\nuptool update --only=example --dry-run --diff\n</code></pre>"},{"location":"plugin-development/#best-practices","title":"Best Practices","text":""},{"location":"plugin-development/#1-version-compatibility","title":"1. Version Compatibility","text":"<p>Ensure plugin is built with compatible uptool version:</p> <pre><code>// version.go\npackage main\n\nconst (\n    // PluginVersion is this plugin's version\n    PluginVersion = \"1.0.0\"\n\n    // RequiredUptoolVersion is the minimum compatible uptool version\n    RequiredUptoolVersion = \"0.1.0\"\n)\n\n// Optionally check version compatibility\nfunc init() {\n    // Check uptool version and warn if incompatible\n}\n</code></pre>"},{"location":"plugin-development/#2-error-handling","title":"2. Error Handling","text":"<p>Provide helpful error messages:</p> <pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error) {\n    manifests, err := i.findManifests(repoRoot)\n    if err != nil {\n        return nil, fmt.Errorf(\"example: detecting manifests in %s: %w\", repoRoot, err)\n    }\n    return manifests, nil\n}\n</code></pre>"},{"location":"plugin-development/#3-logging","title":"3. Logging","text":"<p>Use structured logging:</p> <pre><code>import \"log/slog\"\n\ntype Integration struct {\n    logger *slog.Logger\n}\n\nfunc New() engine.Integration {\n    return &amp;Integration{\n        logger: slog.Default().With(\"integration\", \"example\"),\n    }\n}\n\nfunc (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error) {\n    i.logger.Info(\"scanning for manifests\", \"root\", repoRoot)\n    // ...\n}\n</code></pre>"},{"location":"plugin-development/#4-context-handling","title":"4. Context Handling","text":"<p>Respect context cancellation:</p> <pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error) {\n    for _, dep := range manifest.Dependencies {\n        // Check context before expensive operations\n        select {\n        case &lt;-ctx.Done():\n            return nil, ctx.Err()\n        default:\n        }\n\n        version, err := i.queryRegistry(ctx, dep.Name)\n        // ...\n    }\n}\n</code></pre>"},{"location":"plugin-development/#5-resource-cleanup","title":"5. Resource Cleanup","text":"<p>Clean up resources:</p> <pre><code>type Integration struct {\n    client *http.Client\n}\n\nfunc New() engine.Integration {\n    return &amp;Integration{\n        client: &amp;http.Client{Timeout: 30 * time.Second},\n    }\n}\n\n// Optional: Implement cleanup if needed\nfunc (i *Integration) Close() error {\n    i.client.CloseIdleConnections()\n    return nil\n}\n</code></pre>"},{"location":"plugin-development/#6-testing","title":"6. Testing","text":"<p>Include comprehensive tests:</p> <pre><code># Test plugin before distribution\ngo test -v ./...\ngo test -race ./...\ngo test -cover ./...\n</code></pre>"},{"location":"plugin-development/#7-documentation","title":"7. Documentation","text":"<p>Document your plugin:</p> <pre><code># Example Plugin\n\nCustom uptool integration for example.yaml manifests.\n\n## Installation\n\n```bash\nmkdir -p ~/.uptool/plugins\ncurl -LO https://github.com/you/plugin/releases/latest/example.so\nmv example.so ~/.uptool/plugins/\n</code></pre>"},{"location":"plugin-development/#usage","title":"Usage","text":"<pre><code>uptool scan --only=example\nuptool plan --only=example\nuptool update --only=example\n</code></pre>"},{"location":"plugin-development/#manifest-format","title":"Manifest Format","text":"<pre><code># example.yaml\ndependencies:\n  package1: 1.0.0\n  package2: 2.0.0\n</code></pre> <pre><code>## Example Plugins\n\nComplete example plugins are available in the `examples/plugins/` directory:\n\n- **Python (pip)** - `examples/plugins/python/` - Manages requirements.txt\n- **Ruby (bundler)** - `examples/plugins/ruby/` - Manages Gemfile\n- **Custom YAML** - `examples/plugins/custom-yaml/` - Generic YAML dependency updater\n\nEach example includes:\n- Full source code\n- Tests\n- Build scripts\n- Documentation\n\n## Distribution\n\n### GitHub Releases\n\nCreate releases with compiled plugins:\n\n```bash\n# Build for multiple architectures\nGOOS=linux GOARCH=amd64 go build -buildmode=plugin -o example-linux-amd64.so .\nGOOS=linux GOARCH=arm64 go build -buildmode=plugin -o example-linux-arm64.so .\nGOOS=darwin GOARCH=amd64 go build -buildmode=plugin -o example-darwin-amd64.so .\nGOOS=darwin GOARCH=arm64 go build -buildmode=plugin -o example-darwin-arm64.so .\n\n# Create GitHub release and attach .so files\ngh release create v1.0.0 *.so\n</code></pre>"},{"location":"plugin-development/#installation-script","title":"Installation Script","text":"<p>Provide an easy installation script:</p> <pre><code>#!/bin/bash\n# install.sh\nset -e\n\nPLUGIN_NAME=\"example\"\nVERSION=\"${VERSION:-latest}\"\nOS=$(uname -s | tr '[:upper:]' '[:lower:]')\nARCH=$(uname -m)\n\ncase \"$ARCH\" in\n    x86_64) ARCH=\"amd64\" ;;\n    aarch64|arm64) ARCH=\"arm64\" ;;\nesac\n\nDOWNLOAD_URL=\"https://github.com/you/plugin/releases/download/${VERSION}/${PLUGIN_NAME}-${OS}-${ARCH}.so\"\n\necho \"Installing ${PLUGIN_NAME} for ${OS}/${ARCH}...\"\nmkdir -p ~/.uptool/plugins\ncurl -L \"$DOWNLOAD_URL\" -o ~/.uptool/plugins/${PLUGIN_NAME}.so\necho \"\u2713 Installed ${PLUGIN_NAME} plugin\"\n</code></pre>"},{"location":"plugin-development/#example-plugins","title":"Example plugins","text":"<p>see: example</p>"},{"location":"plugin-development/#see-also","title":"See Also","text":"<ul> <li>Integration Development Guide - Built-in integrations</li> <li>Engine Interface - Integration interface definition</li> <li>Example Plugins - Complete working examples</li> <li>API Documentation - Go package docs</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get up and running with uptool in 5 minutes!</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have uptool installed. If not, see the Installation Guide.</p> <pre><code>uptool version\n</code></pre>"},{"location":"quickstart/#step-1-initialize-your-project","title":"Step 1: Initialize Your Project","text":"<p>Navigate to your project directory:</p> <pre><code>cd your-project\n</code></pre>"},{"location":"quickstart/#step-2-scan-for-dependencies","title":"Step 2: Scan for Dependencies","text":"<p>Scan your project to detect supported manifest files and check for outdated dependencies:</p> <pre><code>uptool scan\n</code></pre> <p>Example output:</p> <pre><code>Found 5 manifest files:\n  \u2705 package.json (npm)\n  \u2705 Chart.yaml (helm)\n  \u2705 main.tf (terraform)\n  \u2705 .pre-commit-config.yaml (precommit)\n  \u2705 mise.toml (mise)\n\nScanning for updates...\n</code></pre>"},{"location":"quickstart/#step-3-plan-updates","title":"Step 3: Plan Updates","text":"<p>Preview what would be updated without making changes:</p> <pre><code>uptool plan\n</code></pre> <p>Example output:</p> <pre><code>Updates available:\n\nnpm (package.json):\n  - react: 18.2.0 \u2192 18.3.1\n  - typescript: 5.0.0 \u2192 5.4.5\n\nterraform (main.tf):\n  - aws: 5.0.0 \u2192 5.70.0\n\nprecommit (.pre-commit-config.yaml):\n  - golangci-lint: v1.63.4 \u2192 v2.6.2\n</code></pre> <p>Dry Run</p> <p>The <code>plan</code> command never modifies files. It only shows what would change.</p>"},{"location":"quickstart/#step-4-apply-updates","title":"Step 4: Apply Updates","text":"<p>Apply the updates with a diff preview:</p> <pre><code>uptool update --diff\n</code></pre> <p>This will:</p> <ol> <li>Update manifest files</li> <li>Show a diff of changes</li> <li>Preserve formatting and comments</li> <li>Validate the changes</li> </ol> <p>Example diff output:</p> <pre><code>--- package.json\n+++ package.json\n@@ -5,7 +5,7 @@\n   \"dependencies\": {\n-    \"react\": \"^18.2.0\",\n+    \"react\": \"^18.3.1\",\n-    \"typescript\": \"^5.0.0\"\n+    \"typescript\": \"^5.4.5\"\n   }\n }\n</code></pre>"},{"location":"quickstart/#step-5-review-and-commit","title":"Step 5: Review and Commit","text":"<p>After uptool applies the updates, review the changes:</p> <pre><code>git diff\n</code></pre> <p>Commit the changes:</p> <pre><code>git add .\ngit commit -m \"chore(deps): update dependencies via uptool\"\ngit push\n</code></pre>"},{"location":"quickstart/#advanced-usage","title":"Advanced Usage","text":""},{"location":"quickstart/#filter-by-integration","title":"Filter by Integration","text":"<p>Update only specific integrations:</p> <pre><code># Update only npm packages\nuptool update --only npm\n\n# Update everything except terraform\nuptool update --exclude terraform\n</code></pre>"},{"location":"quickstart/#dry-run-mode","title":"Dry Run Mode","text":"<p>Preview changes without applying:</p> <pre><code>uptool update --dry-run\n</code></pre>"},{"location":"quickstart/#quiet-mode","title":"Quiet Mode","text":"<p>Suppress informational output (errors only):</p> <pre><code>uptool update --quiet\n</code></pre>"},{"location":"quickstart/#verbose-mode","title":"Verbose Mode","text":"<p>Get detailed debug output:</p> <pre><code>uptool scan --verbose\n</code></pre>"},{"location":"quickstart/#configuration-file","title":"Configuration File","text":"<p>Create a <code>uptool.yaml</code> configuration file to customize behavior:</p> <pre><code># Enable/disable specific integrations\nintegrations:\n  npm:\n    enabled: true\n  terraform:\n    enabled: true\n  helm:\n    enabled: false  # Skip Helm charts\n\n# Update policies\npolicies:\n  npm:\n    allow_major: false  # Only minor and patch updates\n    allow_prerelease: false\n\n  terraform:\n    allow_major: true\n    version_constraints: \"~&gt;\"  # Use pessimistic constraints\n</code></pre> <p>See the Configuration Guide for more details.</p>"},{"location":"quickstart/#using-as-a-github-action","title":"Using as a GitHub Action","text":"<p>Add uptool to your CI/CD pipeline:</p> <pre><code>name: Dependency Updates\n\non:\n  schedule:\n    - cron: '0 0 * * 1'  # Weekly on Monday\n  workflow_dispatch:\n\njobs:\n  update-dependencies:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run uptool\n        uses: santosr2/uptool@v0.1\n        with:\n          command: update\n          create-pr: true\n</code></pre> <p>See the GitHub Action Usage Guide for more examples.</p>"},{"location":"quickstart/#example-projects","title":"Example Projects","text":"<p>Check out example configurations:</p> <ul> <li>JavaScript Project: examples/javascript</li> <li>Terraform Project: examples/terraform</li> <li>Multi-Language: examples/monorepo</li> </ul>"},{"location":"quickstart/#common-workflows","title":"Common Workflows","text":""},{"location":"quickstart/#daily-dependency-scan","title":"Daily Dependency Scan","text":"<pre><code># Add to crontab\n0 9 * * * cd /path/to/project &amp;&amp; uptool scan\n</code></pre>"},{"location":"quickstart/#pre-commit-hook","title":"Pre-commit Hook","text":"<pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: local\n    hooks:\n      - id: uptool-scan\n        name: Scan for outdated dependencies\n        entry: uptool scan\n        language: system\n        pass_filenames: false\n</code></pre>"},{"location":"quickstart/#integration-with-ci","title":"Integration with CI","text":"<pre><code># In your CI script\nuptool scan || exit 1\nuptool plan --format json &gt; updates.json\n</code></pre>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quickstart/#no-updates-found","title":"No Updates Found","text":"<p>If <code>uptool scan</code> doesn't find updates:</p> <ol> <li>Check that manifest files exist and are valid</li> <li>Verify internet connectivity (uptool queries registries)</li> <li>Run with <code>--verbose</code> to see debug output</li> </ol>"},{"location":"quickstart/#permission-denied","title":"Permission Denied","text":"<p>If you get permission errors:</p> <pre><code># On Linux/macOS\nsudo chmod +x /usr/local/bin/uptool\n\n# Or install to user directory\ngo install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre>"},{"location":"quickstart/#rate-limiting","title":"Rate Limiting","text":"<p>If you hit API rate limits:</p> <pre><code># Use authentication for higher limits\nexport NPM_TOKEN=your-npm-token\nexport GITHUB_TOKEN=your-github-token\nuptool scan\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Customize uptool behavior</li> <li>Integrations - Learn about supported ecosystems</li> <li>GitHub Action Usage - Automate dependency updates</li> <li>Plugin Development - Add custom integrations</li> </ul>"},{"location":"versioning/","title":"Version Management","text":"<p>uptool uses automated semantic versioning based on conventional commits and GitHub Actions workflows. This document explains the complete version management system.</p>"},{"location":"versioning/#overview","title":"Overview","text":"<p>Version management in uptool is fully automated:</p> <ol> <li>Conventional commits determine version bumps</li> <li>GitHub Actions calculate and apply versions</li> <li><code>bump-my-version</code> updates all files consistently</li> <li>VERSION file is the single source of truth</li> </ol>"},{"location":"versioning/#version-sources","title":"Version Sources","text":""},{"location":"versioning/#single-source-of-truth","title":"Single Source of Truth","text":"<p>The canonical version is stored in <code>internal/version/VERSION</code>:</p> <pre><code>0.1.0\n</code></pre> <p>This file is:</p> <ul> <li>Embedded into Go binaries at build time</li> <li>Updated automatically by GitHub Actions</li> <li>Used by <code>bump-my-version</code> to update all documentation</li> </ul>"},{"location":"versioning/#version-embedding","title":"Version Embedding","text":"<p>The CLI reads the version from the embedded VERSION file:</p> <pre><code>// internal/version/version.go\npackage version\n\nimport (\n    _ \"embed\"\n    \"strings\"\n)\n\n//go:embed VERSION\nvar versionFile string\n\nvar version = strings.TrimSpace(versionFile)\n\nfunc Get() string {\n    if version == \"\" {\n        return \"dev\"\n    }\n    return version\n}\n</code></pre> <p>When you build the binary:</p> <pre><code>go build ./cmd/uptool\n./uptool --version\n# Output: uptool version 0.1.0\n</code></pre>"},{"location":"versioning/#conventional-commits","title":"Conventional Commits","text":"<p>uptool follows the Conventional Commits specification to determine version bumps.</p>"},{"location":"versioning/#commit-format","title":"Commit Format","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre>"},{"location":"versioning/#version-bump-rules","title":"Version Bump Rules","text":"Commit Type Example Version Bump Example <code>feat:</code> <code>feat: add Python integration</code> Minor 0.1.0 \u2192 0.2.0 <code>fix:</code> <code>fix: handle empty manifests</code> Patch 0.1.0 \u2192 0.1.1 <code>BREAKING CHANGE:</code> <code>feat!: redesign API</code> Major 0.1.0 \u2192 1.0.0 <code>chore:</code>, <code>docs:</code>, etc. <code>docs: update README</code> None No bump"},{"location":"versioning/#supported-types","title":"Supported Types","text":"<ul> <li><code>feat:</code> - New feature (minor bump)</li> <li><code>fix:</code> - Bug fix (patch bump)</li> <li><code>docs:</code> - Documentation only (no bump)</li> <li><code>style:</code> - Formatting, no code change (no bump)</li> <li><code>refactor:</code> - Code change that neither fixes nor adds (no bump)</li> <li><code>perf:</code> - Performance improvement (patch bump)</li> <li><code>test:</code> - Adding/updating tests (no bump)</li> <li><code>chore:</code> - Maintenance tasks (no bump)</li> <li><code>ci:</code> - CI/CD changes (no bump)</li> <li><code>revert:</code> - Revert previous commit (patch bump)</li> </ul>"},{"location":"versioning/#breaking-changes","title":"Breaking Changes","text":"<p>To trigger a major version bump, use either:</p> <p>Method 1: Exclamation mark</p> <pre><code>git commit -m \"feat!: redesign integration interface\"\n</code></pre> <p>Method 2: Footer</p> <pre><code>git commit -m \"feat: redesign integration interface\n\nBREAKING CHANGE: Integration interface now requires Validate method\"\n</code></pre>"},{"location":"versioning/#examples","title":"Examples","text":"<p>Feature Addition (Minor Bump):</p> <pre><code>git commit -m \"feat(integrations): add Python integration\n\nAdd support for pyproject.toml, requirements.txt, and Pipfile.\nIncludes version resolution via PyPI API and TOML rewriting.\"\n</code></pre> <p>\u2192 0.1.0 \u2192 0.2.0</p> <p>Bug Fix (Patch Bump):</p> <pre><code>git commit -m \"fix(npm): handle empty devDependencies\n\nPreviously crashed when package.json had missing devDependencies section.\"\n</code></pre> <p>\u2192 0.1.0 \u2192 0.1.1</p> <p>Breaking Change (Major Bump):</p> <pre><code>git commit -m \"feat!: redesign configuration format\n\nBREAKING CHANGE: uptool.yaml now requires version: 2 and uses\ndifferent policy structure. See migration guide in docs/.\"\n</code></pre> <p>\u2192 0.1.0 \u2192 1.0.0</p> <p>Documentation (No Bump):</p> <pre><code>git commit -m \"docs: add versioning guide\"\n</code></pre> <p>\u2192 No version change</p>"},{"location":"versioning/#automated-release-process","title":"Automated Release Process","text":""},{"location":"versioning/#pre-release-workflow","title":"Pre-Release Workflow","text":"<p>Location: <code>.github/workflows/pre-release.yml</code></p> <p>Trigger: Manual dispatch (workflow_dispatch)</p> <p>Steps:</p> <ol> <li>Calculate Version</li> <li>Uses <code>mathieudutour/github-tag-action</code> to analyze commits since last tag</li> <li>Determines semantic version bump (major/minor/patch)</li> <li> <p>Calculates pre-release version with type suffix</p> </li> <li> <p>Update VERSION Files</p> </li> <li> <p>Uses <code>bump-my-version</code> to update:</p> <ul> <li><code>internal/version/VERSION</code></li> <li>All documentation version references</li> <li>README.md examples</li> <li>SECURITY.md policy</li> <li>docs/action-usage.md</li> </ul> </li> <li> <p>Commit Changes</p> </li> <li>Commits version updates to <code>main</code> branch</li> <li> <p>Commit message: <code>chore(release): bump version to v0.2.0-rc.1 [skip ci]</code></p> </li> <li> <p>Run Tests</p> </li> <li>Checks out updated code</li> <li>Runs full test suite</li> <li> <p>Runs <code>go vet</code></p> </li> <li> <p>Approval Gate \u26a0\ufe0f</p> </li> <li>Workflow pauses for manual approval</li> <li>Uses GitHub Environment: <code>pre-release</code></li> <li>Requires approval from designated reviewers</li> <li> <p>See Environment Setup for configuration</p> </li> <li> <p>Build Artifacts (after approval)</p> </li> <li>Builds for all platforms (Linux, macOS, Windows)</li> <li>Generates checksums (SHA256)</li> <li>Creates SBOM files (SPDX + CycloneDX)</li> <li> <p>Signs with Cosign (keyless)</p> </li> <li> <p>Create Pre-Release</p> </li> <li>Creates Git tag (e.g., <code>v0.2.0-rc.1</code>)</li> <li>Generates changelog from commits</li> <li>Uploads all artifacts to GitHub Release</li> <li>Marks as pre-release</li> </ol>"},{"location":"versioning/#running-a-pre-release","title":"Running a Pre-Release","text":"<ol> <li>Go to Actions \u2192 Pre-Release</li> <li>Click Run workflow</li> <li>Select pre-release type:</li> <li>rc - Release candidate (recommended for testing before stable)</li> <li>beta - Beta version (earlier testing phase)</li> <li>alpha - Alpha version (very early, unstable)</li> <li>Click Run workflow</li> <li>Wait for approval \u26a0\ufe0f</li> <li>Workflow will pause after tests complete</li> <li>Designated reviewers receive notification</li> <li>Review the changes and approve/reject</li> <li>See Approving Deployments</li> </ol> <p>Example:</p> <ul> <li>Current version: <code>v0.1.0</code></li> <li>Commits since last tag: 2 <code>feat:</code> commits, 1 <code>fix:</code> commit</li> <li>Pre-release type: <code>rc</code></li> <li>Result: <code>v0.2.0-rc.1</code> (feat causes minor bump)</li> </ul> <p>If you run another pre-release without new commits:</p> <ul> <li>Result: <code>v0.2.0-rc.2</code> (increments rc number)</li> </ul>"},{"location":"versioning/#promote-to-stable-workflow","title":"Promote to Stable Workflow","text":"<p>Location: <code>.github/workflows/promote-release.yml</code></p> <p>Trigger: Manual dispatch with pre-release tag input</p> <p>Steps:</p> <ol> <li>Validate Pre-Release</li> <li>Checks that pre-release tag exists</li> <li>Extracts stable version (<code>v0.2.0-rc.1</code> \u2192 <code>v0.2.0</code>)</li> <li> <p>Verifies stable tag doesn't already exist</p> </li> <li> <p>Update to Stable Version</p> </li> <li>Uses <code>bump-my-version</code> to remove pre-release suffix</li> <li>Updates <code>internal/version/VERSION</code> to <code>0.2.0</code></li> <li> <p>Updates all documentation</p> </li> <li> <p>Commit Changes</p> </li> <li>Commits version updates to <code>main</code> branch</li> <li> <p>Commit message: <code>chore(release): release v0.2.0 [skip ci]</code></p> </li> <li> <p>Run Final Tests</p> </li> <li>Runs full test suite on stable version</li> <li> <p>Verifies build works</p> </li> <li> <p>Approval Gate \u26a0\ufe0f</p> </li> <li>Workflow pauses for manual approval</li> <li>Uses GitHub Environment: <code>production</code></li> <li>Requires approval from designated reviewers (recommended: 2+)</li> <li> <p>See Environment Setup for configuration</p> </li> <li> <p>Promote Release (after approval)</p> </li> <li>Downloads all artifacts from pre-release</li> <li>Creates Git tag (e.g., <code>v0.2.0</code>)</li> <li>Creates stable GitHub Release</li> <li>Marks as latest release</li> <li>Updates CHANGELOG.md</li> </ol>"},{"location":"versioning/#running-a-stable-release","title":"Running a Stable Release","text":"<ol> <li>Go to Actions \u2192 Promote to Stable Release</li> <li>Click Run workflow</li> <li>Enter pre-release tag (e.g., <code>v0.2.0-rc.1</code>)</li> <li>Click Run workflow</li> <li>Wait for approval \u26a0\ufe0f</li> <li>Workflow will pause after tests complete</li> <li>Designated reviewers receive notification</li> <li>Review the pre-release testing results</li> <li>Approve/reject the promotion to stable</li> <li>See Approving Deployments</li> </ol> <p>The system automatically (after approval):</p> <ul> <li>Detects stable version (<code>v0.2.0</code>)</li> <li>Updates VERSION file</li> <li>Promotes artifacts</li> <li>Updates CHANGELOG</li> <li>Creates stable release</li> </ul>"},{"location":"versioning/#local-version-management","title":"Local Version Management","text":"<p>For local development and testing, you can manually manage versions using Mise tasks targets.</p>"},{"location":"versioning/#show-current-version","title":"Show Current Version","text":"<pre><code>mise run version-show\n# Output:\n# Current version:\n# 0.1.0\n</code></pre>"},{"location":"versioning/#bump-version-locally","title":"Bump Version Locally","text":"<p>Important: Only use these for local testing. Production releases are automated via GitHub Actions.</p> <pre><code># Patch bump (0.1.0 \u2192 0.1.1)\nmise run version-bump-patch\n\n# Minor bump (0.1.0 \u2192 0.2.0)\nmise run version-bump-minor\n\n# Major bump (0.1.0 \u2192 1.0.0)\nmise run version-bump-major\n</code></pre> <p>These commands use <code>bump-my-version</code> to update:</p> <ul> <li><code>internal/version/VERSION</code></li> <li><code>README.md</code></li> <li><code>SECURITY.md</code></li> <li><code>docs/action-usage.md</code></li> </ul> <p>After bumping locally:</p> <pre><code># Rebuild to test\nmise run build\n./dist/uptool --version\n\n# Commit changes\ngit add .\ngit commit -m \"chore: bump version to 0.2.0\"\n</code></pre>"},{"location":"versioning/#file-update-mechanism","title":"File Update Mechanism","text":""},{"location":"versioning/#bump-my-version-configuration","title":"bump-my-version Configuration","text":"<p>Location: <code>.bumpversion.toml</code></p> <pre><code>[tool.bumpversion]\ncurrent_version = \"0.1.0\"\nparse = \"(?P&lt;major&gt;\\\\d+)\\\\.(?P&lt;minor&gt;\\\\d+)\\\\.(?P&lt;patch&gt;\\\\d+)(\\\\-(?P&lt;pre_label&gt;rc|beta|alpha)\\\\.(?P&lt;pre_num&gt;\\\\d+))?\"\nserialize = [\n    \"{major}.{minor}.{patch}-{pre_label}.{pre_num}\",\n    \"{major}.{minor}.{patch}\",\n]\n\n# Source of truth\n[[tool.bumpversion.files]]\nfilename = \"internal/version/VERSION\"\n\n# Documentation\n[[tool.bumpversion.files]]\nfilename = \"README.md\"\nsearch = \"@v{current_version}\"\nreplace = \"@v{new_version}\"\n\n# ... more files ...\n</code></pre>"},{"location":"versioning/#files-updated-automatically","title":"Files Updated Automatically","text":"<p>When <code>bump-my-version</code> runs, it updates:</p> <ol> <li>internal/version/VERSION - Single source of truth</li> <li>README.md - GitHub Action version examples</li> <li>SECURITY.md - Supported version policy</li> <li>docs/action-usage.md - Action usage examples</li> </ol> <p>All updates preserve file formatting and context.</p>"},{"location":"versioning/#version-tagging","title":"Version Tagging","text":""},{"location":"versioning/#tag-format","title":"Tag Format","text":"<p>uptool uses semantic versioning with <code>v</code> prefix and supports both immutable and mutable tags:</p>"},{"location":"versioning/#immutable-tags-never-change","title":"Immutable Tags (Never Change)","text":"<ul> <li>Stable releases: <code>v0.1.0</code>, <code>v0.2.0</code>, <code>v1.0.0</code></li> <li>Pre-releases: <code>v0.2.0-rc.1</code>, <code>v1.0.0-beta.2</code>, <code>v0.3.0-alpha.1</code></li> </ul>"},{"location":"versioning/#mutable-tags-auto-updated","title":"Mutable Tags (Auto-Updated)","text":"<p>For GitHub Actions convenience, mutable tags are automatically maintained:</p> <p>Stable Release Tags:</p> <ul> <li><code>v0</code> - Always points to latest <code>v0.x.x</code> stable release</li> <li><code>v0.1</code> - Always points to latest <code>v0.1.x</code> patch release</li> <li><code>v1</code> - Always points to latest <code>v1.x.x</code> stable release</li> </ul> <p>Pre-Release Tags:</p> <ul> <li><code>v0-rc</code> - Always points to latest release candidate in v0</li> <li><code>v0.1-rc</code> - Always points to latest release candidate in v0.1</li> <li><code>v0-beta</code> - Always points to latest beta in v0</li> <li><code>v0.1-beta</code> - Always points to latest beta in v0.1</li> </ul>"},{"location":"versioning/#tag-creation","title":"Tag Creation","text":"<p>Tags are created automatically by GitHub Actions:</p>"},{"location":"versioning/#pre-release-workflow_1","title":"Pre-release Workflow","text":"<p>Creates 3 tags:</p> <pre><code># Immutable tag (exact version)\ngit tag -a \"v0.2.0-rc.1\" -m \"Pre-release v0.2.0-rc.1\"\ngit push origin \"v0.2.0-rc.1\"\n\n# Mutable tags (force-updated to follow latest)\ngit tag -fa \"v0.2-rc\" -m \"Latest rc pre-release in v0.2\"\ngit push origin \"v0.2-rc\" --force\n\ngit tag -fa \"v0-rc\" -m \"Latest rc pre-release in v0\"\ngit push origin \"v0-rc\" --force\n</code></pre> <p>Example: If you release <code>v0.2.0-rc.1</code>, then <code>v0.2.0-rc.2</code>:</p> <ul> <li><code>v0.2.0-rc.1</code> - Points to rc.1 (immutable)</li> <li><code>v0.2.0-rc.2</code> - Points to rc.2 (immutable)</li> <li><code>v0.2-rc</code> - Updates from rc.1 \u2192 rc.2 (mutable)</li> <li><code>v0-rc</code> - Updates from rc.1 \u2192 rc.2 (mutable)</li> </ul>"},{"location":"versioning/#promote-workflow","title":"Promote Workflow","text":"<p>Creates 3 tags:</p> <pre><code># Immutable tag (exact version)\ngit tag -a \"v0.2.0\" -m \"Release v0.2.0 (promoted from v0.2.0-rc.1)\"\ngit push origin \"v0.2.0\"\n\n# Mutable tags (force-updated to follow latest)\ngit tag -fa \"v0.2\" -m \"Latest stable release in v0.2 (currently v0.2.0)\"\ngit push origin \"v0.2\" --force\n\ngit tag -fa \"v0\" -m \"Latest stable release in v0 (currently v0.2.0)\"\ngit push origin \"v0\" --force\n</code></pre> <p>Example: If you release <code>v0.1.0</code>, then <code>v0.2.0</code>, then <code>v0.2.1</code>:</p> <ul> <li><code>v0.1.0</code>, <code>v0.2.0</code>, <code>v0.2.1</code> - Immutable exact versions</li> <li><code>v0.1</code> - Points to v0.1.0 (immutable after v0.2.0 release)</li> <li><code>v0.2</code> - Updates from v0.2.0 \u2192 v0.2.1 (mutable)</li> <li><code>v0</code> - Updates from v0.1.0 \u2192 v0.2.0 \u2192 v0.2.1 (mutable)</li> </ul>"},{"location":"versioning/#github-actions-usage","title":"GitHub Actions Usage","text":"<p>These mutable tags make it easy to reference uptool in workflows:</p> <pre><code># Recommended: Pin to major version\n- uses: santosr2/uptool@v0\n  # Gets latest v0.x.x automatically (v0.1.0 \u2192 v0.2.0 \u2192 v0.2.1)\n\n# Pin to minor version\n- uses: santosr2/uptool@v0.2\n  # Gets latest v0.2.x patches (v0.2.0 \u2192 v0.2.1 \u2192 v0.2.2)\n\n# Pin to exact version (most secure)\n- uses: santosr2/uptool@v0.2.0\n  # Never changes\n\n# Test with pre-releases\n- uses: santosr2/uptool@v0-rc\n  # Gets latest release candidate\n</code></pre>"},{"location":"versioning/#viewing-tags","title":"Viewing Tags","text":"<pre><code># List all tags\ngit tag\n\n# List only stable releases (immutable)\ngit tag -l 'v[0-9]*.[0-9]*.[0-9]*' | grep -v '\\-'\n\n# List only pre-releases (immutable)\ngit tag -l 'v[0-9]*.[0-9]*.[0-9]*-*'\n\n# List mutable stable tags\ngit tag -l 'v[0-9]*' | grep -v '\\.' | grep -v '\\-'\ngit tag -l 'v[0-9]*.[0-9]*' | grep -v '\\.' | grep -v '\\-'\n\n# List mutable pre-release tags\ngit tag -l 'v*-rc' 'v*-beta' 'v*-alpha'\n\n# Show tag details\ngit show v0.1.0\ngit show v0     # Shows what v0 currently points to\ngit show v0-rc  # Shows latest rc\n</code></pre>"},{"location":"versioning/#tag-management-rules","title":"Tag Management Rules","text":"<p>Immutable Tags (created once, never modified):</p> <ul> <li>\u2705 Exact versions: <code>v0.1.0</code>, <code>v1.2.3</code></li> <li>\u2705 Exact pre-releases: <code>v0.2.0-rc.1</code>, <code>v1.0.0-beta.2</code></li> </ul> <p>Mutable Tags (force-updated on each release):</p> <ul> <li>\u26a0\ufe0f Major version: <code>v0</code>, <code>v1</code></li> <li>\u26a0\ufe0f Minor version: <code>v0.1</code>, <code>v1.2</code></li> <li>\u26a0\ufe0f Pre-release major: <code>v0-rc</code>, <code>v1-beta</code></li> <li>\u26a0\ufe0f Pre-release minor: <code>v0.1-rc</code>, <code>v1.2-alpha</code></li> </ul>"},{"location":"versioning/#changelog-management","title":"CHANGELOG Management","text":"<p>The CHANGELOG is automatically generated from commit messages using <code>git-cliff</code>.</p>"},{"location":"versioning/#configuration","title":"Configuration","text":"<p>Location: <code>git-cliff.toml</code></p> <p>Defines:</p> <ul> <li>Commit grouping by type (<code>feat</code>, <code>fix</code>, etc.)</li> <li>Link generation for commits and comparisons</li> <li>Version extraction from tags</li> <li>Output format (Keep a Changelog style)</li> </ul>"},{"location":"versioning/#update-process","title":"Update Process","text":"<p>Pre-release workflow: Generates changelog section for release notes</p> <p>Promote workflow: Updates CHANGELOG.md with new version:</p> <pre><code>git-cliff --config git-cliff.toml --tag \"v0.2.0\" --prepend CHANGELOG.md\n</code></pre>"},{"location":"versioning/#changelog-format","title":"CHANGELOG Format","text":"<pre><code># Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [0.2.0] - 2025-01-15\n\n### Features\n- Add Python integration (#123)\n- Support for pyproject.toml (#124)\n\n### Bug Fixes\n- Handle empty devDependencies in npm (#125)\n\n## [0.1.0] - 2025-01-10\n\nInitial release\n</code></pre>"},{"location":"versioning/#release-approval-process","title":"Release Approval Process","text":"<p>uptool uses GitHub Environments with approval gates to control releases. This provides an additional security layer and creates an audit trail for all releases.</p>"},{"location":"versioning/#overview_1","title":"Overview","text":"<p>Both release workflows require manual approval before artifacts are created or promoted:</p> <ul> <li>Pre-Release Workflow: Requires approval before building and publishing pre-release artifacts</li> <li>Promote Workflow: Requires approval before promoting to stable release</li> </ul>"},{"location":"versioning/#github-environments","title":"GitHub Environments","text":"<p>Two environments are configured:</p>"},{"location":"versioning/#pre-release-environment","title":"pre-release Environment","text":"<ul> <li>Purpose: Protect pre-release creation</li> <li>Used by: <code>.github/workflows/pre-release.yml</code></li> <li>Recommended reviewers: 1+ maintainers</li> <li>Approval required: Before building artifacts</li> </ul>"},{"location":"versioning/#production-environment","title":"production Environment","text":"<ul> <li>Purpose: Protect stable release promotion</li> <li>Used by: <code>.github/workflows/promote-release.yml</code></li> <li>Recommended reviewers: 2+ senior maintainers</li> <li>Approval required: Before promoting to stable</li> </ul>"},{"location":"versioning/#setting-up-environments","title":"Setting Up Environments","text":"<p>Environments must be configured by repository administrators:</p> <ol> <li>Go to Settings \u2192 Environments</li> <li>Create <code>pre-release</code> and <code>production</code> environments</li> <li>Configure protection rules:</li> <li>Add required reviewers</li> <li>Restrict to <code>main</code> branch only</li> <li>Optional: Add wait timer</li> </ol> <p>Complete setup instructions: See Environment Setup Guide</p>"},{"location":"versioning/#approval-workflow","title":"Approval Workflow","text":"<p>When a release workflow runs:</p> <ol> <li>Workflow triggers and runs initial steps (calculate version, update files, test)</li> <li>Workflow pauses at the environment-protected job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewers see:</li> <li>Version being released</li> <li>Commit SHA</li> <li>Test results</li> <li>Link to pending deployment</li> <li>Reviewers must click \"Review deployments\" and approve/reject</li> <li>If approved: Workflow continues with build/promotion</li> <li>If rejected: Workflow is cancelled</li> </ol>"},{"location":"versioning/#reviewing-a-release","title":"Reviewing a Release","text":"<p>Before approving a pre-release:</p> <ul> <li> Version number is correct based on commits</li> <li> All tests passed</li> <li> No critical issues in commits</li> <li> CHANGELOG will be updated</li> <li> Pre-release type matches intent (rc/beta/alpha)</li> </ul> <p>Before approving a stable release:</p> <ul> <li> Pre-release was tested successfully</li> <li> No blocking issues reported</li> <li> Documentation is accurate</li> <li> All artifacts are present in pre-release</li> <li> Multiple reviewers agree (for production)</li> </ul>"},{"location":"versioning/#deployment-history","title":"Deployment History","text":"<p>GitHub tracks all deployments:</p> <ul> <li>Go to Settings \u2192 Environments \u2192 [Environment name]</li> <li>View deployment history showing:</li> <li>Who triggered the workflow</li> <li>Who approved/rejected</li> <li>When deployment occurred</li> <li>Links to workflow runs</li> </ul> <p>This creates a complete audit trail for compliance and security reviews.</p>"},{"location":"versioning/#emergency-releases","title":"Emergency Releases","text":"<p>For critical security fixes that need immediate release:</p> <ol> <li>Ensure multiple reviewers are available</li> <li>Follow normal process but expedite review</li> <li>Document reason in approval comments:</li> </ol> <pre><code>Approved: Critical security fix for CVE-2025-XXXX\nExpedited due to active exploitation\n</code></pre> <p>Never bypass approvals - instead, add emergency contacts as reviewers.</p>"},{"location":"versioning/#version-support-policy","title":"Version Support Policy","text":"<p>See SECURITY.md for the official support policy.</p> <p>General Policy:</p> <ul> <li>Latest minor version: Full support with security patches</li> <li>Previous minor version: Security patches only (6 months)</li> <li>Older versions: No support</li> </ul> <p>Example (current version: 0.2.x):</p> <ul> <li>\u2705 <code>0.2.x</code> - Fully supported</li> <li>\u26a0\ufe0f <code>0.1.x</code> - Security patches only (until July 2025)</li> <li>\u274c <code>&lt; 0.1</code> - No support</li> </ul>"},{"location":"versioning/#troubleshooting","title":"Troubleshooting","text":""},{"location":"versioning/#version-not-updating","title":"Version Not Updating","text":"<p>Problem: Ran pre-release workflow but version didn't change</p> <p>Causes:</p> <ol> <li>No version-bumping commits since last tag</li> <li>Solution: Ensure you have <code>feat:</code> or <code>fix:</code> commits</li> <li>Only <code>chore:</code> or <code>docs:</code> commits</li> <li>Solution: These don't trigger version bumps by design</li> </ol> <p>Check commits:</p> <pre><code># See commits since last tag\ngit log $(git describe --tags --abbrev=0)..HEAD --oneline\n\n# Check commit types\ngit log $(git describe --tags --abbrev=0)..HEAD --pretty=format:\"%s\"\n</code></pre>"},{"location":"versioning/#build-has-wrong-version","title":"Build Has Wrong Version","text":"<p>Problem: Built binary shows wrong version</p> <p>Solution:</p> <pre><code># Ensure VERSION file is up to date\ncat internal/version/VERSION\n\n# Rebuild completely\nmise run clean\nmise run build\n\n# Verify\n./dist/uptool --version\n</code></pre>"},{"location":"versioning/#documentation-out-of-sync","title":"Documentation Out of Sync","text":"<p>Problem: README shows different version than binary</p> <p>Solution:</p> <pre><code># Run bump-my-version manually\nbump-my-version bump --new-version \"0.2.0\" patch\n\n# Check git diff\ngit diff\n\n# Commit if correct\ngit add .\ngit commit -m \"chore: sync version across files\"\n</code></pre>"},{"location":"versioning/#best-practices","title":"Best Practices","text":""},{"location":"versioning/#1-use-conventional-commits","title":"1. Use Conventional Commits","text":"<p>Always follow the conventional commit format:</p> <pre><code># Good\ngit commit -m \"feat(npm): add peer dependencies support\"\ngit commit -m \"fix(helm): handle missing Chart.lock\"\n\n# Bad\ngit commit -m \"added feature\"\ngit commit -m \"bug fix\"\n</code></pre>"},{"location":"versioning/#2-meaningful-commit-messages","title":"2. Meaningful Commit Messages","text":"<p>Include context in the commit body:</p> <pre><code>git commit -m \"feat(terraform): add provider version updates\n\nPreviously only module versions were updated. This adds support for\nupdating provider versions in required_providers blocks.\n\nCloses #123\"\n</code></pre>"},{"location":"versioning/#3-test-before-pre-release","title":"3. Test Before Pre-Release","text":"<p>Before creating a pre-release:</p> <pre><code># Run full test suite\nmise run check\n\n# Test locally\nmise run build\n./dist/uptool scan\n./dist/uptool plan\n</code></pre>"},{"location":"versioning/#4-verify-pre-release-before-promoting","title":"4. Verify Pre-Release Before Promoting","text":"<p>Before promoting to stable:</p> <ol> <li>Download and test pre-release artifacts</li> <li>Run integration tests</li> <li>Check documentation accuracy</li> <li>Verify GitHub Action works</li> </ol>"},{"location":"versioning/#5-document-breaking-changes","title":"5. Document Breaking Changes","text":"<p>For major version bumps, provide migration guidance:</p> <pre><code>git commit -m \"feat!: redesign configuration format\n\nBREAKING CHANGE: Configuration format changed from version 1 to 2.\nSee docs/migration/v1-to-v2.md for upgrade guide.\n\nOld format:\n  integrations:\n    - name: npm\n\nNew format:\n  integrations:\n    - id: npm\n      enabled: true\n\"\n</code></pre>"},{"location":"versioning/#reference","title":"Reference","text":""},{"location":"versioning/#workflow-inputs","title":"Workflow Inputs","text":"<p>Pre-Release Workflow:</p> <ul> <li><code>prerelease_type</code>: <code>rc</code> | <code>beta</code> | <code>alpha</code></li> </ul> <p>Promote Workflow:</p> <ul> <li><code>pre_release_tag</code>: Tag to promote (e.g., <code>v0.2.0-rc.1</code>)</li> </ul>"},{"location":"versioning/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>VERSION</code> - Current version (in workflows)</li> <li><code>NEW_VERSION</code> - Calculated next version (in workflows)</li> <li><code>NEW_TAG</code> - Git tag with <code>v</code> prefix (in workflows)</li> </ul>"},{"location":"versioning/#commands","title":"Commands","text":"<pre><code># Show version\nmise run version-show\n\n# Bump versions locally\nmise run version-bump-patch\nmise run version-bump-minor\nmise run version-bump-major\n\n# View workflow runs\ngh run list --workflow=pre-release.yml\ngh run list --workflow=promote-release.yml\n\n# Trigger pre-release\ngh workflow run pre-release.yml -f prerelease_type=rc\n\n# Trigger promotion\ngh workflow run promote-release.yml -f pre_release_tag=v0.2.0-rc.1\n</code></pre>"},{"location":"versioning/#see-also","title":"See Also","text":"<ul> <li>GitHub Environments Setup Guide - Configure approval gates for releases</li> <li>Conventional Commits Specification</li> <li>Semantic Versioning</li> <li>Keep a Changelog</li> <li>git-cliff Documentation</li> <li>bump-my-version Documentation</li> <li>GitHub Environments Documentation</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#scripts","title":"scripts","text":"<pre><code>import \"github.com/santosr2/uptool/scripts\"\n</code></pre> <p>Command gen_integrations generates the all.go file that imports all integrations. This ensures that adding a new integration doesn't require manual updates.</p> <p>Usage:</p> <pre><code>go run scripts/gen_integrations.go\n</code></pre> <p>Or via go generate:</p> <pre><code>go generate ./internal/integrations\n</code></pre>"},{"location":"api/#index","title":"Index","text":""},{"location":"api/#uptool","title":"uptool","text":"<pre><code>import \"github.com/santosr2/uptool/cmd/uptool\"\n</code></pre> <p>uptool is a manifest-first dependency updater for multiple ecosystems. It scans repositories for dependency manifest files \\(package.json, Chart.yaml, .pre\\-commit\\-config.yaml, etc.\\), checks for available updates, and rewrites manifests with new versions while preserving formatting.</p>"},{"location":"api/#index_1","title":"Index","text":""},{"location":"api/#datasource","title":"datasource","text":"<pre><code>import \"github.com/santosr2/uptool/internal/datasource\"\n</code></pre> <p>Package datasource provides a unified interface for querying package registries. This abstraction allows multiple integrations to share the same registry client.</p>"},{"location":"api/#index_2","title":"Index","text":"<ul> <li>func List() []string</li> <li>func Register\\(ds Datasource\\)</li> <li>type Datasource</li> <li>func Get\\(name string\\) \\(Datasource, error\\)</li> <li>type GitHubDatasource</li> <li>func NewGitHubDatasource() *GitHubDatasource</li> <li>func \\(d \\*GitHubDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) Name() string</li> <li>type HelmDatasource</li> <li>func NewHelmDatasource() *HelmDatasource</li> <li>func \\(d \\*HelmDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*HelmDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*HelmDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*HelmDatasource\\) Name() string</li> <li>type NPMDatasource</li> <li>func NewNPMDatasource() *NPMDatasource</li> <li>func \\(d \\*NPMDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*NPMDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*NPMDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*NPMDatasource\\) Name() string</li> <li>type PackageInfo</li> <li>type TerraformDatasource</li> <li>func NewTerraformDatasource() *TerraformDatasource</li> <li>func \\(d \\*TerraformDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) Name() string</li> <li>type VersionInfo</li> </ul>"},{"location":"api/#func-list","title":"func List","text":"<pre><code>func List() []string\n</code></pre> <p>List returns all registered datasource names.</p> <p></p>"},{"location":"api/#func-register","title":"func Register","text":"<pre><code>func Register(ds Datasource)\n</code></pre> <p>Register adds a datasource to the global registry.</p> <p></p>"},{"location":"api/#type-datasource","title":"type Datasource","text":"<p>Datasource represents a package registry or version source.</p> <pre><code>type Datasource interface {\n    // Name returns the datasource identifier (e.g., \"npm\", \"pypi\", \"github-releases\")\n    Name() string\n\n    // GetLatestVersion returns the latest stable version for a package.\n    GetLatestVersion(ctx context.Context, pkg string) (string, error)\n\n    // GetVersions returns all available versions for a package.\n    GetVersions(ctx context.Context, pkg string) ([]string, error)\n\n    // GetPackageInfo returns detailed information about a package.\n    GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n}\n</code></pre> <p></p>"},{"location":"api/#func-get","title":"func Get","text":"<pre><code>func Get(name string) (Datasource, error)\n</code></pre> <p>Get returns a datasource by name.</p> <p></p>"},{"location":"api/#type-githubdatasource","title":"type GitHubDatasource","text":"<p>GitHubDatasource implements the Datasource interface for GitHub Releases.</p> <pre><code>type GitHubDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgithubdatasource","title":"func NewGitHubDatasource","text":"<pre><code>func NewGitHubDatasource() *GitHubDatasource\n</code></pre> <p>NewGitHubDatasource creates a new GitHub datasource.</p> <p></p>"},{"location":"api/#func-githubdatasource-getlatestversion","title":"func \\(\\*GitHubDatasource\\) GetLatestVersion","text":"<pre><code>func (d *GitHubDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable release for a GitHub repository.</p> <p></p>"},{"location":"api/#func-githubdatasource-getpackageinfo","title":"func \\(\\*GitHubDatasource\\) GetPackageInfo","text":"<pre><code>func (d *GitHubDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a GitHub repository's releases.</p> <p></p>"},{"location":"api/#func-githubdatasource-getversions","title":"func \\(\\*GitHubDatasource\\) GetVersions","text":"<pre><code>func (d *GitHubDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available releases for a GitHub repository.</p> <p></p>"},{"location":"api/#func-githubdatasource-name","title":"func \\(\\*GitHubDatasource\\) Name","text":"<pre><code>func (d *GitHubDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-helmdatasource","title":"type HelmDatasource","text":"<p>HelmDatasource implements the Datasource interface for Helm chart repositories.</p> <pre><code>type HelmDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newhelmdatasource","title":"func NewHelmDatasource","text":"<pre><code>func NewHelmDatasource() *HelmDatasource\n</code></pre> <p>NewHelmDatasource creates a new Helm datasource.</p> <p></p>"},{"location":"api/#func-helmdatasource-getlatestversion","title":"func \\(\\*HelmDatasource\\) GetLatestVersion","text":"<pre><code>func (d *HelmDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-getpackageinfo","title":"func \\(\\*HelmDatasource\\) GetPackageInfo","text":"<pre><code>func (d *HelmDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-getversions","title":"func \\(\\*HelmDatasource\\) GetVersions","text":"<pre><code>func (d *HelmDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-name","title":"func \\(\\*HelmDatasource\\) Name","text":"<pre><code>func (d *HelmDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-npmdatasource","title":"type NPMDatasource","text":"<p>NPMDatasource implements the Datasource interface for the npm registry.</p> <pre><code>type NPMDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newnpmdatasource","title":"func NewNPMDatasource","text":"<pre><code>func NewNPMDatasource() *NPMDatasource\n</code></pre> <p>NewNPMDatasource creates a new npm datasource.</p> <p></p>"},{"location":"api/#func-npmdatasource-getlatestversion","title":"func \\(\\*NPMDatasource\\) GetLatestVersion","text":"<pre><code>func (d *NPMDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-getpackageinfo","title":"func \\(\\*NPMDatasource\\) GetPackageInfo","text":"<pre><code>func (d *NPMDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-getversions","title":"func \\(\\*NPMDatasource\\) GetVersions","text":"<pre><code>func (d *NPMDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-name","title":"func \\(\\*NPMDatasource\\) Name","text":"<pre><code>func (d *NPMDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-packageinfo","title":"type PackageInfo","text":"<p>PackageInfo contains metadata about a package.</p> <pre><code>type PackageInfo struct {\n    Name        string\n    Description string\n    Homepage    string\n    Repository  string\n    Versions    []VersionInfo\n}\n</code></pre> <p></p>"},{"location":"api/#type-terraformdatasource","title":"type TerraformDatasource","text":"<p>TerraformDatasource implements the Datasource interface for the Terraform Registry.</p> <pre><code>type TerraformDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newterraformdatasource","title":"func NewTerraformDatasource","text":"<pre><code>func NewTerraformDatasource() *TerraformDatasource\n</code></pre> <p>NewTerraformDatasource creates a new Terraform datasource.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getlatestversion","title":"func \\(\\*TerraformDatasource\\) GetLatestVersion","text":"<pre><code>func (d *TerraformDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getpackageinfo","title":"func \\(\\*TerraformDatasource\\) GetPackageInfo","text":"<pre><code>func (d *TerraformDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getversions","title":"func \\(\\*TerraformDatasource\\) GetVersions","text":"<pre><code>func (d *TerraformDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-name","title":"func \\(\\*TerraformDatasource\\) Name","text":"<pre><code>func (d *TerraformDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-versioninfo","title":"type VersionInfo","text":"<p>VersionInfo contains metadata about a specific version.</p> <pre><code>type VersionInfo struct {\n    Version      string\n    PublishedAt  string\n    IsPrerelease bool\n    Deprecated   bool\n}\n</code></pre>"},{"location":"api/#engine","title":"engine","text":"<pre><code>import \"github.com/santosr2/uptool/internal/engine\"\n</code></pre> <p>Package engine provides the core orchestration layer for uptool. It manages integration registration, manifest scanning, update planning, and update application. The Engine coordinates concurrent operations across multiple integrations while handling errors and logging.</p> <p>Package engine provides the core orchestration layer for uptool's dependency scanning and updating. It defines the fundamental types and interfaces used across all integrations, including Manifest, Dependency, UpdatePlan, and the Integration interface.</p>"},{"location":"api/#index_3","title":"Index","text":"<ul> <li>type ApplyResult</li> <li>type Dependency</li> <li>type Engine</li> <li>func NewEngine\\(logger \\*slog.Logger\\) *Engine</li> <li>func \\(e \\*Engine\\) GetIntegration\\(name string\\) \\(Integration, bool\\)</li> <li>func \\(e \\*Engine\\) ListIntegrations() []string</li> <li>func \\(e \\*Engine\\) Plan\\(ctx context.Context, manifests \\[\\]\\*Manifest\\) \\(\\*PlanResult, error\\)</li> <li>func \\(e \\*Engine\\) Register\\(integration Integration\\)</li> <li>func \\(e \\*Engine\\) Scan\\(ctx context.Context, repoRoot string, only, exclude \\[\\]string\\) \\(\\*ScanResult, error\\)</li> <li>func \\(e \\*Engine\\) Update\\(ctx context.Context, plans \\[\\]\\*UpdatePlan, dryRun bool\\) \\(\\*UpdateResult, error\\)</li> <li>type Impact</li> <li>type Integration</li> <li>type IntegrationPolicy</li> <li>type Manifest</li> <li>type PlanResult</li> <li>type ScanResult</li> <li>type Update</li> <li>type UpdatePlan</li> <li>type UpdateResult</li> </ul>"},{"location":"api/#type-applyresult","title":"type ApplyResult","text":"<p>ApplyResult contains the outcome of applying updates.</p> <pre><code>type ApplyResult struct {\n    Manifest     *Manifest `json:\"manifest\"`\n    ManifestDiff string    `json:\"manifest_diff,omitempty\"`\n    LockfileDiff string    `json:\"lockfile_diff,omitempty\"`\n    Errors       []string  `json:\"errors,omitempty\"`\n    Applied      int       `json:\"applied\"`\n    Failed       int       `json:\"failed\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependency","title":"type Dependency","text":"<p>Dependency represents a single dependency in a manifest.</p> <pre><code>type Dependency struct {\n    Name           string `json:\"name\"`\n    CurrentVersion string `json:\"current_version\"`\n    Constraint     string `json:\"constraint,omitempty\"`\n    Type           string `json:\"type\"` // direct, dev, peer, optional\n    Registry       string `json:\"registry,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-engine","title":"type Engine","text":"<p>Engine orchestrates the scan, plan, and update operations.</p> <pre><code>type Engine struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newengine","title":"func NewEngine","text":"<pre><code>func NewEngine(logger *slog.Logger) *Engine\n</code></pre> <p>NewEngine creates a new engine with the given integrations.</p> <p></p>"},{"location":"api/#func-engine-getintegration","title":"func \\(\\*Engine\\) GetIntegration","text":"<pre><code>func (e *Engine) GetIntegration(name string) (Integration, bool)\n</code></pre> <p>GetIntegration retrieves a registered integration by name.</p> <p></p>"},{"location":"api/#func-engine-listintegrations","title":"func \\(\\*Engine\\) ListIntegrations","text":"<pre><code>func (e *Engine) ListIntegrations() []string\n</code></pre> <p>ListIntegrations returns all registered integration names.</p> <p></p>"},{"location":"api/#func-engine-plan","title":"func \\(\\*Engine\\) Plan","text":"<pre><code>func (e *Engine) Plan(ctx context.Context, manifests []*Manifest) (*PlanResult, error)\n</code></pre> <p>Plan generates update plans for all manifests.</p> <p></p>"},{"location":"api/#func-engine-register","title":"func \\(\\*Engine\\) Register","text":"<pre><code>func (e *Engine) Register(integration Integration)\n</code></pre> <p>Register adds an integration to the engine.</p> <p></p>"},{"location":"api/#func-engine-scan","title":"func \\(\\*Engine\\) Scan","text":"<pre><code>func (e *Engine) Scan(ctx context.Context, repoRoot string, only, exclude []string) (*ScanResult, error)\n</code></pre> <p>Scan discovers all manifests across registered integrations.</p> <p></p>"},{"location":"api/#func-engine-update","title":"func \\(\\*Engine\\) Update","text":"<pre><code>func (e *Engine) Update(ctx context.Context, plans []*UpdatePlan, dryRun bool) (*UpdateResult, error)\n</code></pre> <p>Update applies update plans.</p> <p></p>"},{"location":"api/#type-impact","title":"type Impact","text":"<p>Impact describes the severity of an update.</p> <pre><code>type Impact string\n</code></pre> <p>Impact levels for update severity</p> <pre><code>const (\n    ImpactNone  Impact = \"none\"\n    ImpactPatch Impact = \"patch\"\n    ImpactMinor Impact = \"minor\"\n    ImpactMajor Impact = \"major\"\n)\n</code></pre> <p></p>"},{"location":"api/#type-integration","title":"type Integration","text":"<p>Integration defines the interface for ecosystem integrations.</p> <pre><code>type Integration interface {\n    // Name returns the integration identifier\n    Name() string\n\n    // Detect finds manifest files for this integration\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n\n    // Plan determines available updates for a manifest\n    Plan(ctx context.Context, manifest *Manifest) (*UpdatePlan, error)\n\n    // Apply executes the update plan\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n\n    // Validate checks if changes are valid (optional)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p></p>"},{"location":"api/#type-integrationpolicy","title":"type IntegrationPolicy","text":"<p>IntegrationPolicy contains policy settings that apply to a specific integration.</p> <pre><code>type IntegrationPolicy struct {\n    Custom          map[string]interface{} `yaml:\",inline\" json:\"custom,omitempty\"`\n    Update          string                 `yaml:\"update\" json:\"update\"`\n    Cadence         string                 `yaml:\"cadence,omitempty\" json:\"cadence,omitempty\"`\n    Enabled         bool                   `yaml:\"enabled\" json:\"enabled\"`\n    AllowPrerelease bool                   `yaml:\"allow_prerelease\" json:\"allow_prerelease\"`\n    Pin             bool                   `yaml:\"pin\" json:\"pin\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-manifest","title":"type Manifest","text":"<p>Manifest represents a dependency manifest file.</p> <pre><code>type Manifest struct {\n    Metadata     map[string]interface{} `json:\"metadata,omitempty\"`\n    Path         string                 `json:\"path\"`\n    Type         string                 `json:\"type\"`\n    Dependencies []Dependency           `json:\"dependencies\"`\n    Content      []byte                 `json:\"-\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-planresult","title":"type PlanResult","text":"<p>PlanResult aggregates all update plans.</p> <pre><code>type PlanResult struct {\n    Plans     []*UpdatePlan `json:\"plans\"`\n    Timestamp time.Time     `json:\"timestamp\"`\n    Errors    []string      `json:\"errors,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-scanresult","title":"type ScanResult","text":"<p>ScanResult aggregates all discovered manifests.</p> <pre><code>type ScanResult struct {\n    Manifests []*Manifest `json:\"manifests\"`\n    Timestamp time.Time   `json:\"timestamp\"`\n    RepoRoot  string      `json:\"repo_root\"`\n    Errors    []string    `json:\"errors,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-update","title":"type Update","text":"<p>Update represents a planned update for a dependency.</p> <pre><code>type Update struct {\n    Dependency    Dependency `json:\"dependency\"`\n    TargetVersion string     `json:\"target_version\"`\n    Impact        string     `json:\"impact\"` // patch, minor, major\n    ChangelogURL  string     `json:\"changelog_url,omitempty\"`\n    Breaking      bool       `json:\"breaking\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updateplan","title":"type UpdatePlan","text":"<p>UpdatePlan describes planned updates for a manifest.</p> <pre><code>type UpdatePlan struct {\n    Manifest *Manifest `json:\"manifest\"`\n    Strategy string    `json:\"strategy\"`\n    Updates  []Update  `json:\"updates\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updateresult","title":"type UpdateResult","text":"<p>UpdateResult aggregates all apply results.</p> <pre><code>type UpdateResult struct {\n    Results   []*ApplyResult `json:\"results\"`\n    Timestamp time.Time      `json:\"timestamp\"`\n    Errors    []string       `json:\"errors,omitempty\"`\n}\n</code></pre>"},{"location":"api/#integrations","title":"integrations","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations\"\n</code></pre> <p>Package integrations provides metadata about available integrations.</p> <p>Package integrations provides a central registry for all integration implementations. Integrations can be built-in \\(compiled into the binary\\) or external \\(loaded as plugins\\).</p>"},{"location":"api/#index_4","title":"Index","text":"<ul> <li>func ClearCache()</li> <li>func Count() int</li> <li>func Get\\(name string\\) \\(engine.Integration, error\\)</li> <li>func GetAll() map[string]engine.Integration</li> <li>func GetLazy() map[string]func() engine.Integration</li> <li>func IsDisabled\\(name string\\) bool</li> <li>func IsExperimental\\(name string\\) bool</li> <li>func List() []string</li> <li>func ListByCategory\\(category string\\) \\(map\\[string\\]Metadata, error\\)</li> <li>func ListIntegrations() \\(map\\[string\\]Metadata, error\\)</li> <li>func Register\\(name string, constructor func\\(\\) engine.Integration)</li> <li>func ReloadPlugins() error</li> <li>type CategoryMetadata</li> <li>type DatasourceMetadata</li> <li>type Metadata</li> <li>func GetMetadata\\(name string\\) \\(\\*Metadata, error\\)</li> <li>type RegistryMetadata</li> <li>func LoadMetadata() \\(\\*RegistryMetadata, error\\)</li> </ul>"},{"location":"api/#func-clearcache","title":"func ClearCache","text":"<pre><code>func ClearCache()\n</code></pre> <p>ClearCache clears all cached instances, forcing reinitialization on next access. Useful for testing or when integrations need to be refreshed.</p> <p></p>"},{"location":"api/#func-count","title":"func Count","text":"<pre><code>func Count() int\n</code></pre> <p>Count returns the number of registered integrations.</p> <p></p>"},{"location":"api/#func-get_1","title":"func Get","text":"<pre><code>func Get(name string) (engine.Integration, error)\n</code></pre> <p>Get returns a single integration by name, creating it lazily if needed. This is more efficient than GetAll() when you only need specific integrations.</p> <p></p>"},{"location":"api/#func-getall","title":"func GetAll","text":"<pre><code>func GetAll() map[string]engine.Integration\n</code></pre> <p>GetAll returns a map of all registered integrations. Uses lazy loading - only creates instances for integrations that haven't been created yet.</p> <p></p>"},{"location":"api/#func-getlazy","title":"func GetLazy","text":"<pre><code>func GetLazy() map[string]func() engine.Integration\n</code></pre> <p>GetLazy returns a map of constructors \\(not instances\\). Use this when you want to defer instantiation until actual use.</p> <p></p>"},{"location":"api/#func-isdisabled","title":"func IsDisabled","text":"<pre><code>func IsDisabled(name string) bool\n</code></pre> <p>IsDisabled checks if an integration is disabled in the registry.</p> <p></p>"},{"location":"api/#func-isexperimental","title":"func IsExperimental","text":"<pre><code>func IsExperimental(name string) bool\n</code></pre> <p>IsExperimental checks if an integration is marked as experimental.</p> <p></p>"},{"location":"api/#func-list_1","title":"func List","text":"<pre><code>func List() []string\n</code></pre> <p>List returns a sorted list of all registered integration names.</p> <p></p>"},{"location":"api/#func-listbycategory","title":"func ListByCategory","text":"<pre><code>func ListByCategory(category string) (map[string]Metadata, error)\n</code></pre> <p>ListByCategory returns integrations grouped by category.</p> <p></p>"},{"location":"api/#func-listintegrations","title":"func ListIntegrations","text":"<pre><code>func ListIntegrations() (map[string]Metadata, error)\n</code></pre> <p>ListIntegrations returns a list of all integration names with their metadata.</p> <p></p>"},{"location":"api/#func-register_1","title":"func Register","text":"<pre><code>func Register(name string, constructor func() engine.Integration)\n</code></pre> <p>Register adds an integration constructor to the global registry. This is typically called from init() functions in integration packages.</p> <p>Example:</p> <pre><code>func init() {\n    integrations.Register(\"npm\", New)\n}\n</code></pre> <p></p>"},{"location":"api/#func-reloadplugins","title":"func ReloadPlugins","text":"<pre><code>func ReloadPlugins() error\n</code></pre> <p>ReloadPlugins clears the plugin loaded flag and reloads all plugins. This allows hot-reloading of plugins without restarting the application.</p> <p></p>"},{"location":"api/#type-categorymetadata","title":"type CategoryMetadata","text":"<p>CategoryMetadata contains information about an integration category.</p> <pre><code>type CategoryMetadata struct {\n    Name        string `yaml:\"name\"`\n    Description string `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-datasourcemetadata","title":"type DatasourceMetadata","text":"<p>DatasourceMetadata contains information about a datasource.</p> <pre><code>type DatasourceMetadata struct {\n    Name        string `yaml:\"name\"`\n    URL         string `yaml:\"url\"`\n    Type        string `yaml:\"type\"`\n    Description string `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-metadata","title":"type Metadata","text":"<p>Metadata contains information about an integration.</p> <pre><code>type Metadata struct {\n    DisplayName  string   `yaml:\"displayName\"`\n    Description  string   `yaml:\"description\"`\n    URL          string   `yaml:\"url\"`\n    Category     string   `yaml:\"category\"`\n    FilePatterns []string `yaml:\"filePatterns\"`\n    Datasources  []string `yaml:\"datasources\"`\n    Experimental bool     `yaml:\"experimental\"`\n    Disabled     bool     `yaml:\"disabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-getmetadata","title":"func GetMetadata","text":"<pre><code>func GetMetadata(name string) (*Metadata, error)\n</code></pre> <p>GetMetadata returns metadata for a specific integration.</p> <p></p>"},{"location":"api/#type-registrymetadata","title":"type RegistryMetadata","text":"<p>RegistryMetadata represents the full integrations.yaml structure.</p> <pre><code>type RegistryMetadata struct {\n    Integrations map[string]Metadata           `yaml:\"integrations\"`\n    Datasources  map[string]DatasourceMetadata `yaml:\"datasources\"`\n    Categories   map[string]CategoryMetadata   `yaml:\"categories\"`\n    Version      string                        `yaml:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-loadmetadata","title":"func LoadMetadata","text":"<pre><code>func LoadMetadata() (*RegistryMetadata, error)\n</code></pre> <p>LoadMetadata loads integration metadata from the integrations.yaml file.</p>"},{"location":"api/#policy","title":"policy","text":"<pre><code>import \"github.com/santosr2/uptool/internal/policy\"\n</code></pre> <p>Package policy handles configuration file parsing and policy management. It defines the structure for uptool.yaml configuration files, including integration-specific policies, update strategies, and organization-level governance settings.</p>"},{"location":"api/#index_5","title":"Index","text":"<ul> <li>func ValidateIntegrationPolicy\\(p \\*engine.IntegrationPolicy\\) error</li> <li>type AutoMergeConfig</li> <li>type Config</li> <li>func DefaultConfig() *Config</li> <li>func LoadConfig\\(path string\\) \\(\\*Config, error\\)</li> <li>func \\(c \\*Config\\) EnabledIntegrations() []string</li> <li>func \\(c \\*Config\\) ToPolicyMap() map[string]engine.IntegrationPolicy</li> <li>func \\(c \\*Config\\) Validate() error</li> <li>type IntegrationConfig</li> <li>type MatchConfig</li> <li>type OrgPolicy</li> <li>type SigningConfig</li> </ul>"},{"location":"api/#func-validateintegrationpolicy","title":"func ValidateIntegrationPolicy","text":"<pre><code>func ValidateIntegrationPolicy(p *engine.IntegrationPolicy) error\n</code></pre> <p>ValidateIntegrationPolicy checks that an integration policy is valid.</p> <p></p>"},{"location":"api/#type-automergeconfig","title":"type AutoMergeConfig","text":"<p>AutoMergeConfig controls automatic PR merging.</p> <pre><code>type AutoMergeConfig struct {\n    Guards  []string `yaml:\"guards\"`\n    Enabled bool     `yaml:\"enabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-config","title":"type Config","text":"<p>Config represents the uptool.yaml configuration file.</p> <pre><code>type Config struct {\n    OrgPolicy    *OrgPolicy          `yaml:\"org_policy,omitempty\"`\n    Integrations []IntegrationConfig `yaml:\"integrations\"`\n    Version      int                 `yaml:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-defaultconfig","title":"func DefaultConfig","text":"<pre><code>func DefaultConfig() *Config\n</code></pre> <p>DefaultConfig returns a default configuration with sensible defaults.</p> <p></p>"},{"location":"api/#func-loadconfig","title":"func LoadConfig","text":"<pre><code>func LoadConfig(path string) (*Config, error)\n</code></pre> <p>LoadConfig reads and parses the configuration file.</p> <p></p>"},{"location":"api/#func-config-enabledintegrations","title":"func \\(\\*Config\\) EnabledIntegrations","text":"<pre><code>func (c *Config) EnabledIntegrations() []string\n</code></pre> <p>EnabledIntegrations returns the IDs of all enabled integrations.</p> <p></p>"},{"location":"api/#func-config-topolicymap","title":"func \\(\\*Config\\) ToPolicyMap","text":"<pre><code>func (c *Config) ToPolicyMap() map[string]engine.IntegrationPolicy\n</code></pre> <p>ToPolicyMap converts the configuration into a map of integration policies.</p> <p></p>"},{"location":"api/#func-config-validate","title":"func \\(\\*Config\\) Validate","text":"<pre><code>func (c *Config) Validate() error\n</code></pre> <p>Validate checks that the configuration is valid.</p> <p></p>"},{"location":"api/#type-integrationconfig","title":"type IntegrationConfig","text":"<p>IntegrationConfig defines configuration for a specific integration.</p> <pre><code>type IntegrationConfig struct {\n    Match   *MatchConfig             `yaml:\"match,omitempty\"`\n    ID      string                   `yaml:\"id\"`\n    Policy  engine.IntegrationPolicy `yaml:\"policy\"`\n    Enabled bool                     `yaml:\"enabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-matchconfig","title":"type MatchConfig","text":"<p>MatchConfig specifies file patterns for integration detection.</p> <pre><code>type MatchConfig struct {\n    Files []string `yaml:\"files\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-orgpolicy","title":"type OrgPolicy","text":"<p>OrgPolicy contains organization-level policies and governance settings.</p> <pre><code>type OrgPolicy struct {\n    Signing            *SigningConfig   `yaml:\"signing,omitempty\"`\n    AutoMerge          *AutoMergeConfig `yaml:\"auto_merge,omitempty\"`\n    RequireSignoffFrom []string         `yaml:\"require_signoff_from,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-signingconfig","title":"type SigningConfig","text":"<p>SigningConfig controls artifact signing verification.</p> <pre><code>type SigningConfig struct {\n    CosignVerify bool `yaml:\"cosign_verify\"`\n}\n</code></pre>"},{"location":"api/#registry","title":"registry","text":"<pre><code>import \"github.com/santosr2/uptool/internal/registry\"\n</code></pre> <p>Package registry provides HTTP clients for querying package registries and release APIs. It includes clients for npm Registry, Terraform Registry, GitHub Releases, and Helm repositories, enabling version lookups and constraint-based version resolution.</p>"},{"location":"api/#index_6","title":"Index","text":"<ul> <li>func IsOCIRepository\\(repository string\\) bool</li> <li>func ParseGitHubURL\\(url string\\) \\(owner, repo string, err error\\)</li> <li>type ChartIndex</li> <li>type ChartIndexEntry</li> <li>type GitHubClient</li> <li>func NewGitHubClient\\(token string\\) *GitHubClient</li> <li>func \\(c \\*GitHubClient\\) FindBestRelease\\(ctx context.Context, owner, repo, constraint string, allowPrerelease bool\\) \\(string, error\\)</li> <li>func \\(c \\*GitHubClient\\) GetAllReleases\\(ctx context.Context, owner, repo string\\) \\(\\[\\]Release, error\\)</li> <li>func \\(c \\*GitHubClient\\) GetLatestRelease\\(ctx context.Context, owner, repo string\\) \\(string, error\\)</li> <li>type HelmClient</li> <li>func NewHelmClient() *HelmClient</li> <li>func \\(c \\*HelmClient\\) FindBestChartVersion\\(ctx context.Context, repository, chartName, constraint string\\) \\(string, error\\)</li> <li>func \\(c \\*HelmClient\\) GetChartVersionDetails\\(ctx context.Context, repository, chartName string\\) \\(\\[\\]ChartIndexEntry, error\\)</li> <li>func \\(c \\*HelmClient\\) GetChartVersions\\(ctx context.Context, repository, chartName string\\) \\(\\[\\]string, error\\)</li> <li>func \\(c \\*HelmClient\\) GetLatestChartVersion\\(ctx context.Context, repository, chartName string\\) \\(string, error\\)</li> <li>type Module</li> <li>type ModuleVersion</li> <li>type ModuleVersions</li> <li>type NPMClient</li> <li>func NewNPMClient() *NPMClient</li> <li>func \\(c \\*NPMClient\\) FindBestVersion\\(ctx context.Context, packageName, constraint string, allowPrerelease bool\\) \\(string, error\\)</li> <li>func \\(c \\*NPMClient\\) GetLatestVersion\\(ctx context.Context, packageName string\\) \\(string, error\\)</li> <li>func \\(c \\*NPMClient\\) GetPackageInfo\\(ctx context.Context, packageName string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(c \\*NPMClient\\) GetVersions\\(ctx context.Context, packageName string\\) \\(\\[\\]string, error\\)</li> <li>type PackageInfo</li> <li>type ProviderVersion</li> <li>type ProviderVersions</li> <li>type Release</li> <li>type TerraformClient</li> <li>func NewTerraformClient() *TerraformClient</li> <li>func \\(c \\*TerraformClient\\) FindBestProviderVersion\\(ctx context.Context, source, constraint string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetLatestModuleVersion\\(ctx context.Context, source string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetLatestProviderVersion\\(ctx context.Context, source string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetModuleVersions\\(ctx context.Context, source string\\) \\(\\[\\]ModuleVersion, error\\)</li> </ul>"},{"location":"api/#func-isocirepository","title":"func IsOCIRepository","text":"<pre><code>func IsOCIRepository(repository string) bool\n</code></pre> <p>IsOCIRepository checks if a repository URL is an OCI registry.</p> <p></p>"},{"location":"api/#func-parsegithuburl","title":"func ParseGitHubURL","text":"<pre><code>func ParseGitHubURL(url string) (owner, repo string, err error)\n</code></pre> <p>ParseGitHubURL extracts owner and repo from a GitHub URL. Supports: - https://github.com/owner/repo - github.com/owner/repo - owner/repo</p> <p></p>"},{"location":"api/#type-chartindex","title":"type ChartIndex","text":"<p>ChartIndex represents the index.yaml structure from a Helm repository.</p> <pre><code>type ChartIndex struct {\n    Entries    map[string][]ChartIndexEntry `yaml:\"entries\"`\n    APIVersion string                       `yaml:\"apiVersion\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-chartindexentry","title":"type ChartIndexEntry","text":"<p>ChartIndexEntry represents a single chart version entry.</p> <pre><code>type ChartIndexEntry struct {\n    Created     time.Time `yaml:\"created\"`\n    Name        string    `yaml:\"name\"`\n    Version     string    `yaml:\"version\"`\n    AppVersion  string    `yaml:\"appVersion\"`\n    Description string    `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-githubclient","title":"type GitHubClient","text":"<p>GitHubClient queries GitHub API for release information.</p> <pre><code>type GitHubClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgithubclient","title":"func NewGitHubClient","text":"<pre><code>func NewGitHubClient(token string) *GitHubClient\n</code></pre> <p>NewGitHubClient creates a new GitHub API client. Token is optional but recommended to avoid rate limiting.</p> <p></p>"},{"location":"api/#func-githubclient-findbestrelease","title":"func \\(\\*GitHubClient\\) FindBestRelease","text":"<pre><code>func (c *GitHubClient) FindBestRelease(ctx context.Context, owner, repo, constraint string, allowPrerelease bool) (string, error)\n</code></pre> <p>FindBestRelease finds the best release matching a constraint.</p> <p></p>"},{"location":"api/#func-githubclient-getallreleases","title":"func \\(\\*GitHubClient\\) GetAllReleases","text":"<pre><code>func (c *GitHubClient) GetAllReleases(ctx context.Context, owner, repo string) ([]Release, error)\n</code></pre> <p>GetAllReleases fetches all releases for a repository.</p> <p></p>"},{"location":"api/#func-githubclient-getlatestrelease","title":"func \\(\\*GitHubClient\\) GetLatestRelease","text":"<pre><code>func (c *GitHubClient) GetLatestRelease(ctx context.Context, owner, repo string) (string, error)\n</code></pre> <p>GetLatestRelease fetches the latest non-prerelease release for a repository.</p> <p></p>"},{"location":"api/#type-helmclient","title":"type HelmClient","text":"<p>HelmClient queries Helm chart repositories.</p> <pre><code>type HelmClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newhelmclient","title":"func NewHelmClient","text":"<pre><code>func NewHelmClient() *HelmClient\n</code></pre> <p>NewHelmClient creates a new Helm chart repository client.</p> <p></p>"},{"location":"api/#func-helmclient-findbestchartversion","title":"func \\(\\*HelmClient\\) FindBestChartVersion","text":"<pre><code>func (c *HelmClient) FindBestChartVersion(ctx context.Context, repository, chartName, constraint string) (string, error)\n</code></pre> <p>FindBestChartVersion finds the best chart version matching a constraint.</p> <p></p>"},{"location":"api/#func-helmclient-getchartversiondetails","title":"func \\(\\*HelmClient\\) GetChartVersionDetails","text":"<pre><code>func (c *HelmClient) GetChartVersionDetails(ctx context.Context, repository, chartName string) ([]ChartIndexEntry, error)\n</code></pre> <p>GetChartVersionDetails returns all available versions with metadata for a chart from a repository.</p> <p></p>"},{"location":"api/#func-helmclient-getchartversions","title":"func \\(\\*HelmClient\\) GetChartVersions","text":"<pre><code>func (c *HelmClient) GetChartVersions(ctx context.Context, repository, chartName string) ([]string, error)\n</code></pre> <p>GetChartVersions returns all available versions for a chart.</p> <p></p>"},{"location":"api/#func-helmclient-getlatestchartversion","title":"func \\(\\*HelmClient\\) GetLatestChartVersion","text":"<pre><code>func (c *HelmClient) GetLatestChartVersion(ctx context.Context, repository, chartName string) (string, error)\n</code></pre> <p>GetLatestChartVersion fetches the latest version for a chart from a repository. repository: the base URL of the chart repository \\(e.g., \"https://charts.bitnami.com/bitnami\"\\) chartName: the name of the chart \\(e.g., \"postgresql\"\\)</p> <p></p>"},{"location":"api/#type-module","title":"type Module","text":"<p>Module represents a module with its versions.</p> <pre><code>type Module struct {\n    Source   string          `json:\"source\"`\n    Versions []ModuleVersion `json:\"versions\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-moduleversion","title":"type ModuleVersion","text":"<p>ModuleVersion represents a single module version.</p> <pre><code>type ModuleVersion struct {\n    Version string `json:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-moduleversions","title":"type ModuleVersions","text":"<p>ModuleVersions represents the response from /v1/modules/{namespace}/{name}/{provider}/versions.</p> <pre><code>type ModuleVersions struct {\n    Modules []Module `json:\"modules\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-npmclient","title":"type NPMClient","text":"<p>NPMClient queries the npm registry for package information.</p> <pre><code>type NPMClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newnpmclient","title":"func NewNPMClient","text":"<pre><code>func NewNPMClient() *NPMClient\n</code></pre> <p>NewNPMClient creates a new npm registry client.</p> <p></p>"},{"location":"api/#func-npmclient-findbestversion","title":"func \\(\\*NPMClient\\) FindBestVersion","text":"<pre><code>func (c *NPMClient) FindBestVersion(ctx context.Context, packageName, constraint string, allowPrerelease bool) (string, error)\n</code></pre> <p>FindBestVersion finds the best version matching a constraint.</p> <p></p>"},{"location":"api/#func-npmclient-getlatestversion","title":"func \\(\\*NPMClient\\) GetLatestVersion","text":"<pre><code>func (c *NPMClient) GetLatestVersion(ctx context.Context, packageName string) (string, error)\n</code></pre> <p>GetLatestVersion fetches the latest version for a package.</p> <p></p>"},{"location":"api/#func-npmclient-getpackageinfo","title":"func \\(\\*NPMClient\\) GetPackageInfo","text":"<pre><code>func (c *NPMClient) GetPackageInfo(ctx context.Context, packageName string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo fetches full package information from npm registry.</p> <p></p>"},{"location":"api/#func-npmclient-getversions","title":"func \\(\\*NPMClient\\) GetVersions","text":"<pre><code>func (c *NPMClient) GetVersions(ctx context.Context, packageName string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a package.</p> <p></p>"},{"location":"api/#type-packageinfo_1","title":"type PackageInfo","text":"<p>PackageInfo contains npm package metadata.</p> <pre><code>type PackageInfo struct {\n    Versions map[string]map[string]interface{} `json:\"versions\"`\n    DistTags map[string]string                 `json:\"dist-tags\"`\n    Time     map[string]string                 `json:\"time\"`\n    Name     string                            `json:\"name\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerversion","title":"type ProviderVersion","text":"<p>ProviderVersion represents a single provider version.</p> <pre><code>type ProviderVersion struct {\n    Version   string   `json:\"version\"`\n    Platforms []string `json:\"platforms\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerversions","title":"type ProviderVersions","text":"<p>ProviderVersions represents the response from /v1/providers/{namespace}/{type}/versions.</p> <pre><code>type ProviderVersions struct {\n    Versions []ProviderVersion `json:\"versions\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-release","title":"type Release","text":"<p>Release represents a GitHub release.</p> <pre><code>type Release struct {\n    TagName     string `json:\"tag_name\"`\n    Name        string `json:\"name\"`\n    CreatedAt   string `json:\"created_at\"`\n    PublishedAt string `json:\"published_at\"`\n    Draft       bool   `json:\"draft\"`\n    Prerelease  bool   `json:\"prerelease\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-terraformclient","title":"type TerraformClient","text":"<p>TerraformClient queries the Terraform Registry API.</p> <pre><code>type TerraformClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newterraformclient","title":"func NewTerraformClient","text":"<pre><code>func NewTerraformClient() *TerraformClient\n</code></pre> <p>NewTerraformClient creates a new Terraform Registry client.</p> <p></p>"},{"location":"api/#func-terraformclient-findbestproviderversion","title":"func \\(\\*TerraformClient\\) FindBestProviderVersion","text":"<pre><code>func (c *TerraformClient) FindBestProviderVersion(ctx context.Context, source, constraint string) (string, error)\n</code></pre> <p>FindBestProviderVersion finds the best provider version matching a constraint.</p> <p></p>"},{"location":"api/#func-terraformclient-getlatestmoduleversion","title":"func \\(\\*TerraformClient\\) GetLatestModuleVersion","text":"<pre><code>func (c *TerraformClient) GetLatestModuleVersion(ctx context.Context, source string) (string, error)\n</code></pre> <p>GetLatestModuleVersion fetches the latest version for a module. source format: \"namespace/name/provider\" \\(e.g., \"terraform\\-aws\\-modules/vpc/aws\"\\)</p> <p></p>"},{"location":"api/#func-terraformclient-getlatestproviderversion","title":"func \\(\\*TerraformClient\\) GetLatestProviderVersion","text":"<pre><code>func (c *TerraformClient) GetLatestProviderVersion(ctx context.Context, source string) (string, error)\n</code></pre> <p>GetLatestProviderVersion fetches the latest version for a provider. source format: \"namespace/name\" \\(e.g., \"hashicorp/aws\"\\)</p> <p></p>"},{"location":"api/#func-terraformclient-getmoduleversions","title":"func \\(\\*TerraformClient\\) GetModuleVersions","text":"<pre><code>func (c *TerraformClient) GetModuleVersions(ctx context.Context, source string) ([]ModuleVersion, error)\n</code></pre> <p>GetModuleVersions returns all available versions for a module. source format: \"namespace/name/provider\" \\(e.g., \"terraform\\-aws\\-modules/vpc/aws\"\\)</p>"},{"location":"api/#resolve","title":"resolve","text":"<pre><code>import \"github.com/santosr2/uptool/internal/resolve\"\n</code></pre> <p>Package resolve provides semantic version resolution and selection logic. It implements version constraint checking, policy-based version selection, and semantic version impact calculation \\(patch/minor/major\\).</p>"},{"location":"api/#index_7","title":"Index","text":"<ul> <li>func CompareVersions\\(v1, v2 string\\) \\(int, error\\)</li> <li>func IsValidSemver\\(version string\\) bool</li> <li>func SelectVersion\\(currentVersion string, availableVersions \\[\\]string, policy engine.IntegrationPolicy\\) \\(string, engine.Impact, error\\)</li> </ul>"},{"location":"api/#func-compareversions","title":"func CompareVersions","text":"<pre><code>func CompareVersions(v1, v2 string) (int, error)\n</code></pre> <p>CompareVersions returns -1 if v1 \\&lt; v2, 0 if v1 == v2, 1 if v1 &gt; v2.</p> <p></p>"},{"location":"api/#func-isvalidsemver","title":"func IsValidSemver","text":"<pre><code>func IsValidSemver(version string) bool\n</code></pre> <p>IsValidSemver checks if a string is a valid semver version.</p> <p></p>"},{"location":"api/#func-selectversion","title":"func SelectVersion","text":"<pre><code>func SelectVersion(currentVersion string, availableVersions []string, policy engine.IntegrationPolicy) (string, engine.Impact, error)\n</code></pre> <p>SelectVersion chooses the best version from a list based on policy. It filters versions by update strategy and prerelease policy, then returns the latest.</p>"},{"location":"api/#rewrite","title":"rewrite","text":"<pre><code>import \"github.com/santosr2/uptool/internal/rewrite\"\n</code></pre> <p>Package rewrite provides utilities for rewriting structured files while preserving formatting. It includes functions for YAML manipulation, unified diff generation, and patch creation, enabling integrations to update configuration files without destroying formatting or comments.</p>"},{"location":"api/#index_8","title":"Index","text":"<ul> <li>func CountChanges\\(diff string\\) \\(additions, deletions int\\)</li> <li>func GeneratePatch\\(filename, oldContent, newContent string\\) \\(string, error\\)</li> <li>func GenerateUnifiedDiff\\(filename, oldContent, newContent string\\) \\(string, error\\)</li> <li>func ReplaceYAMLValue\\(content string, path \\[\\]string, oldValue, newValue string, matcher func\\(\\*yaml.Node\\) bool) \\(string, error\\)</li> <li>func UpdateYAMLField\\(content string, path \\[\\]string, newValue string\\) \\(string, error\\)</li> </ul>"},{"location":"api/#func-countchanges","title":"func CountChanges","text":"<pre><code>func CountChanges(diff string) (additions, deletions int)\n</code></pre> <p>CountChanges returns the number of additions and deletions in a diff.</p> <p></p>"},{"location":"api/#func-generatepatch","title":"func GeneratePatch","text":"<pre><code>func GeneratePatch(filename, oldContent, newContent string) (string, error)\n</code></pre> <p>GeneratePatch creates a git-style patch with timestamps.</p> <p></p>"},{"location":"api/#func-generateunifieddiff","title":"func GenerateUnifiedDiff","text":"<pre><code>func GenerateUnifiedDiff(filename, oldContent, newContent string) (string, error)\n</code></pre> <p>GenerateUnifiedDiff creates a unified diff between old and new content.</p> <p></p>"},{"location":"api/#func-replaceyamlvalue","title":"func ReplaceYAMLValue","text":"<pre><code>func ReplaceYAMLValue(content string, path []string, oldValue, newValue string, matcher func(*yaml.Node) bool) (string, error)\n</code></pre> <p>ReplaceYAMLValue replaces a specific value in a YAML document while preserving formatting. path specifies the location \\(e.g., \\[\"repos\", \"\\*\", \"rev\"\\]\\) where * matches any element. matcher is an optional function to further filter which nodes to update.</p> <p></p>"},{"location":"api/#func-updateyamlfield","title":"func UpdateYAMLField","text":"<pre><code>func UpdateYAMLField(content string, path []string, newValue string) (string, error)\n</code></pre> <p>UpdateYAMLField updates a specific field in a YAML document.</p>"},{"location":"api/#secureio","title":"secureio","text":"<pre><code>import \"github.com/santosr2/uptool/internal/secureio\"\n</code></pre> <p>Package secureio provides secure file I/O operations with path validation.</p>"},{"location":"api/#index_9","title":"Index","text":"<ul> <li>func Create\\(path string\\) \\(\\*os.File, error\\)</li> <li>func ReadFile\\(path string\\) \\(\\[\\]byte, error\\)</li> <li>func ValidateFilePath\\(path string\\) error</li> <li>func WriteFile\\(path string, data \\[\\]byte, perm os.FileMode\\) error</li> </ul>"},{"location":"api/#func-create","title":"func Create","text":"<pre><code>func Create(path string) (*os.File, error)\n</code></pre> <p>Create safely creates a file after validating the path</p> <p></p>"},{"location":"api/#func-readfile","title":"func ReadFile","text":"<pre><code>func ReadFile(path string) ([]byte, error)\n</code></pre> <p>ReadFile safely reads a file after validating the path</p> <p></p>"},{"location":"api/#func-validatefilepath","title":"func ValidateFilePath","text":"<pre><code>func ValidateFilePath(path string) error\n</code></pre> <p>ValidateFilePath validates that a file path is safe to read/write</p> <p></p>"},{"location":"api/#func-writefile","title":"func WriteFile","text":"<pre><code>func WriteFile(path string, data []byte, perm os.FileMode) error\n</code></pre> <p>WriteFile safely writes a file after validating the path</p>"},{"location":"api/#version","title":"version","text":"<pre><code>import \"github.com/santosr2/uptool/internal/version\"\n</code></pre> <p>Package version provides version information for uptool. The version is embedded from the VERSION file at the repository root.</p>"},{"location":"api/#index_10","title":"Index","text":"<ul> <li>func Get() string</li> </ul>"},{"location":"api/#func-get_2","title":"func Get","text":"<pre><code>func Get() string\n</code></pre> <p>Get returns the current uptool version.</p>"},{"location":"api/#cmd","title":"cmd","text":"<pre><code>import \"github.com/santosr2/uptool/cmd/uptool/cmd\"\n</code></pre> <p>Package cmd implements the command-line interface for uptool. It provides commands for scanning, planning, and updating dependency manifests across multiple ecosystems \\(npm, Helm, Terraform, pre\\-commit, asdf, mise, tflint\\).</p> <p>The CLI is built using Cobra and provides the following commands:</p> <ul> <li>scan: Discover all manifests in a repository</li> <li>plan: Generate an update plan showing available dependency updates</li> <li>update: Apply updates to manifest files</li> <li>list: List all supported integrations and their status</li> <li>completion: Generate shell completion scripts</li> </ul> <p>Global flags available across all commands:</p> <ul> <li>-v, --verbose: Enable verbose debug output</li> <li>-q, --quiet: Suppress informational output \\(errors only\\)</li> </ul> <p>Example usage:</p> <pre><code># Scan repository for manifests\nuptool scan\n\n# Generate update plan\nuptool plan\n\n# Apply updates (dry-run first)\nuptool update --dry-run --diff\nuptool update\n\n# Update only specific integrations\nuptool update --only=npm,helm\n</code></pre> <p>See individual command documentation for detailed usage and options.</p>"},{"location":"api/#index_11","title":"Index","text":"<ul> <li>func Execute() error</li> <li>func GetLogLevel() slog.Level</li> </ul>"},{"location":"api/#func-execute","title":"func Execute","text":"<pre><code>func Execute() error\n</code></pre> <p>Execute runs the root command</p> <p></p>"},{"location":"api/#func-getloglevel","title":"func GetLogLevel","text":"<pre><code>func GetLogLevel() slog.Level\n</code></pre> <p>GetLogLevel returns the current log level based on flags</p>"},{"location":"api/#python","title":"python","text":"<pre><code>import \"github.com/santosr2/uptool/examples/plugins/python\"\n</code></pre> <p>Package main implements an uptool plugin for Python requirements.txt dependencies. This plugin demonstrates the external plugin architecture for uptool.</p>"},{"location":"api/#index_12","title":"Index","text":"<ul> <li>func New() engine.Integration</li> <li>func ParseRequirements\\(content string\\) \\(\\[\\]\\*engine.Dependency, error\\)</li> <li>func RegisterWith\\(register func\\(name string, constructor func\\(\\) engine.Integration))</li> <li>type Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type PyPIClient</li> <li>func NewPyPIClient() *PyPIClient</li> <li>func \\(c \\*PyPIClient\\) GetLatestVersion\\(ctx context.Context, packageName string\\) \\(string, error\\)</li> <li>type PyPIResponse</li> </ul>"},{"location":"api/#func-new","title":"func New","text":"<pre><code>func New() engine.Integration\n</code></pre> <p>New creates a new Python integration instance.</p> <p></p>"},{"location":"api/#func-parserequirements","title":"func ParseRequirements","text":"<pre><code>func ParseRequirements(content string) ([]*engine.Dependency, error)\n</code></pre> <p>ParseRequirements parses a requirements.txt file and extracts dependencies. It handles: - Simple version pins \\(package==1.0.0\\) - Version constraints \\(package\\&gt;=1.0.0\\) - Comments \\(\\# comment\\) - Blank lines - Extras \\(package\\[extra\\]==1.0.0\\)</p> <p></p>"},{"location":"api/#func-registerwith","title":"func RegisterWith","text":"<pre><code>func RegisterWith(register func(name string, constructor func() engine.Integration))\n</code></pre> <p>RegisterWith is called by uptool to register this plugin's integrations. This function MUST be exported and have this exact signature for the plugin to work.</p> <p>uptool will call this function and pass its Register function, which the plugin should call to register each integration it provides.</p> <p></p>"},{"location":"api/#type-integration_1","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for Python requirements.txt.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-integration-apply","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update plan by rewriting requirements.txt.</p> <p></p>"},{"location":"api/#func-integration-detect","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds requirements.txt files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for a requirements.txt file.</p> <p></p>"},{"location":"api/#func-integration-validate","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if a requirements.txt file is valid.</p> <p></p>"},{"location":"api/#type-pypiclient","title":"type PyPIClient","text":"<p>PyPIClient queries the PyPI JSON API for package information.</p> <pre><code>type PyPIClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newpypiclient","title":"func NewPyPIClient","text":"<pre><code>func NewPyPIClient() *PyPIClient\n</code></pre> <p>NewPyPIClient creates a new PyPI client.</p> <p></p>"},{"location":"api/#func-pypiclient-getlatestversion","title":"func \\(\\*PyPIClient\\) GetLatestVersion","text":"<pre><code>func (c *PyPIClient) GetLatestVersion(ctx context.Context, packageName string) (string, error)\n</code></pre> <p>GetLatestVersion fetches the latest stable version for a package from PyPI.</p> <p></p>"},{"location":"api/#type-pypiresponse","title":"type PyPIResponse","text":"<p>PyPIResponse represents the PyPI JSON API response.</p> <pre><code>type PyPIResponse struct {\n    Info struct {\n        Name    string `json:\"name\"`\n        Version string `json:\"version\"`\n    }   `json:\"info\"`\n    Releases map[string][]struct {\n        Yanked bool `json:\"yanked\"`\n    }   `json:\"releases\"`\n}\n</code></pre>"},{"location":"api/#all","title":"all","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/all\"\n</code></pre> <p>Package all imports all integration packages to trigger their self-registration. Import this package with a blank identifier to enable all integrations:</p> <pre><code>import _ \"github.com/santosr2/uptool/internal/integrations/all\"\n</code></pre>"},{"location":"api/#index_13","title":"Index","text":""},{"location":"api/#asdf","title":"asdf","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/asdf\"\n</code></pre> <p>Package asdf provides integration for asdf tool version manager. It detects and updates .tool-versions files.</p> <p>Status: EXPERIMENTAL - Version resolution not yet implemented</p>"},{"location":"api/#index_14","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-integration_2","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for asdf.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_1","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new asdf integration.</p> <p></p>"},{"location":"api/#func-integration-apply_1","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply applies updates to asdf manifest files.</p> <p>Note: Apply is not implemented for asdf. Use native asdf commands instead:</p> <ul> <li>asdf plugin update --all # Update all plugins</li> <li>asdf install \\&lt;tool&gt; latest # Install latest version of a tool</li> </ul> <p>To manually update versions in .tool-versions:</p> <ol> <li>Check available versions: asdf list all \\&lt;tool&gt;</li> <li>Edit .tool-versions with desired versions</li> <li>Install: asdf install</li> </ol> <p></p>"},{"location":"api/#func-integration-detect_1","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect scans for .tool-versions files.</p> <p></p>"},{"location":"api/#func-integration-name_1","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_1","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for asdf tools.</p> <p>Note: asdf integration is experimental. Version resolution is not implemented because each tool \\(.tool\\-versions can contain nodejs, python, ruby, terraform, etc.\\) has its own registry and update mechanism. This would require datasources for every possible runtime.</p> <p>Recommended approach: Use native asdf commands:</p> <ul> <li>asdf plugin update --all # Update plugin versions</li> <li>asdf latest --all # Show latest versions</li> <li>asdf install \\&lt;tool&gt; latest # Install latest version</li> </ul> <p>Future enhancement: Could implement version checking via tool-specific datasources \\(npm registry, python.org, ruby gems, etc.\\) or by calling asdf native commands.</p> <p></p>"},{"location":"api/#func-integration-validate_1","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate validates an asdf manifest.</p>"},{"location":"api/#helm","title":"helm","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/helm\"\n</code></pre> <p>Package helm implements the Helm chart integration for updating Chart.yaml dependencies. It detects Chart.yaml files, queries Helm chart repositories for version updates, and rewrites chart dependency versions while preserving YAML structure.</p>"},{"location":"api/#index_15","title":"Index","text":"<ul> <li>type Chart</li> <li>type Dependency</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-chart","title":"type Chart","text":"<p>Chart represents the structure of Chart.yaml.</p> <pre><code>type Chart struct {\n    Raw          map[string]any `yaml:\",inline\"`\n    APIVersion   string         `yaml:\"apiVersion\"`\n    Name         string         `yaml:\"name\"`\n    Description  string         `yaml:\"description\"`\n    Type         string         `yaml:\"type\"`\n    Version      string         `yaml:\"version\"`\n    AppVersion   string         `yaml:\"appVersion\"`\n    Dependencies []Dependency   `yaml:\"dependencies,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependency_1","title":"type Dependency","text":"<p>Dependency represents a chart dependency.</p> <pre><code>type Dependency struct {\n    Name       string `yaml:\"name\"`\n    Version    string `yaml:\"version\"`\n    Repository string `yaml:\"repository\"`\n    Condition  string `yaml:\"condition,omitempty\"`\n    Tags       string `yaml:\"tags,omitempty\"`\n    Alias      string `yaml:\"alias,omitempty\"`\n    Enabled    bool   `yaml:\"enabled,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_3","title":"type Integration","text":"<p>Integration implements helm chart updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_2","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new helm integration.</p> <p></p>"},{"location":"api/#func-integration-apply_2","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting Chart.yaml.</p> <p></p>"},{"location":"api/#func-integration-detect_2","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds Chart.yaml files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_2","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_2","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for helm chart dependencies.</p> <p></p>"},{"location":"api/#func-integration-validate_2","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the Chart.yaml is valid.</p>"},{"location":"api/#mise","title":"mise","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/mise\"\n</code></pre> <p>Package mise provides integration for mise tool version manager. It detects and updates mise.toml, .mise.toml, and optionally .tool-versions files. mise is backward-compatible with asdf's .tool-versions format.</p> <p>Status: EXPERIMENTAL - Version resolution not yet implemented</p>"},{"location":"api/#index_16","title":"Index","text":"<ul> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-config_1","title":"type Config","text":"<p>Config represents the structure of a mise.toml file.</p> <pre><code>type Config struct {\n    Tools map[string]interface{} `toml:\"tools\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_4","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for mise.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_3","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new mise integration.</p> <p></p>"},{"location":"api/#func-integration-apply_3","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply applies updates to mise manifest files.</p> <p>Note: Apply is not implemented for mise. Use native mise commands instead:</p> <ul> <li>mise upgrade # Upgrade all tools to latest</li> <li>mise use \\&lt;tool&gt;@latest # Pin specific tool to latest</li> </ul> <p>To manually update versions in mise.toml or .mise.toml:</p> <ol> <li>Check available versions: mise ls-remote \\&lt;tool&gt;</li> <li>Edit mise.toml with desired versions</li> <li>Install: mise install</li> </ol> <p></p>"},{"location":"api/#func-integration-detect_3","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect scans for mise.toml and .mise.toml files.</p> <p></p>"},{"location":"api/#func-integration-name_3","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_3","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for mise tools.</p> <p>Note: mise integration is experimental. Version resolution is not implemented because each tool \\(mise.toml can contain nodejs, python, ruby, terraform, etc.\\) has its own registry and update mechanism. This would require datasources for every possible runtime.</p> <p>Recommended approach: Use native mise commands:</p> <ul> <li>mise upgrade # Upgrade all tools to latest versions</li> <li>mise outdated # Show outdated tools</li> <li>mise use \\&lt;tool&gt;@latest # Pin to latest version</li> </ul> <p>Future enhancement: Could implement version checking via tool-specific datasources \\(npm registry, python.org, ruby gems, etc.\\) or by calling mise native commands.</p> <p></p>"},{"location":"api/#func-integration-validate_3","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate validates a mise manifest.</p>"},{"location":"api/#npm","title":"npm","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/npm\"\n</code></pre> <p>Package npm implements the npm integration for updating package.json dependencies. It detects package.json files, queries the npm registry for version updates, and rewrites dependency versions while preserving constraint prefixes \\(^, \\~, \\&gt;=\\).</p>"},{"location":"api/#index_17","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type PackageJSON</li> </ul>"},{"location":"api/#type-integration_5","title":"type Integration","text":"<p>Integration implements npm package.json updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_4","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new npm integration.</p> <p></p>"},{"location":"api/#func-integration-apply_4","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update plan by rewriting package.json.</p> <p></p>"},{"location":"api/#func-integration-detect_4","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds package.json files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_4","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_4","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for npm dependencies.</p> <p></p>"},{"location":"api/#func-integration-validate_4","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate runs npm validation \\(optional\\).</p> <p></p>"},{"location":"api/#type-packagejson","title":"type PackageJSON","text":"<p>PackageJSON represents the structure of package.json.</p> <pre><code>type PackageJSON struct {\n    Dependencies         map[string]string `json:\"dependencies,omitempty\"`\n    DevDependencies      map[string]string `json:\"devDependencies,omitempty\"`\n    PeerDependencies     map[string]string `json:\"peerDependencies,omitempty\"`\n    OptionalDependencies map[string]string `json:\"optionalDependencies,omitempty\"`\n    Name                 string            `json:\"name,omitempty\"`\n    Version              string            `json:\"version,omitempty\"`\n}\n</code></pre>"},{"location":"api/#precommit","title":"precommit","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/precommit\"\n</code></pre> <p>Package precommit implements the pre-commit integration using the native autoupdate command. It detects .pre-commit-config.yaml files, runs 'pre-commit autoupdate' to update hook versions, and parses the output to report changes. This follows the manifest-first philosophy by using the native tool that directly updates the configuration file.</p>"},{"location":"api/#index_18","title":"Index","text":"<ul> <li>type Config</li> <li>type Hook</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Repo</li> </ul>"},{"location":"api/#type-config_2","title":"type Config","text":"<p>Config represents the structure of .pre-commit-config.yaml.</p> <pre><code>type Config struct {\n    Repos []Repo `yaml:\"repos\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-hook","title":"type Hook","text":"<p>Hook represents a pre-commit hook.</p> <pre><code>type Hook struct {\n    ID string `yaml:\"id\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_6","title":"type Integration","text":"<p>Integration implements pre-commit hook updates using native autoupdate command.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_5","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new pre-commit integration.</p> <p></p>"},{"location":"api/#func-integration-apply_5","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update using native pre-commit autoupdate command.</p> <p></p>"},{"location":"api/#func-integration-detect_5","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .pre-commit-config.yaml files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_5","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_5","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for pre-commit hooks. For pre-commit, we use the native autoupdate command in dry-run mode.</p> <p></p>"},{"location":"api/#func-integration-validate_5","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate runs pre-commit validate-config.</p> <p></p>"},{"location":"api/#type-repo","title":"type Repo","text":"<p>Repo represents a pre-commit repository.</p> <pre><code>type Repo struct {\n    Repo  string `yaml:\"repo\"`\n    Rev   string `yaml:\"rev\"`\n    Hooks []Hook `yaml:\"hooks,omitempty\"`\n}\n</code></pre>"},{"location":"api/#terraform","title":"terraform","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/terraform\"\n</code></pre> <p>Package terraform implements the Terraform integration for updating module versions in .tf files. It detects Terraform configuration files, parses HCL to extract module and provider versions, queries the Terraform Registry for updates, and rewrites versions while preserving HCL formatting.</p>"},{"location":"api/#index_19","title":"Index","text":"<ul> <li>type Block</li> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type ModuleBlock</li> <li>type ProviderBlock</li> <li>type RequiredProvidersBlock</li> </ul>"},{"location":"api/#type-block","title":"type Block","text":"<p>Block represents a terraform configuration block.</p> <pre><code>type Block struct {\n    Remain            hcl.Body                `hcl:\",remain\"`\n    RequiredProviders *RequiredProvidersBlock `hcl:\"required_providers,block\"`\n    RequiredVersion   string                  `hcl:\"required_version,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-config_3","title":"type Config","text":"<p>Config represents terraform configuration structure.</p> <pre><code>type Config struct {\n    Remain    hcl.Body        `hcl:\",remain\"`\n    Terraform []Block         `hcl:\"terraform,block\"`\n    Modules   []ModuleBlock   `hcl:\"module,block\"`\n    Providers []ProviderBlock `hcl:\"provider,block\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_7","title":"type Integration","text":"<p>Integration implements terraform configuration updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_6","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new terraform integration.</p> <p></p>"},{"location":"api/#func-integration-apply_6","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting terraform files.</p> <p></p>"},{"location":"api/#func-integration-detect_6","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .tf files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_6","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_6","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for terraform providers and modules.</p> <p></p>"},{"location":"api/#func-integration-validate_6","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the terraform configuration is valid.</p> <p></p>"},{"location":"api/#type-moduleblock","title":"type ModuleBlock","text":"<p>ModuleBlock represents a module block.</p> <pre><code>type ModuleBlock struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Source  string   `hcl:\"source,optional\"`\n    Version string   `hcl:\"version,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerblock","title":"type ProviderBlock","text":"<p>ProviderBlock represents a provider block.</p> <pre><code>type ProviderBlock struct {\n    Remain hcl.Body `hcl:\",remain\"`\n    Name   string   `hcl:\"name,label\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-requiredprovidersblock","title":"type RequiredProvidersBlock","text":"<p>RequiredProvidersBlock represents the required_providers block.</p> <pre><code>type RequiredProvidersBlock struct {\n    Body hcl.Body `hcl:\",remain\"`\n}\n</code></pre>"},{"location":"api/#tflint","title":"tflint","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/tflint\"\n</code></pre> <p>Package tflint implements the tflint integration for updating plugin versions in .tflint.hcl files. It detects tflint configuration files, parses HCL to extract plugin versions, queries GitHub Releases for plugin updates, and rewrites versions while preserving HCL formatting.</p>"},{"location":"api/#index_20","title":"Index","text":"<ul> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Plugin</li> <li>type Rule</li> </ul>"},{"location":"api/#type-config_4","title":"type Config","text":"<p>Config represents .tflint.hcl structure.</p> <pre><code>type Config struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Plugins []Plugin `hcl:\"plugin,block\"`\n    Rules   []Rule   `hcl:\"rule,block\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_8","title":"type Integration","text":"<p>Integration implements tflint configuration updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_7","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new tflint integration.</p> <p></p>"},{"location":"api/#func-integration-apply_7","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting the HCL file.</p> <p></p>"},{"location":"api/#func-integration-detect_7","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .tflint.hcl files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_7","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_7","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for tflint plugins.</p> <p></p>"},{"location":"api/#func-integration-validate_7","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the HCL file is valid.</p> <p></p>"},{"location":"api/#type-plugin","title":"type Plugin","text":"<p>Plugin represents a tflint plugin block.</p> <pre><code>type Plugin struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Version string   `hcl:\"version,optional\"`\n    Source  string   `hcl:\"source,optional\"`\n    Enabled bool     `hcl:\"enabled,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-rule","title":"type Rule","text":"<p>Rule represents a tflint rule block.</p> <pre><code>type Rule struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Enabled bool     `hcl:\"enabled,optional\"`\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"cli/commands/","title":"CLI Commands","text":"<p>uptool is a manifest-first dependency updater for multiple ecosystems. It scans repositories for dependency manifest files (package.json, Chart.yaml, .pre-commit-config.yaml, etc.), checks for available updates, and rewrites manifests with new versions while preserving formatting.</p> <p>Usage:   uptool [command]</p> <p>Available Commands:   completion  Generate shell completion scripts   help        Help about any command   list        List available integrations   plan        Generate update plans   scan        Discover dependency manifests   update      Apply updates to manifests</p> <p>Flags:   -h, --help      help for uptool   -q, --quiet     suppress informational output (errors only)   -v, --verbose   enable verbose debug output       --version   version for uptool</p> <p>Use \"uptool [command] --help\" for more information about a command.</p>"},{"location":"integrations/","title":"Integration Guides","text":"<p>This directory contains detailed guides for each uptool integration.</p>"},{"location":"integrations/#available-integrations","title":"Available Integrations","text":""},{"location":"integrations/#package-managers","title":"Package Managers","text":"<ul> <li>npm - JavaScript/Node.js dependencies (<code>package.json</code>)</li> <li>Status: \u2705 Stable</li> <li>Manifests: <code>package.json</code></li> <li>Registry: npm Registry</li> </ul>"},{"location":"integrations/#infrastructure-as-code","title":"Infrastructure as Code","text":"<ul> <li>helm - Kubernetes Helm charts (<code>Chart.yaml</code>)</li> <li>Status: \u2705 Stable</li> <li>Manifests: <code>Chart.yaml</code></li> <li> <p>Registry: Helm chart repositories</p> </li> <li> <p>terraform - Terraform modules (<code>*.tf</code>)</p> </li> <li>Status: \u2705 Stable</li> <li>Manifests: <code>*.tf</code> files</li> <li> <p>Registry: Terraform Registry</p> </li> <li> <p>tflint - Terraform linter plugins (<code>.tflint.hcl</code>)</p> </li> <li>Status: \u2705 Stable</li> <li>Manifests: <code>.tflint.hcl</code></li> <li>Registry: GitHub Releases</li> </ul>"},{"location":"integrations/#development-tools","title":"Development Tools","text":"<ul> <li>precommit - Pre-commit hooks (<code>.pre-commit-config.yaml</code>)</li> <li>Status: \u2705 Stable</li> <li>Manifests: <code>.pre-commit-config.yaml</code></li> <li>Registry: GitHub Releases</li> <li> <p>Note: Uses native <code>pre-commit autoupdate</code></p> </li> <li> <p>asdf - asdf version manager (<code>.tool-versions</code>)</p> </li> <li>Status: \u2705 Stable</li> <li>Manifests: <code>.tool-versions</code></li> <li> <p>Registry: GitHub Releases (per tool)</p> </li> <li> <p>mise - mise version manager (<code>mise.toml</code>)</p> </li> <li>Status: \u2705 Stable</li> <li>Manifests: <code>mise.toml</code>, <code>.mise.toml</code></li> <li>Registry: GitHub Releases (per tool)</li> </ul>"},{"location":"integrations/#integration-categories","title":"Integration Categories","text":""},{"location":"integrations/#by-update-strategy","title":"By Update Strategy","text":"<p>Custom Rewriting (uptool parses and rewrites manifest):</p> <ul> <li>npm (<code>package.json</code>)</li> <li>helm (<code>Chart.yaml</code>)</li> <li>terraform (<code>*.tf</code>)</li> <li>tflint (<code>.tflint.hcl</code>)</li> <li>asdf (<code>.tool-versions</code>)</li> <li>mise (<code>mise.toml</code>)</li> </ul> <p>Native Command (integration calls native tool):</p> <ul> <li>precommit (<code>pre-commit autoupdate</code>)</li> </ul>"},{"location":"integrations/#by-registry-type","title":"By Registry Type","text":"<p>HTTP APIs:</p> <ul> <li>npm \u2192 npm Registry API</li> <li>terraform \u2192 Terraform Registry API</li> </ul> <p>Repository Indexes:</p> <ul> <li>helm \u2192 Helm chart repository <code>index.yaml</code></li> </ul> <p>GitHub Releases:</p> <ul> <li>precommit \u2192 Hook repository releases</li> <li>tflint \u2192 Plugin repository releases</li> <li>asdf \u2192 Tool repository releases (via plugin mapping)</li> <li>mise \u2192 Tool repository releases</li> </ul>"},{"location":"integrations/#quick-reference","title":"Quick Reference","text":"Integration Manifest Update Strategy Registry npm <code>package.json</code> Custom rewrite npm API helm <code>Chart.yaml</code> Custom rewrite Helm repos terraform <code>*.tf</code> Custom rewrite Terraform API tflint <code>.tflint.hcl</code> Custom rewrite GitHub precommit <code>.pre-commit-config.yaml</code> Native command GitHub asdf <code>.tool-versions</code> Custom rewrite GitHub mise <code>mise.toml</code> Custom rewrite GitHub"},{"location":"integrations/#common-patterns","title":"Common Patterns","text":""},{"location":"integrations/#scan-for-specific-integration","title":"Scan for Specific Integration","text":"<pre><code>uptool scan --only=npm\nuptool scan --only=terraform,tflint\n</code></pre>"},{"location":"integrations/#update-single-integration","title":"Update Single Integration","text":"<pre><code>uptool update --only=helm --diff\n</code></pre>"},{"location":"integrations/#exclude-specific-integrations","title":"Exclude Specific Integrations","text":"<pre><code>uptool update --exclude=precommit\n</code></pre>"},{"location":"integrations/#integration-priority","title":"Integration Priority","text":"<p>When using multiple integrations, they run in parallel:</p> <pre><code>uptool update  # All integrations run concurrently\n</code></pre> <p>To control execution:</p> <pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n\n  - id: terraform\n    enabled: false    # Disabled\n</code></pre>"},{"location":"integrations/#see-also","title":"See Also","text":"<ul> <li>Manifest Files Reference</li> <li>Configuration Guide</li> <li>Main README</li> </ul>"},{"location":"integrations/asdf/","title":"asdf Integration","text":"<p>The asdf integration updates tool versions in <code>.tool-versions</code> files used by the asdf version manager.</p>"},{"location":"integrations/asdf/#overview","title":"Overview","text":"<p>Integration ID: <code>asdf</code></p> <p>Manifest Files: <code>.tool-versions</code></p> <p>Update Strategy: Line-based parsing and rewriting</p> <p>Registry: GitHub Releases (per tool via asdf plugin mapping)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/asdf/#what-gets-updated","title":"What Gets Updated","text":"<p>The asdf integration updates tool versions:</p> <ul> <li>Tool version entries in <code>.tool-versions</code> file</li> <li>Supports multiple versions per tool (space-separated)</li> </ul>"},{"location":"integrations/asdf/#example","title":"Example","text":"<p>Before (<code>.tool-versions</code>):</p> <pre><code># Development tools\ngo 1.23.0\nnodejs 20.10.0\nterraform 1.5.0\n\n# Build tools\npython 3.11.0\nruby 3.2.0\n</code></pre> <p>After (uptool update):</p> <pre><code># Development tools\ngo 1.25.0\nnodejs 22.12.0\nterraform 1.10.5\n\n# Build tools\npython 3.13.1\nruby 3.3.6\n</code></pre>"},{"location":"integrations/asdf/#tool-detection","title":"Tool Detection","text":"<p>uptool detects tools based on:</p> <ol> <li>Tool name: Must match an asdf plugin name</li> <li>Version format: Semantic version or tool-specific format</li> <li>Plugin mapping: Maps tool names to GitHub repositories</li> </ol>"},{"location":"integrations/asdf/#supported-tools","title":"Supported Tools","text":"<p>Common tools with known GitHub release patterns:</p> <ul> <li>go \u2192 golang/go</li> <li>nodejs / node \u2192 nodejs/node</li> <li>python \u2192 python/cpython</li> <li>ruby \u2192 ruby/ruby</li> <li>terraform \u2192 hashicorp/terraform</li> <li>kubectl \u2192 kubernetes/kubernetes</li> <li>helm \u2192 helm/helm</li> <li>And many more via asdf plugins</li> </ul>"},{"location":"integrations/asdf/#cli-usage","title":"CLI Usage","text":""},{"location":"integrations/asdf/#scan-for-tool-versions","title":"Scan for .tool-versions","text":"<pre><code>uptool scan --only=asdf\n</code></pre> <p>Output:</p> <pre><code>Type                 Path                Dependencies\n----------------------------------------------------------------\nasdf                 .tool-versions      5\n\nTotal: 1 manifest\n</code></pre>"},{"location":"integrations/asdf/#plan-asdf-updates","title":"Plan asdf Updates","text":"<pre><code>uptool plan --only=asdf\n</code></pre> <p>Output:</p> <pre><code>.tool-versions (asdf):\nTool             Current         Target          Impact\n--------------------------------------------------------\ngo               1.23.0          1.25.0          minor\nnodejs           20.10.0         22.12.0         major\nterraform        1.5.0           1.10.5          minor\npython           3.11.0          3.13.1          minor\nruby             3.2.0           3.3.6           minor\n\nTotal: 5 updates across 1 manifest\n</code></pre>"},{"location":"integrations/asdf/#apply-asdf-updates","title":"Apply asdf Updates","text":"<pre><code># Dry run first\nuptool update --only=asdf --dry-run --diff\n\n# Apply updates\nuptool update --only=asdf\n\n# Then install new versions\nasdf install\n</code></pre>"},{"location":"integrations/asdf/#multiple-versions","title":"Multiple Versions","text":"<p>asdf supports multiple versions per tool:</p> <p>Before:</p> <pre><code>nodejs 20.10.0 18.19.0 16.20.0\n</code></pre> <p>After (uptool updates latest in each major):</p> <pre><code>nodejs 22.12.0 18.20.5 16.20.2\n</code></pre> <p>uptool updates all specified versions independently.</p>"},{"location":"integrations/asdf/#configuration","title":"Configuration","text":""},{"location":"integrations/asdf/#update-policy","title":"Update Policy","text":"<pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: asdf\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false\n</code></pre> <p>Update Levels:</p> <ul> <li><code>none</code> - No updates</li> <li><code>patch</code> - Only patch updates (1.23.0 \u2192 1.23.1)</li> <li><code>minor</code> - Patch + minor updates (1.23.0 \u2192 1.24.0)</li> <li><code>major</code> - All updates including major (1.23.0 \u2192 2.0.0)</li> </ul>"},{"location":"integrations/asdf/#exclude-specific-tools","title":"Exclude Specific Tools","text":"<p>Pin to exact version:</p> <pre><code># .tool-versions\ngo 1.23.0        # Will be updated\nnodejs 20.10.0   # Will be updated\npython 3.11.0    # To pin, use comment\n</code></pre> <p>Note: asdf doesn't have built-in version pinning syntax. To prevent updates, use specific version numbers and update policy.</p>"},{"location":"integrations/asdf/#tool-version-installation","title":"Tool Version Installation","text":"<p>uptool does NOT install tool versions.</p> <p>After updating <code>.tool-versions</code>, install new versions:</p> <pre><code># Install all tools at specified versions\nasdf install\n\n# Install specific tool\nasdf install nodejs\n\n# Set global versions\nasdf global nodejs 22.12.0\n</code></pre>"},{"location":"integrations/asdf/#per-project-configuration","title":"Per-Project Configuration","text":"<p>asdf supports per-project <code>.tool-versions</code>:</p> <pre><code>my-project/\n\u251c\u2500\u2500 .tool-versions              # Project-specific versions\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 .tool-versions          # Nested project versions\n\u2514\u2500\u2500 scripts/\n</code></pre> <p>Each <code>.tool-versions</code> is updated independently.</p>"},{"location":"integrations/asdf/#legacy-versions","title":"Legacy Versions","text":"<p>Some tools use non-semver versioning:</p> <pre><code># Traditional versioning\njava openjdk-11.0.2\nerlang 26.0\n\n# System version\nnodejs system\npython system\n</code></pre> <p>uptool handles:</p> <ul> <li>\u2705 Semantic versions (1.2.3)</li> <li>\u2705 Version prefixes (v1.2.3, openjdk-11.0.2)</li> <li>\u274c <code>system</code> keyword (not updated)</li> <li>\u274c Custom version strings (varies by tool)</li> </ul>"},{"location":"integrations/asdf/#github-rate-limiting","title":"GitHub Rate Limiting","text":"<p>uptool queries GitHub Releases API for each tool.</p>"},{"location":"integrations/asdf/#unauthenticated","title":"Unauthenticated","text":"<ul> <li>Rate limit: 60 requests/hour</li> <li>May be insufficient for many tools</li> </ul>"},{"location":"integrations/asdf/#authenticated","title":"Authenticated","text":"<p>Set <code>GITHUB_TOKEN</code> environment variable:</p> <pre><code>export GITHUB_TOKEN=\"your_github_token\"\nuptool update --only=asdf\n</code></pre> <p>Rate limit: 5000 requests/hour</p>"},{"location":"integrations/asdf/#limitations","title":"Limitations","text":"<ol> <li>No version installation: uptool only updates <code>.tool-versions</code></li> <li> <p>Solution: Run <code>asdf install</code> after</p> </li> <li> <p>GitHub-based tools only: Tools must release via GitHub Releases</p> </li> <li> <p>Non-GitHub tools not yet supported</p> </li> <li> <p>No plugin installation: Assumes asdf plugins already installed</p> </li> <li> <p>Solution: Install plugins first with <code>asdf plugin add &lt;tool&gt;</code></p> </li> <li> <p>No version validation: Doesn't verify version compatibility</p> </li> <li> <p>Solution: Test with <code>asdf install</code> before committing</p> </li> <li> <p>No .tool-versions.lock: asdf doesn't use lockfiles</p> </li> <li>Versions are declarative</li> </ol>"},{"location":"integrations/asdf/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/asdf/#tool-not-found","title":"Tool Not Found","text":"<p>Problem: \"Tool not found in GitHub\"</p> <p>Causes:</p> <ol> <li>Tool name doesn't map to known GitHub repository</li> <li>asdf plugin uses non-GitHub source</li> <li>Tool name misspelled</li> </ol> <p>Solutions:</p> <pre><code># Check asdf plugin for tool\nasdf plugin list\nasdf plugin list all | grep &lt;tool&gt;\n\n# Verify tool in .tool-versions\ncat .tool-versions\n\n# Add plugin if missing\nasdf plugin add &lt;tool&gt;\n</code></pre>"},{"location":"integrations/asdf/#github-rate-limit","title":"GitHub Rate Limit","text":"<p>Problem: \"API rate limit exceeded\"</p> <p>Causes:</p> <ol> <li>Many tools without authentication</li> <li>Frequent updates</li> </ol> <p>Solutions:</p> <pre><code># Set GitHub token\nexport GITHUB_TOKEN=\"ghp_xxxxxxxxxxxx\"\n\n# Verify rate limit\ncurl -H \"Authorization: token $GITHUB_TOKEN\" \\\n  https://api.github.com/rate_limit\n\n# Run update\nuptool update --only=asdf\n</code></pre>"},{"location":"integrations/asdf/#version-not-available","title":"Version Not Available","text":"<p>Problem: uptool suggests version that doesn't exist</p> <p>Causes:</p> <ol> <li>Version numbering changed</li> <li>Pre-release versions included</li> </ol> <p>Solutions:</p> <pre><code># Check available versions\nasdf list all &lt;tool&gt;\n\n# Or check GitHub releases\ngh release list --repo golang/go\n\n# Exclude pre-releases in policy\n# uptool.yaml:\npolicy:\n  allow_prerelease: false\n</code></pre>"},{"location":"integrations/asdf/#installation-fails","title":"Installation Fails","text":"<p>Problem: <code>asdf install</code> fails after update</p> <p>Causes:</p> <ol> <li>New version has different dependencies</li> <li>Plugin not updated</li> <li>Build requirements missing</li> </ol> <p>Solutions:</p> <pre><code># Update asdf plugin\nasdf plugin update &lt;tool&gt;\nasdf plugin update --all\n\n# Check plugin requirements\nasdf plugin list\ncat ~/.asdf/plugins/&lt;tool&gt;/README.md\n\n# Install build dependencies\n# (varies by tool and OS)\n</code></pre>"},{"location":"integrations/asdf/#best-practices","title":"Best Practices","text":"<ol> <li>Always install after updating:</li> </ol> <pre><code>uptool update --only=asdf\nasdf install\ngit add .tool-versions\ngit commit -m \"chore: update tool versions\"\n</code></pre> <ol> <li>Test versions before committing:</li> </ol> <pre><code>asdf install\nasdf current  # Verify all tools installed\n# Run your test suite\n</code></pre> <ol> <li>Update plugins regularly:</li> </ol> <pre><code>asdf plugin update --all\n</code></pre> <ol> <li>Use conservative policy:</li> </ol> <pre><code># For production\npolicy:\n  update: patch\n\n# For development\npolicy:\n  update: minor\n</code></pre> <ol> <li>Set GitHub token:</li> </ol> <pre><code># In CI/CD\nenv:\n  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n# Locally\nexport GITHUB_TOKEN=\"your_token\"\n</code></pre> <ol> <li>Document required plugins:</li> </ol> <pre><code># In README or docs\n# Required asdf plugins:\nasdf plugin add nodejs\nasdf plugin add python\nasdf plugin add terraform\n</code></pre>"},{"location":"integrations/asdf/#asdf-version-compatibility","title":"asdf Version Compatibility","text":"<p>uptool works with asdf &gt;= 0.8.0.</p> <p>asdf &lt; 0.8.0:</p> <ul> <li>Not tested</li> <li><code>.tool-versions</code> format may differ</li> </ul> <p>asdf &gt;= 0.8.0:</p> <ul> <li>\u2705 Fully supported</li> <li>Standard <code>.tool-versions</code> format</li> </ul>"},{"location":"integrations/asdf/#tool-version-format","title":"Tool Version Format","text":"<p>asdf uses simple format:</p> <pre><code>&lt;tool-name&gt; &lt;version&gt; [&lt;version&gt; ...]\n</code></pre> <p>Examples:</p> <pre><code>nodejs 20.10.0\nnodejs 20.10.0 18.19.0\nterraform 1.5.0\npython 3.11.0 3.10.13\n</code></pre> <p>Comments (lines starting with <code>#</code>) are preserved.</p>"},{"location":"integrations/asdf/#comparison-with-mise","title":"Comparison with mise","text":"<p>asdf and mise use similar concepts:</p> Feature asdf mise Config file <code>.tool-versions</code> <code>mise.toml</code> or <code>.mise.toml</code> Format Simple text TOML Version syntax <code>tool version</code> <code>tool = \"version\"</code> Multiple versions Yes (space-separated) Limited <p>See mise integration for mise-specific documentation.</p>"},{"location":"integrations/asdf/#see-also","title":"See Also","text":"<ul> <li>asdf Documentation</li> <li>asdf Plugins</li> <li>.tool-versions Format</li> <li>Manifest Files Reference</li> </ul>"},{"location":"integrations/helm/","title":"Helm Integration","text":"<p>The Helm integration updates Kubernetes Helm chart dependencies in <code>Chart.yaml</code> files.</p>"},{"location":"integrations/helm/#overview","title":"Overview","text":"<p>Integration ID: <code>helm</code></p> <p>Manifest Files: <code>Chart.yaml</code></p> <p>Update Strategy: YAML parsing and rewriting</p> <p>Registry: Helm chart repositories (index.yaml)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/helm/#what-gets-updated","title":"What Gets Updated","text":"<p>The Helm integration updates chart dependency versions in <code>Chart.yaml</code>:</p> <ul> <li><code>dependencies[].version</code> - Version of each chart dependency</li> </ul>"},{"location":"integrations/helm/#example","title":"Example","text":"<p>Before (<code>Chart.yaml</code>):</p> <pre><code>apiVersion: v2\nname: my-application\nversion: 1.0.0\ndependencies:\n  - name: postgresql\n    version: 12.0.0\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 17.0.0\n    repository: https://charts.bitnami.com/bitnami\n  - name: nginx\n    version: 13.0.0\n    repository: https://charts.bitnami.com/bitnami\n</code></pre> <p>After (uptool update):</p> <pre><code>apiVersion: v2\nname: my-application\nversion: 1.0.0\ndependencies:\n  - name: postgresql\n    version: 18.1.8\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 23.2.12\n    repository: https://charts.bitnami.com/bitnami\n  - name: nginx\n    version: 18.2.5\n    repository: https://charts.bitnami.com/bitnami\n</code></pre>"},{"location":"integrations/helm/#chart-metadata","title":"Chart Metadata","text":"<p>uptool does NOT update:</p> <ul> <li>Chart <code>version</code> (your application version)</li> <li>Chart <code>appVersion</code> (application version packaged)</li> <li>Chart metadata fields</li> </ul> <p>Only dependency versions are updated.</p>"},{"location":"integrations/helm/#cli-usage","title":"CLI Usage","text":""},{"location":"integrations/helm/#scan-for-helm-charts","title":"Scan for Helm Charts","text":"<pre><code>uptool scan --only=helm\n</code></pre> <p>Output:</p> <pre><code>Type                 Path                            Dependencies\n------------------------------------------------------------------------\nhelm                 charts/myapp/Chart.yaml         3\nhelm                 charts/api/Chart.yaml           2\nhelm                 infra/charts/monitoring/Chart.yaml  5\n\nTotal: 3 manifests\n</code></pre>"},{"location":"integrations/helm/#plan-helm-updates","title":"Plan Helm Updates","text":"<pre><code>uptool plan --only=helm\n</code></pre> <p>Output:</p> <pre><code>charts/myapp/Chart.yaml (helm):\nChart            Current         Target          Impact\n--------------------------------------------------------\npostgresql       12.0.0          18.1.8          major\nredis            17.0.0          23.2.12         major\nnginx            13.0.0          18.2.5          major\n\ncharts/api/Chart.yaml (helm):\nChart            Current         Target          Impact\n--------------------------------------------------------\nmysql            9.0.0           11.1.16         major\n\nTotal: 4 updates across 2 manifests\n</code></pre>"},{"location":"integrations/helm/#apply-helm-updates","title":"Apply Helm Updates","text":"<pre><code># Dry run first\nuptool update --only=helm --dry-run --diff\n\n# Apply updates\nuptool update --only=helm\n\n# Then update Chart.lock\nhelm dependency update charts/myapp\nhelm dependency update charts/api\n</code></pre>"},{"location":"integrations/helm/#helm-repository-types","title":"Helm Repository Types","text":""},{"location":"integrations/helm/#public-repositories","title":"Public Repositories","text":"<p>Most common: Bitnami, official charts</p> <pre><code>dependencies:\n  - name: postgresql\n    version: 18.1.8\n    repository: https://charts.bitnami.com/bitnami\n</code></pre> <p>uptool queries the repository's <code>index.yaml</code>:</p> <pre><code>curl https://charts.bitnami.com/bitnami/index.yaml\n</code></pre>"},{"location":"integrations/helm/#oci-registries","title":"OCI Registries","text":"<p>Helm charts in OCI registries (Docker-like):</p> <pre><code>dependencies:\n  - name: my-chart\n    version: 1.0.0\n    repository: oci://registry.example.com/charts\n</code></pre> <p>Note: OCI registry support depends on Helm client configuration.</p>"},{"location":"integrations/helm/#chart-museum","title":"Chart Museum","text":"<p>Private chart repositories:</p> <pre><code>dependencies:\n  - name: internal-chart\n    version: 2.0.0\n    repository: https://charts.company.internal\n</code></pre> <p>uptool attempts to fetch <code>index.yaml</code> from the repository URL.</p>"},{"location":"integrations/helm/#configuration","title":"Configuration","text":""},{"location":"integrations/helm/#update-policy","title":"Update Policy","text":"<pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: helm\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false    # Don't update to pre-release versions\n</code></pre> <p>Update Levels:</p> <ul> <li><code>none</code> - No updates</li> <li><code>patch</code> - Only patch updates (12.0.0 \u2192 12.0.1)</li> <li><code>minor</code> - Patch + minor updates (12.0.0 \u2192 12.1.0)</li> <li><code>major</code> - All updates including major (12.0.0 \u2192 18.0.0)</li> </ul>"},{"location":"integrations/helm/#exclude-specific-charts","title":"Exclude Specific Charts","text":"<p>To pin a chart version, use exact version without range:</p> <pre><code>dependencies:\n  - name: critical-chart\n    version: 1.2.3    # Won't be updated (exact version)\n</code></pre>"},{"location":"integrations/helm/#repository-authentication","title":"Repository Authentication","text":""},{"location":"integrations/helm/#private-repositories","title":"Private Repositories","text":"<p>Configure Helm authentication separately:</p> <pre><code># Add private repository with credentials\nhelm repo add myrepo https://charts.company.internal \\\n  --username=user \\\n  --password=pass\n\n# Or use token\nhelm repo add myrepo https://charts.company.internal \\\n  --username=token \\\n  --password=$HELM_TOKEN\n</code></pre> <p>uptool respects Helm's repository configuration in <code>~/.config/helm/repositories.yaml</code>.</p>"},{"location":"integrations/helm/#helm-registries","title":"Helm Registries","text":"<p>For OCI registries, authenticate with Helm:</p> <pre><code>helm registry login registry.example.com -u username\n</code></pre>"},{"location":"integrations/helm/#chartlock-file","title":"Chart.lock File","text":"<p>uptool does NOT update <code>Chart.lock</code> (lockfile).</p> <p>After updating <code>Chart.yaml</code>, regenerate the lockfile:</p> <pre><code># For single chart\nhelm dependency update charts/myapp\n\n# For multiple charts\nfor dir in charts/*/; do\n  helm dependency update \"$dir\"\ndone\n</code></pre>"},{"location":"integrations/helm/#monorepo-pattern","title":"Monorepo Pattern","text":"<p>Common structure:</p> <pre><code>my-monorepo/\n\u251c\u2500\u2500 charts/\n\u2502   \u251c\u2500\u2500 frontend/\n\u2502   \u2502   \u251c\u2500\u2500 Chart.yaml       # Updated independently\n\u2502   \u2502   \u2514\u2500\u2500 Chart.lock\n\u2502   \u251c\u2500\u2500 backend/\n\u2502   \u2502   \u251c\u2500\u2500 Chart.yaml       # Updated independently\n\u2502   \u2502   \u2514\u2500\u2500 Chart.lock\n\u2502   \u2514\u2500\u2500 database/\n\u2502       \u251c\u2500\u2500 Chart.yaml       # Updated independently\n\u2502       \u2514\u2500\u2500 Chart.lock\n</code></pre> <p>Each <code>Chart.yaml</code> is scanned and updated independently.</p>"},{"location":"integrations/helm/#limitations","title":"Limitations","text":"<ol> <li>No Chart.lock updates: uptool only updates <code>Chart.yaml</code></li> <li> <p>Solution: Run <code>helm dependency update</code> after</p> </li> <li> <p>No version constraint validation: uptool doesn't validate Helm version constraints</p> </li> <li> <p>Solution: Test with <code>helm lint</code> after updating</p> </li> <li> <p>No chart availability check: Assumes charts exist in repositories</p> </li> <li> <p>Solution: Run <code>helm dependency build</code> to verify</p> </li> <li> <p>Repository access: Requires repository to be accessible and configured</p> </li> <li>Solution: Ensure <code>helm repo add</code> is configured</li> </ol>"},{"location":"integrations/helm/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/helm/#repository-not-found","title":"Repository Not Found","text":"<p>Problem: \"Failed to fetch chart from repository\"</p> <p>Causes:</p> <ol> <li>Repository URL incorrect in <code>Chart.yaml</code></li> <li>Repository not added to Helm</li> <li>Network connectivity issues</li> </ol> <p>Solutions:</p> <pre><code># List configured repositories\nhelm repo list\n\n# Add missing repository\nhelm repo add bitnami https://charts.bitnami.com/bitnami\n\n# Update repository indexes\nhelm repo update\n\n# Test chart availability\nhelm search repo postgresql\n</code></pre>"},{"location":"integrations/helm/#authentication-errors","title":"Authentication Errors","text":"<p>Problem: \"403 Forbidden\" or \"401 Unauthorized\"</p> <p>Causes:</p> <ol> <li>Private repository requires authentication</li> <li>Credentials expired or incorrect</li> </ol> <p>Solutions:</p> <pre><code># Re-add repository with credentials\nhelm repo remove myrepo\nhelm repo add myrepo https://charts.company.internal \\\n  --username=$USER \\\n  --password=$PASS\n\n# Verify access\nhelm search repo myrepo/\n</code></pre>"},{"location":"integrations/helm/#chartlock-out-of-sync","title":"Chart.lock Out of Sync","text":"<p>Problem: After updating, <code>helm install</code> fails with dependency errors</p> <p>Solution:</p> <pre><code># Delete Chart.lock and rebuild\nrm Chart.lock\nhelm dependency update .\n\n# Or rebuild dependencies\nhelm dependency build .\n</code></pre>"},{"location":"integrations/helm/#version-not-available","title":"Version Not Available","text":"<p>Problem: uptool wants to update to version that doesn't exist</p> <p>Causes:</p> <ol> <li>Repository index is stale</li> <li>Chart was removed from repository</li> </ol> <p>Solutions:</p> <pre><code># Update repository indexes\nhelm repo update\n\n# Check available versions\nhelm search repo postgresql --versions\n\n# Pin to known good version in Chart.yaml\n</code></pre>"},{"location":"integrations/helm/#best-practices","title":"Best Practices","text":"<ol> <li>Always regenerate Chart.lock:</li> </ol> <pre><code>uptool update --only=helm\nhelm dependency update charts/myapp\ngit add charts/myapp/Chart.yaml charts/myapp/Chart.lock\ngit commit -m \"chore(helm): update chart dependencies\"\n</code></pre> <ol> <li>Test charts after updating:</li> </ol> <pre><code>helm lint charts/myapp\nhelm template charts/myapp\nhelm install --dry-run test charts/myapp\n</code></pre> <ol> <li>Review major version updates:</li> </ol> <pre><code># Check release notes for breaking changes\nhelm show readme bitnami/postgresql --version 18.1.8\n</code></pre> <ol> <li>Use separate PRs for major updates:</li> </ol> <pre><code># Minor/patch updates together\nuptool update --only=helm  # (with policy: minor)\n\n# Major updates separately per chart\n# Review each carefully\n</code></pre> <ol> <li>Keep repository indexes fresh:</li> </ol> <pre><code>helm repo update\n</code></pre> <ol> <li>Pin critical dependencies:</li> </ol> <pre><code>dependencies:\n  - name: critical-database\n    version: 12.0.0  # Exact version\n</code></pre>"},{"location":"integrations/helm/#helm-version-compatibility","title":"Helm Version Compatibility","text":"<p>uptool works with Helm v3.x chart repositories.</p> <p>Helm v2 (deprecated):</p> <ul> <li>Not officially supported</li> <li>May work if repository format is compatible</li> </ul> <p>Helm v3:</p> <ul> <li>\u2705 Fully supported</li> <li>Works with <code>Chart.yaml</code> v2 (apiVersion: v2)</li> </ul>"},{"location":"integrations/helm/#see-also","title":"See Also","text":"<ul> <li>Helm Chart Dependencies</li> <li>Helm Repositories</li> <li>Chart.yaml Specification</li> <li>Manifest Files Reference</li> </ul>"},{"location":"integrations/mise/","title":"mise Integration","text":"<p>The mise integration updates tool versions in <code>mise.toml</code> or <code>.mise.toml</code> files used by the mise version manager (formerly rtx).</p>"},{"location":"integrations/mise/#overview","title":"Overview","text":"<p>Integration ID: <code>mise</code></p> <p>Manifest Files: <code>mise.toml</code>, <code>.mise.toml</code></p> <p>Update Strategy: TOML parsing and rewriting</p> <p>Registry: GitHub Releases (per tool)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/mise/#what-gets-updated","title":"What Gets Updated","text":"<p>The mise integration updates tool versions in the <code>[tools]</code> section:</p> <ul> <li>Tool version values (both string and map format)</li> <li>Preserves comments and formatting</li> </ul>"},{"location":"integrations/mise/#example","title":"Example","text":""},{"location":"integrations/mise/#string-format","title":"String Format","text":"<p>Before (<code>mise.toml</code>):</p> <pre><code>[tools]\ngo = \"1.23\"\nnode = \"20\"\ngolangci-lint = \"2.6\"\nterraform = \"1.5.0\"\npython = \"3.11\"\n</code></pre> <p>After (uptool update):</p> <pre><code>[tools]\ngo = \"1.25\"\nnode = \"22\"\ngolangci-lint = \"2.7\"\nterraform = \"1.10.5\"\npython = \"3.13\"\n</code></pre>"},{"location":"integrations/mise/#map-format","title":"Map Format","text":"<p>Before (<code>mise.toml</code>):</p> <pre><code>[tools]\ngo = { version = \"1.23\", path = \".go-version\" }\nnode = { version = \"20\" }\npython = { version = \"3.11\", virtualenv = \".venv\" }\n</code></pre> <p>After (uptool update):</p> <pre><code>[tools]\ngo = { version = \"1.25\", path = \".go-version\" }\nnode = { version = \"22\" }\npython = { version = \"3.13\", virtualenv = \".venv\" }\n</code></pre>"},{"location":"integrations/mise/#tool-detection","title":"Tool Detection","text":"<p>uptool detects tools in the <code>[tools]</code> section and maps them to GitHub repositories:</p>"},{"location":"integrations/mise/#supported-tools","title":"Supported Tools","text":"<p>Common tools with known GitHub release patterns:</p> <ul> <li>go \u2192 golang/go</li> <li>node / nodejs \u2192 nodejs/node</li> <li>python \u2192 python/cpython</li> <li>ruby \u2192 ruby/ruby</li> <li>terraform \u2192 hashicorp/terraform</li> <li>kubectl \u2192 kubernetes/kubernetes</li> <li>helm \u2192 helm/helm</li> <li>golangci-lint \u2192 golangci/golangci-lint</li> <li>And many more</li> </ul>"},{"location":"integrations/mise/#cli-usage","title":"CLI Usage","text":""},{"location":"integrations/mise/#scan-for-mise-configs","title":"Scan for mise Configs","text":"<pre><code>uptool scan --only=mise\n</code></pre> <p>Output:</p> <pre><code>Type                 Path                Dependencies\n----------------------------------------------------------------\nmise                 mise.toml           6\nmise                 .mise.toml          4\n\nTotal: 2 manifests\n</code></pre>"},{"location":"integrations/mise/#plan-mise-updates","title":"Plan mise Updates","text":"<pre><code>uptool plan --only=mise\n</code></pre> <p>Output:</p> <pre><code>mise.toml (mise):\nTool             Current         Target          Impact\n--------------------------------------------------------\ngo               1.23            1.25            minor\nnode             20              22              major\ngolangci-lint    2.6             2.7             minor\nterraform        1.5.0           1.10.5          minor\npython           3.11            3.13            minor\n\nTotal: 5 updates across 1 manifest\n</code></pre>"},{"location":"integrations/mise/#apply-mise-updates","title":"Apply mise Updates","text":"<pre><code># Dry run first\nuptool update --only=mise --dry-run --diff\n\n# Apply updates\nuptool update --only=mise\n\n# Then install new versions\nmise install\n</code></pre>"},{"location":"integrations/mise/#version-formats","title":"Version Formats","text":"<p>mise supports two format styles:</p>"},{"location":"integrations/mise/#string-format-simple","title":"String Format (Simple)","text":"<pre><code>[tools]\ngo = \"1.23\"\nnode = \"20\"\n</code></pre> <p>Recommended for most use cases.</p>"},{"location":"integrations/mise/#map-format-advanced","title":"Map Format (Advanced)","text":"<pre><code>[tools]\ngo = { version = \"1.23\", path = \".go-version\" }\nnode = { version = \"20\", prefix = \"v\" }\npython = { version = \"3.11\", virtualenv = \".venv\" }\n</code></pre> <p>Used when additional options are needed.</p> <p>uptool preserves the format - if map format is used, it stays map format.</p>"},{"location":"integrations/mise/#configuration","title":"Configuration","text":""},{"location":"integrations/mise/#update-policy","title":"Update Policy","text":"<pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: mise\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false\n</code></pre> <p>Update Levels:</p> <ul> <li><code>none</code> - No updates</li> <li><code>patch</code> - Only patch updates (1.23.0 \u2192 1.23.1)</li> <li><code>minor</code> - Patch + minor updates (1.23.0 \u2192 1.24.0)</li> <li><code>major</code> - All updates including major (1.23.0 \u2192 2.0.0)</li> </ul>"},{"location":"integrations/mise/#exclude-specific-tools","title":"Exclude Specific Tools","text":"<p>Pin to exact version (won't be updated based on policy):</p> <pre><code>[tools]\ngo = \"1.23\"              # Will be updated\nnode = \"20.10.0\"         # Exact version (patch specified)\n</code></pre>"},{"location":"integrations/mise/#tool-installation","title":"Tool Installation","text":"<p>uptool does NOT install tool versions.</p> <p>After updating <code>mise.toml</code>, install new versions:</p> <pre><code># Install all tools at specified versions\nmise install\n\n# Install specific tool\nmise install node\n\n# Verify installations\nmise current\n</code></pre>"},{"location":"integrations/mise/#config-file-locations","title":"Config File Locations","text":"<p>mise supports multiple config file locations:</p>"},{"location":"integrations/mise/#project-config","title":"Project Config","text":"<pre><code>my-project/\n\u251c\u2500\u2500 mise.toml                   # Project config (recommended)\n\u251c\u2500\u2500 .mise.toml                  # Hidden variant\n\u2514\u2500\u2500 subproject/\n    \u2514\u2500\u2500 mise.toml               # Nested project\n</code></pre>"},{"location":"integrations/mise/#global-config","title":"Global Config","text":"<pre><code>~/.config/mise/config.toml      # Global config\n</code></pre> <p>uptool scans and updates:</p> <ul> <li>\u2705 <code>mise.toml</code> in repository</li> <li>\u2705 <code>.mise.toml</code> in repository</li> <li>\u274c Global config (not in repo)</li> </ul>"},{"location":"integrations/mise/#per-directory-configuration","title":"Per-Directory Configuration","text":"<p>mise supports directory-specific configs:</p> <pre><code>monorepo/\n\u251c\u2500\u2500 mise.toml                   # Root tools\n\u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 mise.toml               # Frontend-specific tools\n\u2514\u2500\u2500 backend/\n    \u2514\u2500\u2500 mise.toml               # Backend-specific tools\n</code></pre> <p>Each <code>mise.toml</code> is updated independently.</p>"},{"location":"integrations/mise/#version-specification","title":"Version Specification","text":"<p>mise supports various version formats:</p>"},{"location":"integrations/mise/#exact-version","title":"Exact Version","text":"<pre><code>[tools]\ngo = \"1.23.0\"\n</code></pre>"},{"location":"integrations/mise/#partial-version-mise-auto-resolves","title":"Partial Version (mise auto-resolves)","text":"<pre><code>[tools]\ngo = \"1.23\"     # mise installs latest 1.23.x\nnode = \"20\"     # mise installs latest 20.x\n</code></pre> <p>uptool updates the partial version (1.23 \u2192 1.25).</p>"},{"location":"integrations/mise/#version-prefix","title":"Version Prefix","text":"<pre><code>[tools]\ngo = { version = \"1.23\", prefix = \"go\" }\n</code></pre> <p>uptool updates the version field only.</p>"},{"location":"integrations/mise/#legacy-tool-version-files","title":"Legacy Tool Version Files","text":"<p>mise can read from other version files:</p> <pre><code>[tools]\nnode = { version = \"20\", path = \".nvmrc\" }\npython = { version = \"3.11\", path = \".python-version\" }\n</code></pre> <p>uptool updates the version in mise.toml, not the referenced file.</p>"},{"location":"integrations/mise/#github-rate-limiting","title":"GitHub Rate Limiting","text":"<p>uptool queries GitHub Releases API for each tool.</p>"},{"location":"integrations/mise/#unauthenticated","title":"Unauthenticated","text":"<ul> <li>Rate limit: 60 requests/hour</li> <li>May be insufficient for many tools</li> </ul>"},{"location":"integrations/mise/#authenticated","title":"Authenticated","text":"<p>Set <code>GITHUB_TOKEN</code> environment variable:</p> <pre><code>export GITHUB_TOKEN=\"your_github_token\"\nuptool update --only=mise\n</code></pre> <p>Rate limit: 5000 requests/hour</p>"},{"location":"integrations/mise/#limitations","title":"Limitations","text":"<ol> <li>No version installation: uptool only updates <code>mise.toml</code></li> <li> <p>Solution: Run <code>mise install</code> after</p> </li> <li> <p>GitHub-based tools only: Tools must release via GitHub Releases</p> </li> <li> <p>Non-GitHub tools not yet supported</p> </li> <li> <p>No backend validation: Doesn't check mise backend availability</p> </li> <li> <p>Solution: Test with <code>mise install</code> before committing</p> </li> <li> <p>No .mise.lock: mise doesn't use lockfiles</p> </li> <li> <p>Versions are declarative</p> </li> <li> <p>No plugin version updates: Only tool versions, not mise plugins</p> </li> <li>mise plugins managed separately</li> </ol>"},{"location":"integrations/mise/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/mise/#tool-not-found","title":"Tool Not Found","text":"<p>Problem: \"Tool not found in GitHub\"</p> <p>Causes:</p> <ol> <li>Tool name doesn't map to known GitHub repository</li> <li>Tool uses non-GitHub backend</li> <li>Tool name misspelled</li> </ol> <p>Solutions:</p> <pre><code># Check mise tool name\nmise ls-remote &lt;tool&gt;\n\n# Verify tool in mise.toml\ncat mise.toml\n\n# Test tool availability\nmise install &lt;tool&gt;@latest\n</code></pre>"},{"location":"integrations/mise/#github-rate-limit","title":"GitHub Rate Limit","text":"<p>Problem: \"API rate limit exceeded\"</p> <p>Causes:</p> <ol> <li>Many tools without authentication</li> <li>Frequent updates</li> </ol> <p>Solutions:</p> <pre><code># Set GitHub token\nexport GITHUB_TOKEN=\"ghp_xxxxxxxxxxxx\"\n\n# Verify rate limit\ncurl -H \"Authorization: token $GITHUB_TOKEN\" \\\n  https://api.github.com/rate_limit\n\n# Run update\nuptool update --only=mise\n</code></pre>"},{"location":"integrations/mise/#version-not-available","title":"Version Not Available","text":"<p>Problem: uptool suggests version that doesn't exist</p> <p>Causes:</p> <ol> <li>Version numbering changed</li> <li>Pre-release versions included</li> </ol> <p>Solutions:</p> <pre><code># Check available versions\nmise ls-remote &lt;tool&gt;\n\n# Or check GitHub releases\ngh release list --repo golang/go\n\n# Exclude pre-releases in policy\n# uptool.yaml:\npolicy:\n  allow_prerelease: false\n</code></pre>"},{"location":"integrations/mise/#installation-fails","title":"Installation Fails","text":"<p>Problem: <code>mise install</code> fails after update</p> <p>Causes:</p> <ol> <li>New version has different dependencies</li> <li>Backend not available</li> <li>Build requirements missing</li> </ol> <p>Solutions:</p> <pre><code># Check mise backend\nmise doctor\n\n# Update mise\nmise self-update\n\n# Install build dependencies\n# (varies by tool and OS)\n\n# Check specific tool\nmise install &lt;tool&gt;@&lt;version&gt; --verbose\n</code></pre>"},{"location":"integrations/mise/#toml-parse-error","title":"TOML Parse Error","text":"<p>Problem: \"Failed to parse mise.toml\"</p> <p>Causes:</p> <ol> <li>Invalid TOML syntax</li> <li>Unsupported mise.toml features</li> </ol> <p>Solutions:</p> <pre><code># Validate TOML\ncat mise.toml | mise validate\n\n# Or use TOML linter\ntaplo format mise.toml --check\n\n# Fix syntax errors\n</code></pre>"},{"location":"integrations/mise/#best-practices","title":"Best Practices","text":"<ol> <li>Always install after updating:</li> </ol> <pre><code>uptool update --only=mise\nmise install\ngit add mise.toml\ngit commit -m \"chore: update tool versions\"\n</code></pre> <ol> <li>Test versions before committing:</li> </ol> <pre><code>mise install\nmise current  # Verify all tools installed\n# Run your test suite\n</code></pre> <ol> <li>Use string format when possible:</li> </ol> <pre><code># Preferred (simpler)\n[tools]\ngo = \"1.23\"\n\n# Only when needed\n[tools]\ngo = { version = \"1.23\", path = \".go-version\" }\n</code></pre> <ol> <li>Use conservative policy:</li> </ol> <pre><code># For production\npolicy:\n  update: patch\n\n# For development\npolicy:\n  update: minor\n</code></pre> <ol> <li>Set GitHub token:</li> </ol> <pre><code># In CI/CD\nenv:\n  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n# Locally\nexport GITHUB_TOKEN=\"your_token\"\n</code></pre> <ol> <li>Document required tools:</li> </ol> <pre><code># mise.toml\n[tools]\n# Development tools\ngo = \"1.23\"\nnode = \"20\"\n\n# CI/CD tools\ngolangci-lint = \"2.6\"\n</code></pre>"},{"location":"integrations/mise/#mise-version-compatibility","title":"mise Version Compatibility","text":"<p>uptool works with mise &gt;= 2024.1.0.</p> <p>mise &lt; 2024.1.0 (rtx era):</p> <ul> <li>May work but not tested</li> <li>TOML format may differ</li> </ul> <p>mise &gt;= 2024.1.0:</p> <ul> <li>\u2705 Fully supported</li> <li>Standard <code>mise.toml</code> format</li> </ul>"},{"location":"integrations/mise/#file-naming","title":"File Naming","text":"<p>mise supports both naming conventions:</p> <ul> <li><code>mise.toml</code> - Visible file (recommended)</li> <li><code>.mise.toml</code> - Hidden file (legacy/preference)</li> </ul> <p>uptool scans both.</p>"},{"location":"integrations/mise/#comparison-with-asdf","title":"Comparison with asdf","text":"<p>mise and asdf are similar:</p> Feature mise asdf Config file <code>mise.toml</code> <code>.tool-versions</code> Format TOML Simple text Version syntax <code>tool = \"version\"</code> <code>tool version</code> Multiple versions Limited Yes Performance Faster (Rust) Slower (Bash) <p>See asdf integration for asdf-specific documentation.</p>"},{"location":"integrations/mise/#special-tool-names","title":"Special Tool Names","text":"<p>Some tools have aliases:</p> <pre><code>[tools]\nnode = \"20\"      # Also: nodejs\ngo = \"1.23\"      # Also: golang\n</code></pre> <p>uptool recognizes common aliases.</p>"},{"location":"integrations/mise/#see-also","title":"See Also","text":"<ul> <li>mise Documentation</li> <li>mise Configuration</li> <li>mise Tool Backends</li> <li>Manifest Files Reference</li> </ul>"},{"location":"integrations/npm/","title":"npm Integration","text":"<p>The npm integration updates JavaScript/Node.js dependencies in <code>package.json</code> files.</p>"},{"location":"integrations/npm/#overview","title":"Overview","text":"<p>Integration ID: <code>npm</code></p> <p>Manifest Files: <code>package.json</code></p> <p>Update Strategy: Custom JSON rewriting</p> <p>Registry: npm Registry API (<code>https://registry.npmjs.org</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/npm/#what-gets-updated","title":"What Gets Updated","text":"<p>The npm integration updates all dependency types in <code>package.json</code>:</p> <ul> <li><code>dependencies</code> - Production dependencies</li> <li><code>devDependencies</code> - Development-only dependencies</li> <li><code>peerDependencies</code> - Peer dependencies (plugins, extensions)</li> <li><code>optionalDependencies</code> - Optional dependencies</li> </ul>"},{"location":"integrations/npm/#example","title":"Example","text":"<p>Before (<code>package.json</code>):</p> <pre><code>{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"lodash\": \"~4.17.20\",\n    \"axios\": \"&gt;=0.27.0\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.0.0\",\n    \"@types/node\": \"^18.0.0\"\n  }\n}\n</code></pre> <p>After (uptool update):</p> <pre><code>{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"express\": \"^4.19.2\",\n    \"lodash\": \"~4.17.21\",\n    \"axios\": \"&gt;=1.7.0\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.7.0\",\n    \"@types/node\": \"^22.0.0\"\n  }\n}\n</code></pre>"},{"location":"integrations/npm/#version-constraint-preservation","title":"Version Constraint Preservation","text":"<p>The npm integration preserves version constraint prefixes:</p> Constraint Meaning Example Before Example After <code>^</code> Compatible with (minor) <code>^4.18.0</code> <code>^4.19.2</code> <code>~</code> Approximately equivalent <code>~4.17.20</code> <code>~4.17.21</code> <code>&gt;=</code> Greater than or equal <code>&gt;=0.27.0</code> <code>&gt;=1.7.0</code> <code>&gt;</code> Greater than <code>&gt;0.27.0</code> <code>&gt;1.7.0</code> <code>&lt;=</code> Less than or equal <code>&lt;=1.0.0</code> <code>&lt;=1.0.0</code> <code>&lt;</code> Less than <code>&lt;2.0.0</code> <code>&lt;2.0.0</code> <code>=</code> Exact version <code>=1.0.0</code> <code>=1.5.0</code> (none) Exact version <code>1.0.0</code> <code>1.5.0</code> <p>Note: Only the version number is updated, the constraint operator is preserved.</p>"},{"location":"integrations/npm/#cli-usage","title":"CLI Usage","text":""},{"location":"integrations/npm/#scan-for-npm-dependencies","title":"Scan for npm Dependencies","text":"<pre><code>uptool scan --only=npm\n</code></pre> <p>Output:</p> <pre><code>Type                 Path                Dependencies\n----------------------------------------------------------------\nnpm                  package.json        12\nnpm                  apps/web/package.json    8\nnpm                  apps/api/package.json    15\n\nTotal: 3 manifests\n</code></pre>"},{"location":"integrations/npm/#plan-npm-updates","title":"Plan npm Updates","text":"<pre><code>uptool plan --only=npm\n</code></pre> <p>Output:</p> <pre><code>package.json (npm):\nPackage          Current         Target          Impact\n--------------------------------------------------------\nexpress          ^4.18.0         ^4.19.2         patch\nlodash           ~4.17.20        ~4.17.21        patch\naxios            &gt;=0.27.0        &gt;=1.7.0         major\n\napps/web/package.json (npm):\nPackage          Current         Target          Impact\n--------------------------------------------------------\nreact            ^18.2.0         ^18.3.1         minor\nreact-dom        ^18.2.0         ^18.3.1         minor\n\nTotal: 5 updates across 2 manifests\n</code></pre>"},{"location":"integrations/npm/#apply-npm-updates","title":"Apply npm Updates","text":"<pre><code># Dry run first\nuptool update --only=npm --dry-run --diff\n\n# Apply updates\nuptool update --only=npm\n\n# Then regenerate lockfile\nnpm install\n</code></pre>"},{"location":"integrations/npm/#monorepo-support","title":"Monorepo Support","text":"<p>The npm integration supports npm workspaces:</p> <pre><code>my-monorepo/\n\u251c\u2500\u2500 package.json           # Root workspace\n\u251c\u2500\u2500 package-lock.json\n\u2514\u2500\u2500 packages/\n    \u251c\u2500\u2500 app/\n    \u2502   \u2514\u2500\u2500 package.json   # Workspace member\n    \u251c\u2500\u2500 lib/\n    \u2502   \u2514\u2500\u2500 package.json   # Workspace member\n    \u2514\u2500\u2500 utils/\n        \u2514\u2500\u2500 package.json   # Workspace member\n</code></pre> <p>Each <code>package.json</code> is updated independently.</p> <p>After updating, run <code>npm install</code> at the root to update the root lockfile.</p>"},{"location":"integrations/npm/#configuration","title":"Configuration","text":""},{"location":"integrations/npm/#update-policy","title":"Update Policy","text":"<p>Control which updates are applied:</p> <pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false    # Don't update to pre-release versions\n      pin: false                 # Don't pin to exact versions\n</code></pre> <p>Update Levels:</p> <ul> <li><code>none</code> - No updates</li> <li><code>patch</code> - Only patch updates (1.0.0 \u2192 1.0.1)</li> <li><code>minor</code> - Patch + minor updates (1.0.0 \u2192 1.1.0)</li> <li><code>major</code> - All updates including major (1.0.0 \u2192 2.0.0)</li> </ul>"},{"location":"integrations/npm/#exclude-specific-packages","title":"Exclude Specific Packages","text":"<p>To exclude specific packages, use lockfiles or version pinning:</p> <pre><code>{\n  \"dependencies\": {\n    \"old-package\": \"1.0.0\"    // Exact version, won't update\n  }\n}\n</code></pre> <p>Or use npm's <code>overrides</code> field:</p> <pre><code>{\n  \"overrides\": {\n    \"old-package\": \"1.0.0\"\n  }\n}\n</code></pre>"},{"location":"integrations/npm/#registry-api","title":"Registry API","text":"<p>The npm integration queries the npm Registry API:</p> <p>Endpoint: <code>https://registry.npmjs.org/{package}</code></p> <p>Example:</p> <pre><code>curl https://registry.npmjs.org/express\n</code></pre> <p>Returns:</p> <pre><code>{\n  \"name\": \"express\",\n  \"dist-tags\": {\n    \"latest\": \"4.19.2\"\n  },\n  \"versions\": {\n    \"4.19.2\": { ... },\n    \"4.19.1\": { ... },\n    ...\n  }\n}\n</code></pre>"},{"location":"integrations/npm/#private-registries","title":"Private Registries","text":"<p>uptool respects npm's registry configuration:</p>"},{"location":"integrations/npm/#npm-config","title":"npm config","text":"<pre><code># Set private registry\nnpm config set registry https://registry.company.com/\n\n# Or use .npmrc\necho \"registry=https://registry.company.com/\" &gt; .npmrc\n</code></pre>"},{"location":"integrations/npm/#authentication","title":"Authentication","text":"<p>uptool does NOT handle npm authentication. Configure npm auth separately:</p> <pre><code># Login to private registry\nnpm login --registry=https://registry.company.com/\n\n# Or use auth token in .npmrc\necho \"//registry.company.com/:_authToken=TOKEN\" &gt;&gt; ~/.npmrc\n</code></pre>"},{"location":"integrations/npm/#limitations","title":"Limitations","text":"<ol> <li>No lockfile updates: uptool only updates <code>package.json</code>, not <code>package-lock.json</code></li> <li> <p>Solution: Run <code>npm install</code> after updating</p> </li> <li> <p>No workspace dependency resolution: Workspaces are updated independently</p> </li> <li> <p>Solution: Run <code>npm install</code> at root to resolve cross-workspace dependencies</p> </li> <li> <p>No peer dependency warnings: uptool doesn't warn about peer dependency conflicts</p> </li> <li> <p>Solution: Run <code>npm install</code> to see peer dependency warnings</p> </li> <li> <p>No package availability check: uptool assumes packages exist in the registry</p> </li> <li>Solution: Check <code>npm install</code> output for missing packages</li> </ol>"},{"location":"integrations/npm/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/npm/#updates-not-applied","title":"Updates Not Applied","text":"<p>Problem: <code>uptool plan</code> shows updates but <code>uptool update</code> doesn't apply them</p> <p>Causes:</p> <ol> <li>Policy restrictions in <code>uptool.yaml</code></li> <li>Version constraints don't allow the update</li> </ol> <p>Solutions:</p> <pre><code># Check policy\ncat uptool.yaml\n\n# Try with different policy\nuptool update --only=npm   # Uses config policy\n\n# Check version constraints\ncat package.json\n</code></pre>"},{"location":"integrations/npm/#registry-errors","title":"Registry Errors","text":"<p>Problem: \"Failed to fetch package info from registry\"</p> <p>Causes:</p> <ol> <li>Network connectivity issues</li> <li>Private registry authentication failed</li> <li>Package doesn't exist</li> </ol> <p>Solutions:</p> <pre><code># Test registry connectivity\nnpm view express\n\n# Check registry configuration\nnpm config get registry\n\n# Test authentication\nnpm whoami\n</code></pre>"},{"location":"integrations/npm/#lockfile-out-of-sync","title":"Lockfile Out of Sync","text":"<p>Problem: After updating, <code>npm install</code> reports conflicts</p> <p>Solution:</p> <pre><code># Delete lockfile and reinstall\nrm package-lock.json\nnpm install\n\n# Or use npm ci for clean install\nrm -rf node_modules package-lock.json\nnpm ci\n</code></pre>"},{"location":"integrations/npm/#best-practices","title":"Best Practices","text":"<ol> <li>Always regenerate lockfile:</li> </ol> <pre><code>uptool update --only=npm\nnpm install\ngit add package.json package-lock.json\ngit commit -m \"chore(deps): update npm dependencies\"\n</code></pre> <ol> <li>Test after updating:</li> </ol> <pre><code>npm test\nnpm run build\n</code></pre> <ol> <li>Review major updates carefully:</li> </ol> <pre><code># Plan first to see impact\nuptool plan --only=npm\n\n# Check BREAKING CHANGES in changelogs\n</code></pre> <ol> <li>Use separate PRs for major updates:</li> </ol> <pre><code># Minor/patch updates together\nuptool update --only=npm  # (with policy: minor)\n\n# Major updates separately\n# (requires manual policy override)\n</code></pre> <ol> <li>Pin critical dependencies:</li> </ol> <pre><code>{\n  \"dependencies\": {\n    \"critical-package\": \"1.2.3\"  // Exact version\n  }\n}\n</code></pre>"},{"location":"integrations/npm/#see-also","title":"See Also","text":"<ul> <li>npm Registry API</li> <li>npm Workspaces</li> <li>Semantic Versioning</li> <li>Manifest Files Reference</li> </ul>"},{"location":"integrations/precommit/","title":"Pre-Commit Integration","text":"<p>The pre-commit integration updates pre-commit hook versions in <code>.pre-commit-config.yaml</code> files.</p>"},{"location":"integrations/precommit/#overview","title":"Overview","text":"<p>Integration ID: <code>precommit</code></p> <p>Manifest Files: <code>.pre-commit-config.yaml</code></p> <p>Update Strategy: Native command - Uses <code>pre-commit autoupdate</code></p> <p>Registry: GitHub Releases (for each hook repository)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/precommit/#what-gets-updated","title":"What Gets Updated","text":"<p>The pre-commit integration updates hook repository revisions:</p> <ul> <li><code>repos[].rev</code> - Git tag/commit of each hook repository</li> </ul>"},{"location":"integrations/precommit/#example","title":"Example","text":"<p>Before (<code>.pre-commit-config.yaml</code>):</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n\n  - repo: https://github.com/PyCQA/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n</code></pre> <p>After (uptool update):</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v6.0.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n\n  - repo: https://github.com/psf/black\n    rev: 24.10.0\n    hooks:\n      - id: black\n\n  - repo: https://github.com/PyCQA/flake8\n    rev: 7.1.1\n    hooks:\n      - id: flake8\n</code></pre>"},{"location":"integrations/precommit/#why-native-command","title":"Why Native Command?","text":"<p>uptool uses <code>pre-commit autoupdate</code> instead of custom rewriting because:</p> <ol> <li>Manifest-first: <code>pre-commit autoupdate</code> updates <code>.pre-commit-config.yaml</code> directly</li> <li>Comprehensive: Handles all edge cases (local hooks, complex revisions, etc.)</li> <li>Maintained: pre-commit team maintains update logic</li> <li>Reliable: Well-tested by entire pre-commit ecosystem</li> </ol> <p>This aligns with uptool's philosophy: use native commands when they update manifests.</p>"},{"location":"integrations/precommit/#cli-usage","title":"CLI Usage","text":""},{"location":"integrations/precommit/#scan-for-pre-commit-configs","title":"Scan for Pre-Commit Configs","text":"<pre><code>uptool scan --only=precommit\n</code></pre> <p>Output:</p> <pre><code>Type                 Path                        Dependencies\n----------------------------------------------------------------\nprecommit            .pre-commit-config.yaml     3\n\nTotal: 1 manifest\n</code></pre>"},{"location":"integrations/precommit/#plan-pre-commit-updates","title":"Plan Pre-Commit Updates","text":"<pre><code>uptool plan --only=precommit\n</code></pre> <p>Output:</p> <pre><code>.pre-commit-config.yaml (precommit):\nHook                 Current         Target          Impact\n--------------------------------------------------------\npre-commit-hooks     v4.3.0          v6.0.0          major\nblack                22.10.0         24.10.0         major\nflake8               5.0.4           7.1.1           major\n\nTotal: 3 updates across 1 manifest\n</code></pre>"},{"location":"integrations/precommit/#apply-pre-commit-updates","title":"Apply Pre-Commit Updates","text":"<pre><code># Dry run first\nuptool update --only=precommit --dry-run --diff\n\n# Apply updates\nuptool update --only=precommit\n\n# No additional steps needed!\n# (pre-commit autoupdate already updated the manifest)\n</code></pre>"},{"location":"integrations/precommit/#configuration","title":"Configuration","text":""},{"location":"integrations/precommit/#update-policy","title":"Update Policy","text":"<pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: precommit\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false\n</code></pre> <p>Update Levels:</p> <ul> <li><code>none</code> - No updates</li> <li><code>patch</code> - Only patch updates</li> <li><code>minor</code> - Patch + minor updates</li> <li><code>major</code> - All updates including major</li> </ul> <p>Note: Policy is passed to <code>pre-commit autoupdate</code> where supported.</p>"},{"location":"integrations/precommit/#hook-types","title":"Hook Types","text":""},{"location":"integrations/precommit/#remote-hooks","title":"Remote Hooks","text":"<p>Standard GitHub-based hooks:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: trailing-whitespace\n</code></pre>"},{"location":"integrations/precommit/#local-hooks","title":"Local Hooks","text":"<p>Local hooks are NOT updated:</p> <pre><code>repos:\n  - repo: local\n    hooks:\n      - id: custom-check\n        name: Custom Check\n        entry: scripts/custom-check.sh\n        language: script\n</code></pre>"},{"location":"integrations/precommit/#meta-hooks","title":"Meta Hooks","text":"<p>Meta hooks using <code>meta</code> repository:</p> <pre><code>repos:\n  - repo: meta\n    hooks:\n      - id: check-hooks-apply\n      - id: check-useless-excludes\n</code></pre> <p>Meta hooks have no version and are NOT updated.</p>"},{"location":"integrations/precommit/#pre-commit-installation","title":"Pre-Commit Installation","text":"<p>uptool does NOT install or manage pre-commit itself.</p> <p>Ensure pre-commit is installed:</p> <pre><code># Install pre-commit\npip install pre-commit\n# or\nbrew install pre-commit\n# or\nmise install pre-commit\n\n# Install hooks\npre-commit install\n</code></pre>"},{"location":"integrations/precommit/#requirements","title":"Requirements","text":"<p>The pre-commit integration requires:</p> <ol> <li>pre-commit installed: Must be available in <code>$PATH</code></li> <li>Valid config: <code>.pre-commit-config.yaml</code> must be valid YAML</li> <li>Git repository: pre-commit requires a git repository</li> </ol>"},{"location":"integrations/precommit/#checking-requirements","title":"Checking Requirements","text":"<pre><code># Check pre-commit is installed\nwhich pre-commit\npre-commit --version\n\n# Validate config\npre-commit validate-config\n\n# Ensure in git repo\ngit status\n</code></pre>"},{"location":"integrations/precommit/#github-rate-limiting","title":"GitHub Rate Limiting","text":"<p><code>pre-commit autoupdate</code> queries GitHub API for each hook repository.</p>"},{"location":"integrations/precommit/#unauthenticated","title":"Unauthenticated","text":"<ul> <li>Rate limit: 60 requests/hour</li> <li>Usually sufficient for small configs</li> </ul>"},{"location":"integrations/precommit/#authenticated","title":"Authenticated","text":"<p>Set <code>GITHUB_TOKEN</code> or configure git credentials:</p> <pre><code># Method 1: Environment variable\nexport GITHUB_TOKEN=\"your_github_token\"\nuptool update --only=precommit\n\n# Method 2: Git credential helper\ngit config --global credential.helper store\n</code></pre>"},{"location":"integrations/precommit/#limitations","title":"Limitations","text":"<ol> <li>Requires pre-commit installed: Must have <code>pre-commit</code> in PATH</li> <li> <p>Solution: Install pre-commit first</p> </li> <li> <p>Git repository required: pre-commit needs git</p> </li> <li> <p>Solution: Ensure you're in a git repository</p> </li> <li> <p>No offline mode: Requires internet to check versions</p> </li> <li> <p>Solution: Update when online</p> </li> <li> <p>Limited policy control: Pre-commit decides what to update</p> </li> <li>uptool passes preferences where supported</li> </ol>"},{"location":"integrations/precommit/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/precommit/#pre-commit-not-found","title":"pre-commit Not Found","text":"<p>Problem: \"pre-commit command not found\"</p> <p>Causes:</p> <ol> <li>pre-commit not installed</li> <li>Not in PATH</li> </ol> <p>Solutions:</p> <pre><code># Install pre-commit\npip install pre-commit\n\n# Or via package manager\nbrew install pre-commit       # macOS\napt install pre-commit         # Debian/Ubuntu\n\n# Or via mise\nmise install pre-commit\n\n# Verify installation\nwhich pre-commit\npre-commit --version\n</code></pre>"},{"location":"integrations/precommit/#invalid-config","title":"Invalid Config","text":"<p>Problem: \"Invalid .pre-commit-config.yaml\"</p> <p>Causes:</p> <ol> <li>YAML syntax errors</li> <li>Invalid hook configuration</li> </ol> <p>Solutions:</p> <pre><code># Validate config\npre-commit validate-config\n\n# Check YAML syntax\nyamllint .pre-commit-config.yaml\n\n# Fix errors and retry\n</code></pre>"},{"location":"integrations/precommit/#hook-repository-not-found","title":"Hook Repository Not Found","text":"<p>Problem: \"Repository not found\" error</p> <p>Causes:</p> <ol> <li>Hook repository URL incorrect</li> <li>Repository deleted or renamed</li> <li>Network issues</li> </ol> <p>Solutions:</p> <pre><code># Verify repository exists\ncurl -I https://github.com/pre-commit/pre-commit-hooks\n\n# Check URL in config\ngrep repo .pre-commit-config.yaml\n\n# Update URL if repository moved\n</code></pre>"},{"location":"integrations/precommit/#github-rate-limit","title":"GitHub Rate Limit","text":"<p>Problem: \"API rate limit exceeded\"</p> <p>Causes:</p> <ol> <li>Too many hooks without authentication</li> <li>Running updates frequently</li> </ol> <p>Solutions:</p> <pre><code># Set GitHub token\nexport GITHUB_TOKEN=\"ghp_xxxxxxxxxxxx\"\n\n# Or configure git credentials\ngit config --global credential.helper store\ngit fetch  # Trigger credential prompt\n\n# Check rate limit\ncurl -H \"Authorization: token $GITHUB_TOKEN\" \\\n  https://api.github.com/rate_limit\n</code></pre>"},{"location":"integrations/precommit/#hooks-not-installing","title":"Hooks Not Installing","text":"<p>Problem: After update, <code>pre-commit run</code> fails</p> <p>Causes:</p> <ol> <li>New hook version incompatible</li> <li>Hook environment not set up</li> </ol> <p>Solutions:</p> <pre><code># Clean and reinstall hooks\npre-commit clean\npre-commit install-hooks\n\n# Run specific hook\npre-commit run &lt;hook-id&gt; --all-files\n\n# Check hook logs\npre-commit run --verbose\n</code></pre>"},{"location":"integrations/precommit/#best-practices","title":"Best Practices","text":"<ol> <li>Test after updating:</li> </ol> <pre><code>uptool update --only=precommit\npre-commit run --all-files\n</code></pre> <ol> <li>Review hook changelogs:</li> </ol> <pre><code># Check for breaking changes\n# Visit hook repository's releases page\n</code></pre> <ol> <li>Update regularly:</li> </ol> <pre><code># Weekly or monthly\nuptool update --only=precommit\n</code></pre> <ol> <li>Pin critical hooks (if needed):</li> </ol> <pre><code>repos:\n  - repo: https://github.com/psf/black\n    rev: 22.10.0  # Exact version\n    hooks:\n      - id: black\n</code></pre> <ol> <li>Use GitHub token in CI:</li> </ol> <pre><code># .github/workflows/update.yml\nenv:\n  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\nsteps:\n  - uses: santosr2/uptool@v0\n    with:\n      command: update\n      only: precommit\n</code></pre> <ol> <li>Commit lock files if used:</li> </ol> <pre><code>git add .pre-commit-config.yaml\ngit commit -m \"chore: update pre-commit hooks\"\n</code></pre>"},{"location":"integrations/precommit/#pre-commit-version-compatibility","title":"Pre-Commit Version Compatibility","text":"<p>uptool works with pre-commit &gt;= 2.0.0.</p> <p>pre-commit &lt; 2.0.0:</p> <ul> <li>Not tested</li> <li>May not support all features</li> </ul> <p>pre-commit &gt;= 2.0.0:</p> <ul> <li>\u2705 Fully supported</li> <li><code>autoupdate</code> command available</li> </ul> <p>pre-commit &gt;= 3.0.0:</p> <ul> <li>\u2705 Fully supported</li> <li>Improved update logic</li> </ul>"},{"location":"integrations/precommit/#minimum-pre-commit-version","title":"Minimum Pre-Commit Version","text":"<p>Some hooks require specific pre-commit versions:</p> <pre><code>minimum_pre_commit_version: 2.9.0\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: check-yaml\n</code></pre> <p>uptool respects this setting when running <code>pre-commit autoupdate</code>.</p>"},{"location":"integrations/precommit/#see-also","title":"See Also","text":"<ul> <li>Pre-Commit Documentation</li> <li>Pre-Commit Hooks</li> <li>Supported Hooks</li> <li>Manifest Files Reference</li> </ul>"},{"location":"integrations/terraform/","title":"Terraform Integration","text":"<p>The Terraform integration updates Terraform module versions in <code>*.tf</code> files.</p>"},{"location":"integrations/terraform/#overview","title":"Overview","text":"<p>Integration ID: <code>terraform</code></p> <p>Manifest Files: <code>*.tf</code> (any Terraform file)</p> <p>Update Strategy: HCL parsing and rewriting via <code>hashicorp/hcl</code></p> <p>Registry: Terraform Registry API (<code>https://registry.terraform.io</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/terraform/#what-gets-updated","title":"What Gets Updated","text":"<p>The Terraform integration currently updates:</p> <ul> <li><code>module</code> block <code>version</code> attributes - Module versions from Terraform Registry</li> </ul> <p>Future support (not yet implemented):</p> <ul> <li>Provider versions in <code>required_providers</code> blocks</li> <li>Module source versions in git URLs</li> </ul>"},{"location":"integrations/terraform/#example","title":"Example","text":"<p>Before (<code>main.tf</code>):</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"\n\n  name = \"my-vpc\"\n  cidr = \"10.0.0.0/16\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 4.0\"\n\n  name   = \"my-sg\"\n  vpc_id = module.vpc.vpc_id\n}\n\nmodule \"rds\" {\n  source  = \"terraform-aws-modules/rds/aws\"\n  version = \"&gt;= 5.0\"\n\n  identifier = \"mydb\"\n}\n</code></pre> <p>After (uptool update):</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"5.13.0\"\n\n  name = \"my-vpc\"\n  cidr = \"10.0.0.0/16\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 5.0\"\n\n  name   = \"my-sg\"\n  vpc_id = module.vpc.vpc_id\n}\n\nmodule \"rds\" {\n  source  = \"terraform-aws-modules/rds/aws\"\n  version = \"&gt;= 6.0\"\n\n  identifier = \"mydb\"\n}\n</code></pre>"},{"location":"integrations/terraform/#version-constraints","title":"Version Constraints","text":"<p>Terraform supports various version constraint operators:</p> Constraint Meaning Example Before Example After <code>=</code> Exact version <code>= 3.0.0</code> <code>= 5.13.0</code> <code>~&gt;</code> Pessimistic constraint <code>~&gt; 4.0</code> <code>~&gt; 5.0</code> <code>&gt;=</code> Greater than or equal <code>&gt;= 5.0</code> <code>&gt;= 6.0</code> <code>&gt;</code> Greater than <code>&gt; 3.0</code> <code>&gt; 5.0</code> <code>&lt;=</code> Less than or equal <code>&lt;= 6.0</code> <code>&lt;= 8.0</code> <code>&lt;</code> Less than <code>&lt; 6.0</code> <code>&lt; 8.0</code> (none) Exact version <code>3.0.0</code> <code>5.13.0</code> <p>uptool preserves the constraint operator and updates the version number.</p>"},{"location":"integrations/terraform/#cli-usage","title":"CLI Usage","text":""},{"location":"integrations/terraform/#scan-for-terraform-modules","title":"Scan for Terraform Modules","text":"<pre><code>uptool scan --only=terraform\n</code></pre> <p>Output:</p> <pre><code>Type                 Path                    Dependencies\n----------------------------------------------------------------\nterraform            main.tf                 3\nterraform            modules/network/main.tf  2\nterraform            infra/staging/main.tf    5\n\nTotal: 3 manifests\n</code></pre>"},{"location":"integrations/terraform/#plan-terraform-updates","title":"Plan Terraform Updates","text":"<pre><code>uptool plan --only=terraform\n</code></pre> <p>Output:</p> <pre><code>main.tf (terraform):\nModule           Current         Target          Impact\n--------------------------------------------------------\nvpc              3.0.0           5.13.0          major\nsecurity_group   ~&gt; 4.0          ~&gt; 5.0          major\nrds              &gt;= 5.0          &gt;= 6.0          major\n\nmodules/network/main.tf (terraform):\nModule           Current         Target          Impact\n--------------------------------------------------------\nsubnets          2.0.0           2.5.0           minor\n\nTotal: 4 updates across 2 manifests\n</code></pre>"},{"location":"integrations/terraform/#apply-terraform-updates","title":"Apply Terraform Updates","text":"<pre><code># Dry run first\nuptool update --only=terraform --dry-run --diff\n\n# Apply updates\nuptool update --only=terraform\n\n# Then upgrade Terraform lockfile\nterraform init -upgrade\n</code></pre>"},{"location":"integrations/terraform/#module-sources","title":"Module Sources","text":""},{"location":"integrations/terraform/#terraform-registry-modules","title":"Terraform Registry Modules","text":"<p>Standard format for registry modules:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"\n}\n</code></pre> <p>Format: <code>NAMESPACE/NAME/PROVIDER</code></p> <p>Supported registries:</p> <ul> <li>Public Terraform Registry (default)</li> <li>Private Terraform Cloud/Enterprise registries (future)</li> </ul>"},{"location":"integrations/terraform/#git-sources","title":"Git Sources","text":"<p>Not yet supported by uptool:</p> <pre><code>module \"consul\" {\n  source = \"git::https://github.com/hashicorp/consul.git?ref=v1.0.0\"\n}\n</code></pre>"},{"location":"integrations/terraform/#local-modules","title":"Local Modules","text":"<p>Not applicable (no version):</p> <pre><code>module \"vpc\" {\n  source = \"./modules/vpc\"\n}\n</code></pre>"},{"location":"integrations/terraform/#configuration","title":"Configuration","text":""},{"location":"integrations/terraform/#update-policy","title":"Update Policy","text":"<pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: terraform\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false\n</code></pre> <p>Update Levels:</p> <ul> <li><code>none</code> - No updates</li> <li><code>patch</code> - Only patch updates (3.0.0 \u2192 3.0.1)</li> <li><code>minor</code> - Patch + minor updates (3.0.0 \u2192 3.1.0)</li> <li><code>major</code> - All updates including major (3.0.0 \u2192 5.0.0)</li> </ul>"},{"location":"integrations/terraform/#exclude-specific-modules","title":"Exclude Specific Modules","text":"<p>Pin to exact version:</p> <pre><code>module \"critical\" {\n  source  = \"terraform-aws-modules/rds/aws\"\n  version = \"5.0.0\"  # Exact version, won't update\n}\n</code></pre>"},{"location":"integrations/terraform/#terraform-lock-file","title":"Terraform Lock File","text":"<p>uptool does NOT update <code>.terraform.lock.hcl</code>.</p> <p>After updating module versions, regenerate the lockfile:</p> <pre><code># Upgrade modules and providers\nterraform init -upgrade\n\n# Or just recalculate hashes\nterraform providers lock\n</code></pre>"},{"location":"integrations/terraform/#monorepo-multi-environment","title":"Monorepo / Multi-Environment","text":"<p>Common structure:</p> <pre><code>terraform/\n\u251c\u2500\u2500 environments/\n\u2502   \u251c\u2500\u2500 dev/\n\u2502   \u2502   \u2514\u2500\u2500 main.tf          # Updated independently\n\u2502   \u251c\u2500\u2500 staging/\n\u2502   \u2502   \u2514\u2500\u2500 main.tf          # Updated independently\n\u2502   \u2514\u2500\u2500 prod/\n\u2502       \u2514\u2500\u2500 main.tf          # Updated independently\n\u2514\u2500\u2500 modules/\n    \u251c\u2500\u2500 network/\n    \u2502   \u2514\u2500\u2500 main.tf          # Updated independently\n    \u2514\u2500\u2500 database/\n        \u2514\u2500\u2500 main.tf          # Updated independently\n</code></pre> <p>Each <code>*.tf</code> file is scanned and updated independently.</p>"},{"location":"integrations/terraform/#private-registries","title":"Private Registries","text":""},{"location":"integrations/terraform/#terraform-cloud","title":"Terraform Cloud","text":"<p>Configure Terraform CLI:</p> <pre><code># ~/.terraformrc\ncredentials \"app.terraform.io\" {\n  token = \"YOUR_TOKEN\"\n}\n</code></pre> <p>uptool respects Terraform's credential configuration.</p>"},{"location":"integrations/terraform/#terraform-enterprise","title":"Terraform Enterprise","text":"<pre><code>module \"private\" {\n  source  = \"app.terraform.io/my-org/vpc/aws\"\n  version = \"1.0.0\"\n}\n</code></pre> <p>Ensure Terraform is authenticated to your Enterprise instance.</p>"},{"location":"integrations/terraform/#limitations","title":"Limitations","text":"<ol> <li>No .terraform.lock.hcl updates: uptool only updates <code>*.tf</code> files</li> <li> <p>Solution: Run <code>terraform init -upgrade</code> after</p> </li> <li> <p>No provider version updates: Only module versions are updated (for now)</p> </li> <li> <p>Future enhancement</p> </li> <li> <p>No git source version updates: Git URLs with refs not supported</p> </li> <li> <p>Future enhancement</p> </li> <li> <p>No workspace awareness: All workspaces use same module versions</p> </li> <li>Intentional (workspaces share code)</li> </ol>"},{"location":"integrations/terraform/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/terraform/#module-not-found","title":"Module Not Found","text":"<p>Problem: \"Module not found in registry\"</p> <p>Causes:</p> <ol> <li>Module doesn't exist in Terraform Registry</li> <li>Module name misspelled</li> <li>Private module not accessible</li> </ol> <p>Solutions:</p> <pre><code># Search registry\nterraform search modules vpc aws\n\n# Verify module exists\ncurl https://registry.terraform.io/v1/modules/terraform-aws-modules/vpc/aws\n\n# Check authentication for private modules\nterraform login\n</code></pre>"},{"location":"integrations/terraform/#version-constraint-errors","title":"Version Constraint Errors","text":"<p>Problem: After updating, <code>terraform init</code> fails</p> <p>Causes:</p> <ol> <li>New version has breaking changes</li> <li>Version constraint too restrictive</li> </ol> <p>Solutions:</p> <pre><code># Check module changelog\nterraform show -json | jq '.module_calls'\n\n# Test with specific version\nterraform init -upgrade\n\n# Review breaking changes in module docs\n</code></pre>"},{"location":"integrations/terraform/#lock-file-conflicts","title":"Lock File Conflicts","text":"<p>Problem: <code>.terraform.lock.hcl</code> has conflicts after update</p> <p>Solution:</p> <pre><code># Delete lock file and regenerate\nrm .terraform.lock.hcl\nterraform init -upgrade\n\n# Or update specific providers\nterraform providers lock \\\n  -platform=linux_amd64 \\\n  -platform=darwin_amd64 \\\n  -platform=darwin_arm64\n</code></pre>"},{"location":"integrations/terraform/#authentication-errors","title":"Authentication Errors","text":"<p>Problem: \"403 Forbidden\" for private modules</p> <p>Causes:</p> <ol> <li>Not logged in to Terraform Cloud/Enterprise</li> <li>Token expired</li> <li>Insufficient permissions</li> </ol> <p>Solutions:</p> <pre><code># Login to Terraform Cloud\nterraform login\n\n# Verify credentials\ncat ~/.terraform.d/credentials.tfrc.json\n\n# Test module access\nterraform init\n</code></pre>"},{"location":"integrations/terraform/#best-practices","title":"Best Practices","text":"<ol> <li>Always regenerate lockfile:</li> </ol> <pre><code>uptool update --only=terraform\nterraform init -upgrade\ngit add *.tf .terraform.lock.hcl\ngit commit -m \"chore(terraform): update module versions\"\n</code></pre> <ol> <li>Test in non-prod first:</li> </ol> <pre><code>cd environments/dev\nuptool update --only=terraform\nterraform init -upgrade\nterraform plan\n</code></pre> <ol> <li>Review module changelogs:</li> </ol> <pre><code># Check breaking changes\n# Visit module's GitHub releases or CHANGELOG\n</code></pre> <ol> <li>Use version constraints wisely:</li> </ol> <pre><code># Good: Allow patch updates\nversion = \"~&gt; 5.0\"\n\n# Risky: Allow any major version\nversion = \"&gt;= 3.0\"\n\n# Safe but manual: Exact version\nversion = \"5.0.0\"\n</code></pre> <ol> <li>Separate PRs for major updates:</li> </ol> <pre><code># Minor/patch updates together\nuptool update --only=terraform  # (with policy: minor)\n\n# Major updates separately\n# Review each module's breaking changes\n</code></pre> <ol> <li>Run terraform plan after updating:</li> </ol> <pre><code>terraform init -upgrade\nterraform plan\n# Review changes before applying\n</code></pre>"},{"location":"integrations/terraform/#terraform-version-compatibility","title":"Terraform Version Compatibility","text":"<p>uptool works with Terraform &gt;= 0.13 (HCL2 format).</p> <p>Terraform 0.12 and older:</p> <ul> <li>Not officially supported</li> <li>May work but not tested</li> </ul> <p>Terraform &gt;= 0.13:</p> <ul> <li>\u2705 Fully supported</li> <li>Uses HCL2 format</li> <li>Module registry syntax</li> </ul> <p>Terraform &gt;= 1.0:</p> <ul> <li>\u2705 Fully supported</li> <li>Lockfile format supported</li> </ul>"},{"location":"integrations/terraform/#see-also","title":"See Also","text":"<ul> <li>Terraform Modules</li> <li>Module Sources</li> <li>Version Constraints</li> <li>Terraform Registry</li> <li>Manifest Files Reference</li> </ul>"},{"location":"integrations/tflint/","title":"tflint Integration","text":"<p>The tflint integration updates tflint plugin versions in <code>.tflint.hcl</code> configuration files.</p>"},{"location":"integrations/tflint/#overview","title":"Overview","text":"<p>Integration ID: <code>tflint</code></p> <p>Manifest Files: <code>.tflint.hcl</code></p> <p>Update Strategy: HCL parsing and rewriting via <code>hashicorp/hcl</code></p> <p>Registry: GitHub Releases (for each plugin)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/tflint/#what-gets-updated","title":"What Gets Updated","text":"<p>The tflint integration updates plugin versions:</p> <ul> <li><code>plugin</code> block <code>version</code> attributes - Plugin versions from GitHub releases</li> </ul>"},{"location":"integrations/tflint/#example","title":"Example","text":"<p>Before (<code>.tflint.hcl</code>):</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.20.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n\nplugin \"google\" {\n  enabled = false\n  version = \"0.18.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-google\"\n}\n</code></pre> <p>After (uptool update):</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.44.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.28.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n\nplugin \"google\" {\n  enabled = false\n  version = \"0.32.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-google\"\n}\n</code></pre>"},{"location":"integrations/tflint/#plugin-sources","title":"Plugin Sources","text":""},{"location":"integrations/tflint/#github-based-plugins","title":"GitHub-Based Plugins","text":"<p>Standard format:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n</code></pre> <p>uptool queries GitHub Releases API for the plugin repository to find latest versions.</p>"},{"location":"integrations/tflint/#official-tflint-rulesets","title":"Official tflint Rulesets","text":"<p>Common plugins:</p> <ul> <li><code>github.com/terraform-linters/tflint-ruleset-aws</code> - AWS</li> <li><code>github.com/terraform-linters/tflint-ruleset-azurerm</code> - Azure</li> <li><code>github.com/terraform-linters/tflint-ruleset-google</code> - Google Cloud</li> <li>Custom plugins following same pattern</li> </ul>"},{"location":"integrations/tflint/#cli-usage","title":"CLI Usage","text":""},{"location":"integrations/tflint/#scan-for-tflint-configs","title":"Scan for tflint Configs","text":"<pre><code>uptool scan --only=tflint\n</code></pre> <p>Output:</p> <pre><code>Type                 Path                Dependencies\n----------------------------------------------------------------\ntflint               .tflint.hcl         3\ntflint               terraform/.tflint.hcl  2\n\nTotal: 2 manifests\n</code></pre>"},{"location":"integrations/tflint/#plan-tflint-updates","title":"Plan tflint Updates","text":"<pre><code>uptool plan --only=tflint\n</code></pre> <p>Output:</p> <pre><code>.tflint.hcl (tflint):\nPlugin           Current         Target          Impact\n--------------------------------------------------------\naws              0.21.0          0.44.0          minor\nazurerm          0.20.0          0.28.0          minor\ngoogle           0.18.0          0.32.0          minor\n\nTotal: 3 updates across 1 manifest\n</code></pre>"},{"location":"integrations/tflint/#apply-tflint-updates","title":"Apply tflint Updates","text":"<pre><code># Dry run first\nuptool update --only=tflint --dry-run --diff\n\n# Apply updates\nuptool update --only=tflint\n\n# Then update tflint plugins\ntflint --init\n</code></pre>"},{"location":"integrations/tflint/#configuration","title":"Configuration","text":""},{"location":"integrations/tflint/#update-policy","title":"Update Policy","text":"<pre><code># uptool.yaml\nversion: 1\n\nintegrations:\n  - id: tflint\n    enabled: true\n    policy:\n      update: minor              # none, patch, minor, major\n      allow_prerelease: false\n</code></pre> <p>Update Levels:</p> <ul> <li><code>none</code> - No updates</li> <li><code>patch</code> - Only patch updates (0.21.0 \u2192 0.21.1)</li> <li><code>minor</code> - Patch + minor updates (0.21.0 \u2192 0.22.0)</li> <li><code>major</code> - All updates including major (0.21.0 \u2192 1.0.0)</li> </ul>"},{"location":"integrations/tflint/#exclude-specific-plugins","title":"Exclude Specific Plugins","text":"<p>Pin to exact version:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"  # Exact version, won't update\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n</code></pre>"},{"location":"integrations/tflint/#tflint-plugin-installation","title":"tflint Plugin Installation","text":"<p>uptool does NOT install plugins.</p> <p>After updating <code>.tflint.hcl</code>, install updated plugins:</p> <pre><code># Install/update all plugins\ntflint --init\n\n# Or with specific config\ntflint --init --config=.tflint.hcl\n</code></pre>"},{"location":"integrations/tflint/#multiple-config-files","title":"Multiple Config Files","text":"<p>tflint supports multiple configuration files:</p> <pre><code>project/\n\u251c\u2500\u2500 .tflint.hcl              # Root config, updated\n\u2514\u2500\u2500 modules/\n    \u251c\u2500\u2500 network/\n    \u2502   \u2514\u2500\u2500 .tflint.hcl      # Module config, updated\n    \u2514\u2500\u2500 database/\n        \u2514\u2500\u2500 .tflint.hcl      # Module config, updated\n</code></pre> <p>Each <code>.tflint.hcl</code> is scanned and updated independently.</p>"},{"location":"integrations/tflint/#plugin-versioning","title":"Plugin Versioning","text":"<p>tflint plugins follow semantic versioning (mostly):</p> <ul> <li>Plugins in 0.x.x may have breaking changes in minor versions</li> <li>Plugins &gt;= 1.0.0 follow strict semver</li> </ul> <p>Recommendation: Use <code>update: patch</code> policy for 0.x.x plugins.</p>"},{"location":"integrations/tflint/#github-rate-limiting","title":"GitHub Rate Limiting","text":"<p>uptool queries GitHub Releases API for each plugin.</p>"},{"location":"integrations/tflint/#unauthenticated","title":"Unauthenticated","text":"<ul> <li>Rate limit: 60 requests/hour</li> <li>May be insufficient for many plugins</li> </ul>"},{"location":"integrations/tflint/#authenticated","title":"Authenticated","text":"<p>Set <code>GITHUB_TOKEN</code> environment variable:</p> <pre><code>export GITHUB_TOKEN=\"your_github_token\"\nuptool update --only=tflint\n</code></pre> <p>Rate limit: 5000 requests/hour</p>"},{"location":"integrations/tflint/#limitations","title":"Limitations","text":"<ol> <li>No plugin installation: uptool only updates <code>.tflint.hcl</code></li> <li> <p>Solution: Run <code>tflint --init</code> after</p> </li> <li> <p>GitHub-only plugins: Only plugins on GitHub are supported</p> </li> <li> <p>Other registries not yet supported</p> </li> <li> <p>No config validation: uptool doesn't validate tflint configuration</p> </li> <li> <p>Solution: Run <code>tflint --init</code> to validate</p> </li> <li> <p>Rate limiting: GitHub API has rate limits</p> </li> <li>Solution: Set <code>GITHUB_TOKEN</code> for higher limits</li> </ol>"},{"location":"integrations/tflint/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/tflint/#plugin-not-found","title":"Plugin Not Found","text":"<p>Problem: \"Plugin not found on GitHub\"</p> <p>Causes:</p> <ol> <li>Plugin repository doesn't exist</li> <li>Source URL incorrect</li> <li>Plugin renamed or moved</li> </ol> <p>Solutions:</p> <pre><code># Verify plugin exists\ncurl -I https://api.github.com/repos/terraform-linters/tflint-ruleset-aws/releases\n\n# Check plugin source in .tflint.hcl\ngrep source .tflint.hcl\n\n# Fix source if incorrect\n</code></pre>"},{"location":"integrations/tflint/#github-rate-limit","title":"GitHub Rate Limit","text":"<p>Problem: \"API rate limit exceeded\"</p> <p>Causes:</p> <ol> <li>Too many plugin checks without authentication</li> <li>Many plugins in config</li> </ol> <p>Solutions:</p> <pre><code># Set GitHub token\nexport GITHUB_TOKEN=\"ghp_xxxxxxxxxxxx\"\n\n# Verify rate limit\ncurl -H \"Authorization: token $GITHUB_TOKEN\" \\\n  https://api.github.com/rate_limit\n\n# Run update\nuptool update --only=tflint\n</code></pre>"},{"location":"integrations/tflint/#version-not-available","title":"Version Not Available","text":"<p>Problem: uptool suggests version that doesn't exist</p> <p>Causes:</p> <ol> <li>Plugin releases use different versioning</li> <li>Pre-release versions included</li> </ol> <p>Solutions:</p> <pre><code># Check available releases\ngh release list --repo terraform-linters/tflint-ruleset-aws\n\n# Set policy to exclude pre-releases\n# in uptool.yaml:\npolicy:\n  allow_prerelease: false\n</code></pre>"},{"location":"integrations/tflint/#plugin-installation-fails","title":"Plugin Installation Fails","text":"<p>Problem: <code>tflint --init</code> fails after update</p> <p>Causes:</p> <ol> <li>New version incompatible with tflint version</li> <li>Plugin architecture changed</li> </ol> <p>Solutions:</p> <pre><code># Check tflint version\ntflint --version\n\n# Upgrade tflint if needed\nbrew upgrade tflint  # macOS\n# or download from GitHub releases\n\n# Check plugin compatibility\n# Visit plugin's GitHub page for requirements\n</code></pre>"},{"location":"integrations/tflint/#best-practices","title":"Best Practices","text":"<ol> <li>Always reinstall plugins:</li> </ol> <pre><code>uptool update --only=tflint\ntflint --init\ngit add .tflint.hcl .tflint.d/\ngit commit -m \"chore(tflint): update plugin versions\"\n</code></pre> <ol> <li>Test after updating:</li> </ol> <pre><code>tflint --init\ntflint\n# Verify linting still works\n</code></pre> <ol> <li>Review plugin changelogs:</li> </ol> <pre><code># Check for new rules or breaking changes\n# Visit plugin's GitHub releases page\n</code></pre> <ol> <li>Use conservative update policy:</li> </ol> <pre><code># For 0.x.x plugins, use patch only\npolicy:\n  update: patch\n</code></pre> <ol> <li>Set GitHub token:</li> </ol> <pre><code># In CI/CD\nenv:\n  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n# Locally\nexport GITHUB_TOKEN=\"your_token\"\n</code></pre> <ol> <li>Pin critical plugins:</li> </ol> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"  # Exact version\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n</code></pre>"},{"location":"integrations/tflint/#tflint-version-compatibility","title":"tflint Version Compatibility","text":"<p>uptool works with tflint &gt;= 0.40.0 (plugin system v0.1.0).</p> <p>tflint &lt; 0.40.0:</p> <ul> <li>May work but not tested</li> <li>Plugin system may differ</li> </ul> <p>tflint &gt;= 0.40.0:</p> <ul> <li>\u2705 Fully supported</li> <li>Plugin configuration in HCL</li> </ul>"},{"location":"integrations/tflint/#see-also","title":"See Also","text":"<ul> <li>tflint Documentation</li> <li>tflint Plugins</li> <li>Available Rulesets</li> <li>Manifest Files Reference</li> </ul>"}]}