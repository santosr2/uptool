{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to uptool","text":"<p>Universal, Manifest-First Dependency Updater</p> <p>uptool combines the ecosystem breadth of Topgrade, the precision of Dependabot, and the flexibility of Renovate \u2014 but with a manifest-first philosophy that works across ANY project toolchain defined in configuration files.</p>"},{"location":"#why-uptool","title":"Why uptool?","text":"<p>Modern projects use dozens of tools across multiple ecosystems. uptool helps you manage:</p> <ul> <li>Language dependencies: npm packages</li> <li>Infrastructure tools: Terraform modules, Helm charts</li> <li>CI/CD: GitHub Actions workflows, pre-commit hooks</li> <li>Containers: Docker images in Dockerfiles and docker-compose</li> <li>Development tools: tflint plugins, asdf (<code>.tool-versions</code>), mise (<code>mise.toml</code>)</li> </ul> <p>Each ecosystem has its own update mechanism. Keeping them all current is tedious and error-prone.</p> <p>uptool provides a unified interface to scan, plan, and update dependencies across all your manifest files.</p>"},{"location":"#manifest-first-philosophy","title":"Manifest-First Philosophy","text":"<p>Unlike traditional dependency updaters that focus on lockfiles, uptool updates manifest files directly (package.json, Chart.yaml, *.tf files, etc.), preserving your intent while keeping dependencies current.</p>"},{"location":"#the-approach","title":"The Approach","text":"<ol> <li>Update manifests first: <code>package.json</code>, <code>Chart.yaml</code>, <code>*.tf</code> files</li> <li>Use native commands when they update manifests: <code>pre-commit autoupdate</code> updates <code>.pre-commit-config.yaml</code> \u2705</li> <li>Don't use commands that only update lockfiles: <code>npm update</code> only touches <code>package-lock.json</code> \u274c</li> <li>Then optionally run native lockfile updates: <code>npm install</code>, <code>terraform init</code>, etc.</li> </ol> <p>This ensures your declared dependencies stay current, not just resolved versions.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p> Multi-Ecosystem Support</p> <p>npm, Helm, Terraform, tflint, pre-commit, GitHub Actions, Docker, asdf, mise \u2014 all in one tool</p> </li> <li> <p> Manifest-First Updates</p> <p>Updates configuration files directly, preserving formatting and comments</p> </li> <li> <p> Intelligent Version Resolution</p> <p>Queries upstream registries (npm, Terraform Registry, Helm repos, GitHub Releases)</p> </li> <li> <p> Safe by Default</p> <p>Dry-run mode, diff generation, validation before applying changes</p> </li> <li> <p> Concurrent Execution</p> <p>Parallel scanning and planning with worker pools for fast performance</p> </li> <li> <p> GitHub Action Integration</p> <p>Use as a CLI tool locally or as a GitHub Action in CI/CD pipelines</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Scan for outdated dependencies\nuptool scan\n\n# Preview available updates\nuptool plan\n\n# Apply updates with diff preview\nuptool update --diff\n\n# Filter by integration\nuptool update --only npm,terraform\n</code></pre>"},{"location":"#supported-integrations","title":"Supported Integrations","text":"Integration Status Manifest Files Registry npm \u2705 Stable <code>package.json</code> npm Registry API Helm \u2705 Stable <code>Chart.yaml</code> Helm chart repositories Terraform \u2705 Stable <code>*.tf</code> Terraform Registry API tflint \u2705 Stable <code>.tflint.hcl</code> GitHub Releases pre-commit \u2705 Stable <code>.pre-commit-config.yaml</code> GitHub Releases GitHub Actions \u2705 Stable <code>.github/workflows/*.yml</code> GitHub Releases Docker \u2705 Stable <code>Dockerfile</code>, <code>docker-compose.yml</code> Docker Hub API asdf \u26a0\ufe0f Experimental <code>.tool-versions</code> GitHub Releases (per tool) mise \u26a0\ufe0f Experimental <code>mise.toml</code>, <code>.mise.toml</code> GitHub Releases (per tool)"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to get started? Choose your path:</p> <ul> <li> <p> Installation</p> <p>Install uptool via Go, pre-built binaries, or package managers</p> </li> <li> <p> Quick Start</p> <p>Get up and running in 5 minutes with a sample project</p> </li> <li> <p> User Guide</p> <p>Deep dive into configuration, environments, and advanced usage</p> </li> <li> <p> GitHub Action</p> <p>Automate dependency updates in your CI/CD pipelines</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: santosr2/uptool</li> <li>Issues: Report a bug</li> <li>Discussions: Ask questions</li> <li>Security: See our Security Policy</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Info</p> <p>uptool is under active development. The current focus is on:</p> <ul> <li>\u2705 Core integrations stable (npm, Helm, Terraform, pre-commit, tflint, GitHub Actions, Docker)</li> <li>\ud83d\udea7 Completing asdf/mise integrations (detection works, updates not yet implemented)</li> <li>\ud83d\udea7 Adding Python ecosystem support</li> <li>\ud83d\udcdd Improving documentation and examples</li> </ul>"},{"location":"#license","title":"License","text":"<p>uptool is released under the MIT License.</p> <p>Made with \u2764\ufe0f by the uptool contributors</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>View Full Changelog</p> <p>For the complete changelog with all releases and updates, please see:</p> <p>CHANGELOG.md on GitHub</p>"},{"location":"CHANGELOG/#about-the-changelog","title":"About the Changelog","text":"<p>The uptool changelog follows the Keep a Changelog format and adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#changelog-categories","title":"Changelog Categories","text":"<ul> <li>Added: New features</li> <li>Changed: Changes in existing functionality</li> <li>Deprecated: Soon-to-be removed features</li> <li>Removed: Removed features</li> <li>Fixed: Bug fixes</li> <li>Security: Security vulnerability fixes</li> </ul>"},{"location":"CHANGELOG/#why-visit-github","title":"Why Visit GitHub?","text":"<p>The CHANGELOG.md on GitHub is automatically generated from conventional commits and is always up-to-date with the latest releases.</p> <p>\u2192 Read the full CHANGELOG.md on GitHub</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>View Full Code of Conduct</p> <p>For the complete Code of Conduct, please see:</p> <p>CODE_OF_CONDUCT.md on GitHub</p>"},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":""},{"location":"CODE_OF_CONDUCT/#examples-of-positive-behavior","title":"Examples of Positive Behavior","text":"<ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes</li> <li>Focusing on what is best for the overall community</li> </ul>"},{"location":"CODE_OF_CONDUCT/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>The use of sexualized language or imagery, and sexual attention or advances</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>\u2192 Read the full CODE_OF_CONDUCT.md on GitHub</p>"},{"location":"CONTRIBUTING/","title":"Contributing to uptool","text":"<p>View Full Contributing Guide</p> <p>This page provides a brief overview. For the complete contributing guide, please see:</p> <p>CONTRIBUTING.md on GitHub</p>"},{"location":"CONTRIBUTING/#quick-links","title":"Quick Links","text":"<ul> <li>Development Setup: See the full guide</li> <li>Code Standards: See the full guide</li> <li>Pull Request Process: See the full guide</li> <li>Testing Requirements: See the full guide</li> </ul>"},{"location":"CONTRIBUTING/#why-visit-github","title":"Why Visit GitHub?","text":"<p>The CONTRIBUTING.md file on GitHub is the source of truth and may contain updates more recent than this documentation build. It also includes:</p> <ul> <li>Detailed development environment setup instructions</li> <li>Comprehensive coding standards and style guides</li> <li>Testing and CI/CD requirements</li> <li>Commit message conventions</li> <li>Release process details</li> </ul> <p>\u2192 Read the full CONTRIBUTING.md on GitHub</p>"},{"location":"GOVERNANCE/","title":"Project Governance","text":"<p>View Full Governance Document</p> <p>For the complete governance policy and decision-making process, please see:</p> <p>GOVERNANCE.md on GitHub</p>"},{"location":"GOVERNANCE/#overview","title":"Overview","text":"<p>uptool follows a trunk-based development workflow with transparent decision-making and community-first principles.</p>"},{"location":"GOVERNANCE/#key-principles","title":"Key Principles","text":"<ul> <li>Trunk-Based Development: All changes merge directly to <code>main</code> after review</li> <li>No Git Flow: Simple, fast-moving development process</li> <li>Community First: Open discussion and transparent decision-making</li> <li>Quality Standards: Comprehensive testing and code review requirements</li> </ul>"},{"location":"GOVERNANCE/#roles","title":"Roles","text":"<ul> <li>Maintainers: Core team members with write access</li> <li>Contributors: Community members who submit pull requests</li> <li>Users: Anyone using uptool in their projects</li> </ul>"},{"location":"GOVERNANCE/#decision-making","title":"Decision Making","text":"<ul> <li>Minor Changes: Approved by any maintainer</li> <li>Major Changes: Require discussion and consensus</li> <li>Breaking Changes: Require RFC and community feedback</li> </ul>"},{"location":"GOVERNANCE/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork and create a feature branch</li> <li>Make changes with tests</li> <li>Submit PR with clear description</li> <li>Address review feedback</li> <li>Maintainer merges after approval</li> </ol> <p>\u2192 Read the full GOVERNANCE.md on GitHub</p>"},{"location":"INTEGRATION_TEMPLATE/","title":"[Integration Name] Integration","text":"<p>Brief one-sentence description of what this integration does.</p>"},{"location":"INTEGRATION_TEMPLATE/#overview","title":"Overview","text":"<p>Integration ID: <code>integration-id</code></p> <p>Manifest Files: <code>manifest-file.ext</code></p> <p>Update Strategy: How it updates (e.g., YAML rewriting, native command, HCL parsing)</p> <p>Registry: Where it queries versions (e.g., npm Registry API, GitHub Releases)</p> <p>Status: \u2705 Stable | \ud83e\uddea Experimental</p>"},{"location":"INTEGRATION_TEMPLATE/#what-gets-updated","title":"What Gets Updated","text":"<p>Clear bullet list of what parts of the manifest are updated:</p> <ul> <li><code>section1</code> - Description</li> <li><code>section2</code> - Description</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#example","title":"Example","text":"<p>Before:</p> <pre><code># Example manifest before update\ndependency: 1.0.0\n</code></pre> <p>After:</p> <pre><code># Example manifest after update\ndependency: 1.5.0\n</code></pre>"},{"location":"INTEGRATION_TEMPLATE/#integration-specific-behavior","title":"Integration-Specific Behavior","text":"<p>Any unique behavior for this integration:</p> <ul> <li>Version constraints: How constraints are handled</li> <li>Format preservation: What formatting is preserved</li> <li>Special features: Any unique features</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#configuration","title":"Configuration","text":"<p>Example <code>uptool.yaml</code> configuration:</p> <pre><code>version: 1\n\nintegrations:\n  - id: integration-id\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"INTEGRATION_TEMPLATE/#limitations","title":"Limitations","text":"<p>(Optional section - only include if there are notable limitations)</p> <p>List any known limitations:</p> <ol> <li>Limitation name: Description and workaround</li> </ol>"},{"location":"INTEGRATION_TEMPLATE/#see-also","title":"See Also","text":"<ul> <li>CLI Reference</li> <li>Configuration Guide</li> <li>Official Documentation</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#template-guidelines","title":"Template Guidelines","text":""},{"location":"INTEGRATION_TEMPLATE/#length-target","title":"Length Target","text":"<ul> <li>Minimum: 60 lines</li> <li>Target: 80-120 lines</li> <li>Maximum: 150 lines</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#required-sections","title":"Required Sections","text":"<ol> <li>Overview (ID, files, strategy, registry, status)</li> <li>What Gets Updated (bullet list)</li> <li>Example (before/after code blocks)</li> <li>Integration-Specific Behavior</li> </ol>"},{"location":"INTEGRATION_TEMPLATE/#optional-sections","title":"Optional Sections","text":"<ul> <li>Configuration (if non-standard)</li> <li>Limitations (only if notable)</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#sections-to-avoid","title":"Sections to AVOID","text":"<ul> <li>\u274c Generic CLI usage (covered in CLI reference)</li> <li>\u274c Obvious troubleshooting (e.g., \"check internet connection\")</li> <li>\u274c Redundant registry API details</li> <li>\u274c Monorepo support (mention briefly in \"What Gets Updated\")</li> <li>\u274c Version constraint tables (show in example instead)</li> <li>\u274c Step-by-step workflows (covered in quickstart)</li> </ul>"},{"location":"INTEGRATION_TEMPLATE/#style-guidelines","title":"Style Guidelines","text":"<ul> <li>Be direct and concise</li> <li>Use tables for structured data</li> <li>Use code blocks for examples</li> <li>Link to other docs instead of duplicating content</li> <li>Focus on integration-specific details only</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>uptool is licensed under the MIT License.</p>"},{"location":"LICENSE/#mit-license","title":"MIT License","text":"<p>https://github.com/santosr2/uptool/blob/main/LICENSE</p>"},{"location":"LICENSE/#third-party-licenses","title":"Third-Party Licenses","text":"<p>uptool uses the following open-source libraries:</p>"},{"location":"LICENSE/#go-standard-library","title":"Go Standard Library","text":"<ul> <li>License: BSD-3-Clause</li> <li>Copyright: The Go Authors</li> <li>URL: https://golang.org/LICENSE</li> </ul>"},{"location":"LICENSE/#third-party-go-modules","title":"Third-Party Go Modules","text":"<p>To see a complete list of dependencies and their licenses, run:</p> <pre><code>go mod graph\n</code></pre> <p>Or generate a license report:</p> <pre><code># Install go-licenses\ngo install github.com/google/go-licenses@latest\n\n# Generate report\ngo-licenses report github.com/santosr2/uptool/cmd/uptool\n</code></pre>"},{"location":"LICENSE/#attribution","title":"Attribution","text":"<p>If you use uptool in your project, attribution is appreciated but not required.</p> <p>You may include a notice like:</p> <pre><code>This project uses uptool (https://github.com/santosr2/uptool),\nlicensed under the MIT License.\n</code></pre>"},{"location":"LICENSE/#contributing","title":"Contributing","text":"<p>By contributing to uptool, you agree that your contributions will be licensed under the MIT License.</p> <p>See CONTRIBUTING.md for contribution guidelines.</p>"},{"location":"LICENSE/#questions","title":"Questions","text":"<p>If you have questions about licensing, please open an issue on GitHub.</p>"},{"location":"SECURITY/","title":"Security Policy","text":"<p>Security Vulnerabilities</p> <p>If you discover a security vulnerability, please report it responsibly:</p> <p>Report a Security Vulnerability</p> <p>View Full Security Policy</p> <p>For the complete security policy, supported versions, and reporting guidelines, please see:</p> <p>SECURITY.md on GitHub</p>"},{"location":"SECURITY/#quick-overview","title":"Quick Overview","text":""},{"location":"SECURITY/#supported-versions","title":"Supported Versions","text":"<p>uptool follows a 6-month support window for security patches:</p> <ul> <li>Latest minor version: Full support (features, bug fixes, security patches)</li> <li>Previous minor version: Security patches only (6 months after next minor release)</li> <li>Older versions: No support</li> </ul>"},{"location":"SECURITY/#reporting-process","title":"Reporting Process","text":"<ol> <li>DO NOT create a public GitHub issue</li> <li>Use GitHub Security Advisories (private reporting)</li> <li>Provide detailed description and reproduction steps</li> <li>Allow time for investigation and patch development</li> </ol>"},{"location":"SECURITY/#response-timeline","title":"Response Timeline","text":"<ul> <li>Initial Response: Within 48 hours</li> <li>Severity Assessment: Within 1 week</li> <li>Patch Development: Varies by severity (1-4 weeks)</li> <li>Public Disclosure: After patch is available</li> </ul> <p>\u2192 Read the full SECURITY.md on GitHub</p>"},{"location":"action-usage/","title":"GitHub Action Usage","text":"<p>Use uptool as a GitHub Action to automate dependency updates.</p>"},{"location":"action-usage/#quick-start","title":"Quick Start","text":"<pre><code># .github/workflows/uptool.yml\nname: Dependency Updates\n\non:\n  schedule:\n    - cron: '0 9 * * 1'  # Monday at 9 AM UTC\n  workflow_dispatch:\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: santosr2/uptool@v0  # Latest stable (recommended)\n        with:\n          command: update\n          create-pr: 'true'\n          token: ${{  secrets.GITHUB_TOKEN  }}\n</code></pre> <p>Version pinning:</p> <ul> <li><code>@v0</code> - Latest stable (auto-updates)</li> <li><code>@v0.2</code> - Latest patch</li> <li><code>@main</code> - Exact version (most secure)</li> </ul>"},{"location":"action-usage/#common-patterns","title":"Common Patterns","text":""},{"location":"action-usage/#scan-only-no-updates","title":"Scan Only (No Updates)","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: scan\n    format: json\n</code></pre>"},{"location":"action-usage/#dry-run-before-applying","title":"Dry-Run Before Applying","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: update\n    dry-run: 'true'\n</code></pre>"},{"location":"action-usage/#integration-specific-updates","title":"Integration-Specific Updates","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: update\n    only: npm,helm\n    create-pr: 'true'\n</code></pre>"},{"location":"action-usage/#custom-config-file","title":"Custom Config File","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: update\n    config: configs/production-uptool.yaml\n    create-pr: 'true'\n</code></pre>"},{"location":"action-usage/#monorepo-pattern","title":"Monorepo Pattern","text":"<pre><code>strategy:\n  matrix:\n    package: [api, web, worker]\nsteps:\n  - uses: actions/checkout@v4\n  - name: Update dependencies for ${{ matrix.package }}\n    working-directory: packages/${{ matrix.package }}\n    run: |\n      uptool update --diff\n</code></pre> <p>Note: For monorepo patterns, run uptool directly with the <code>working-directory</code> step option or use a custom config file per package.</p>"},{"location":"action-usage/#create-issue-instead-of-pr","title":"Create Issue Instead of PR","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    command: plan\n    create-issue: 'true'\n    issue-title: 'Weekly Dependency Report'\n    issue-labels: 'dependencies,review-needed'\n    token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>This creates or updates an issue with available updates instead of automatically creating a PR.</p>"},{"location":"action-usage/#inputs","title":"Inputs","text":"Input Required Default Description <code>command</code> No <code>plan</code> Command: <code>scan</code>, <code>plan</code>, or <code>update</code> <code>format</code> No <code>table</code> Output format: <code>table</code> or <code>json</code> <code>only</code> No <code>''</code> Comma-separated integrations to include <code>exclude</code> No <code>''</code> Comma-separated integrations to exclude <code>config</code> No <code>''</code> Path to uptool config file (default: <code>uptool.yaml</code>) <code>dry-run</code> No <code>false</code> Preview without applying (update only) <code>diff</code> No <code>true</code> Show diffs of changes (update only) <code>create-pr</code> No <code>false</code> Create pull request with updates <code>pr-title</code> No <code>chore: update dependencies</code> PR title <code>pr-branch</code> No <code>uptool/dependency-updates</code> PR branch name <code>create-issue</code> No <code>false</code> Create issue when updates available <code>issue-title</code> No <code>Dependency Updates Available</code> Issue title <code>issue-labels</code> No <code>dependencies,automated</code> Comma-separated issue labels <code>token</code> No <code>${{ github.token }}</code> GitHub token <code>skip-install</code> No <code>false</code> Skip uptool installation (use when already in PATH)"},{"location":"action-usage/#outputs","title":"Outputs","text":"Output Description <code>updates-available</code> <code>true</code> if updates found <code>manifests-updated</code> Number of manifests with updates <code>dependencies-updated</code> Number of dependencies updated <p>Usage:</p> <pre><code>- uses: santosr2/uptool@v0\n  id: uptool\n  with:\n    command: plan\n\n- name: Check results\n  if: steps.uptool.outputs.updates-available == 'true'\n  run: echo \"Found ${{ steps.uptool.outputs.dependencies-updated }} updates across ${{ steps.uptool.outputs.manifests-updated }} manifests\"\n</code></pre>"},{"location":"action-usage/#permissions","title":"Permissions","text":"<p>Minimum required:</p> <pre><code>permissions:\n  contents: write          # To commit changes\n  pull-requests: write     # To create PRs\n</code></pre> <p>For auto-merge:</p> <pre><code>permissions:\n  contents: write\n  pull-requests: write\n  checks: read             # To verify checks pass\n</code></pre>"},{"location":"action-usage/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"action-usage/#skip-ci-on-update-prs","title":"Skip CI on Update PRs","text":"<pre><code>- uses: santosr2/uptool@v0\n  with:\n    pr-title: 'chore(deps): update dependencies [skip ci]'\n</code></pre>"},{"location":"action-usage/#notify-on-failures","title":"Notify on Failures","text":"<pre><code>- uses: santosr2/uptool@v0\n  continue-on-error: true\n  id: uptool\n\n- name: Notify on failure\n  if: failure()\n  uses: slackapi/slack-github-action@v1\n  with:\n    payload: |\n      {\n        \"text\": \"uptool failed in ${{ github.repository }}\"\n      }\n</code></pre>"},{"location":"action-usage/#custom-pr-with-additional-steps","title":"Custom PR with Additional Steps","text":"<pre><code>- uses: santosr2/uptool@v0\n  id: uptool\n  with:\n    command: update\n    create-pr: 'true'\n    pr-title: 'chore(deps): weekly dependency updates'\n    token: ${{ secrets.GITHUB_TOKEN }}\n\n- name: Add comment to PR\n  if: steps.uptool.outputs.updates-available == 'true'\n  run: |\n    echo \"Updated ${{ steps.uptool.outputs.dependencies-updated }} dependencies\"\n</code></pre> <p>Note: The action automatically generates a detailed PR body with update information.</p>"},{"location":"action-usage/#matrix-strategy-for-environments","title":"Matrix Strategy for Environments","text":"<pre><code>strategy:\n  matrix:\n    env: [staging, production]\nsteps:\n  - uses: actions/checkout@v4\n  - name: Update ${{ matrix.env }} dependencies\n    working-directory: environments/${{ matrix.env }}\n    run: uptool update --diff\n  - name: Create PR\n    uses: peter-evans/create-pull-request@v7\n    with:\n      branch: uptool/updates-${{ matrix.env }}\n      title: \"chore(${{ matrix.env }}): update dependencies\"\n</code></pre> <p>Note: Use the <code>working-directory</code> step option with direct uptool commands for environment-specific updates.</p>"},{"location":"action-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"action-usage/#pr-not-created","title":"PR Not Created","text":"<p>Check:</p> <ul> <li>Permissions include <code>contents: write</code> and <code>pull-requests: write</code></li> <li>Token has repo access</li> <li>No existing PR with same branch name</li> </ul>"},{"location":"action-usage/#no-updates-found","title":"No Updates Found","text":"<p>Check:</p> <ul> <li>Manifest files exist in repository</li> <li>Integration enabled in <code>uptool.yaml</code></li> <li>Run with <code>dry-run: 'true'</code> to see debug output</li> </ul>"},{"location":"action-usage/#authentication-errors","title":"Authentication Errors","text":"<p>For private packages:</p> <pre><code>- name: Setup npm auth\n  run: echo \"//registry.npmjs.org/:_authToken=${{  secrets.NPM_TOKEN  }}\" &gt; ~/.npmrc\n\n- uses: santosr2/uptool@v0\n  env:\n    GITHUB_TOKEN: ${{  secrets.GITHUB_TOKEN  }}\n</code></pre>"},{"location":"action-usage/#action-times-out","title":"Action Times Out","text":"<p>Increase timeout:</p> <pre><code>- uses: santosr2/uptool@v0\n  timeout-minutes: 15  # Default is 360\n</code></pre>"},{"location":"action-usage/#best-practices","title":"Best Practices","text":"<ol> <li>Use semantic versioning: Pin to <code>@v0</code> for auto-updates</li> <li>Run on schedule: Weekly or daily, avoid high-traffic times</li> <li>Enable manual trigger: Add <code>workflow_dispatch</code> for testing</li> <li>Test in staging first: Use matrix strategy for environments</li> <li>Review PRs: Don't blindly auto-merge major updates</li> <li>Set PR labels: Use <code>pr-labels: 'dependencies,automated'</code></li> <li>Configure branch protection: Require reviews for major updates</li> </ol>"},{"location":"action-usage/#examples","title":"Examples","text":"<p>See .github/workflows/ for working examples:</p> <ul> <li><code>dependency-updates.yml</code> - Weekly automated updates</li> <li><code>dependency-scan.yml</code> - PR scan checks</li> </ul>"},{"location":"action-usage/#see-also","title":"See Also","text":"<ul> <li>Quick Start - CLI usage</li> <li>Configuration - <code>uptool.yaml</code> reference</li> <li>action.yml - Action definition</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>uptool's design, components, and data flow.</p>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Manifest-First: Update config files directly, not just lockfiles</li> <li>Format Preservation: Maintain YAML comments, indentation, structure</li> <li>Extensibility: Plugin-based integration architecture</li> </ol>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<pre><code>CLI (cmd/uptool)\n  \u2193\nEngine (Scan/Plan/Update)\n  \u2193\nIntegrations (npm, helm, terraform, etc.)\n  \u2193\nDatasources (registries) + Rewrite (manifest updates)\n</code></pre>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#cli-layer-cmduptool","title":"CLI Layer (<code>cmd/uptool</code>)","text":"<p>Command handlers using Cobra:</p> <ul> <li><code>scan</code> - Find and parse manifests</li> <li><code>plan</code> - Query registries for updates</li> <li><code>update</code> - Apply changes to manifests</li> <li><code>list</code> - Show available integrations</li> </ul>"},{"location":"architecture/#engine-layer-internalengine","title":"Engine Layer (<code>internal/engine</code>)","text":"<p>Orchestration logic:</p> <ul> <li>Scan: Parallel integration detection, manifest parsing</li> <li>Plan: Registry queries, version resolution, update policy</li> <li>Update: Manifest rewriting, validation, diff generation</li> </ul>"},{"location":"architecture/#integration-layer-internalintegrations","title":"Integration Layer (<code>internal/integrations</code>)","text":"<p>Each integration implements:</p> <pre><code>type Integration interface {\n    Name() string\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n    Plan(ctx context.Context, manifest *Manifest, planCtx *PlanContext) (*UpdatePlan, error)\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p>The <code>planCtx</code> parameter provides policy configuration following the precedence order: <code>CLI flags &gt; uptool.yaml policy &gt; manifest constraints</code>.</p> <p>Types:</p> <ol> <li>Manifest Rewriting (npm, Helm, asdf, mise) - Parse and rewrite files</li> <li>Native Command (pre-commit) - Execute tool's update command</li> <li>Hybrid (Terraform) - Parse HCL, query registry, rewrite</li> </ol>"},{"location":"architecture/#datasource-layer-internaldatasource","title":"Datasource Layer (<code>internal/datasource</code>)","text":"<p>Registry abstraction:</p> <ul> <li>npm Registry API</li> <li>Helm/Artifact Hub</li> <li>Terraform Registry</li> <li>GitHub Releases (for tflint, asdf, mise)</li> </ul>"},{"location":"architecture/#rewrite-layer-internalrewrite","title":"Rewrite Layer (<code>internal/rewrite</code>)","text":"<p>Format-preserving updates:</p> <ul> <li>YAML: Line-by-line rewriting, preserves comments</li> <li>JSON: Structured rewriting with indentation</li> <li>TOML: gopkg.in/toml-based updates</li> <li>HCL: hashicorp/hcl parser</li> </ul>"},{"location":"architecture/#resolve-layer-internalresolve","title":"Resolve Layer (<code>internal/resolve</code>)","text":"<p>Semantic version resolution:</p> <ul> <li>Parse version constraints (<code>^4.0.0</code>, <code>~1.2.3</code>, <code>&gt;=2.0.0</code>)</li> <li>Find compatible versions</li> <li>Handle pre-release tags</li> </ul>"},{"location":"architecture/#policy-layer-internalpolicy","title":"Policy Layer (<code>internal/policy</code>)","text":"<p>Update policies from <code>uptool.yaml</code>:</p> <ul> <li>Maximum update level (none/patch/minor/major)</li> <li>Pre-release inclusion</li> <li>Pin vs range versions</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#scan","title":"Scan","text":"<ol> <li>CLI receives <code>scan</code> command</li> <li>Engine loads integrations</li> <li>Each integration detects manifests (parallel)</li> <li>Parse manifests, extract dependencies</li> <li>Return list of manifests with dependency counts</li> </ol>"},{"location":"architecture/#plan","title":"Plan","text":"<ol> <li>For each manifest, query datasources</li> <li>Resolve latest compatible versions</li> <li>Apply update policy filters</li> <li>Generate UpdatePlan with current \u2192 target versions</li> <li>Return plans (shows what would change)</li> </ol>"},{"location":"architecture/#update","title":"Update","text":"<ol> <li>Execute Plan for each manifest</li> <li>Integration rewrites manifest file</li> <li>Generate diff (before/after)</li> <li>Validate updated manifest</li> <li>Return ApplyResult with changes</li> </ol>"},{"location":"architecture/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/#pattern-1-manifest-rewriting-npm","title":"Pattern 1: Manifest Rewriting (npm)","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error) {\n    data, _ := os.ReadFile(plan.Manifest.Path)\n    var pkg PackageJSON\n    json.Unmarshal(data, &amp;pkg)\n\n    // Update versions\n    for dep, newVer := range plan.Updates {\n        pkg.Dependencies[dep] = newVer\n    }\n\n    // Write back with formatting\n    output, _ := json.MarshalIndent(pkg, \"\", \"  \")\n    os.WriteFile(plan.Manifest.Path, output, 0644)\n    return &amp;ApplyResult{Updated: len(plan.Updates)}, nil\n}\n</code></pre>"},{"location":"architecture/#pattern-2-native-command-pre-commit","title":"Pattern 2: Native Command (pre-commit)","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error) {\n    cmd := exec.CommandContext(ctx, \"pre-commit\", \"autoupdate\")\n    output, err := cmd.CombinedOutput()\n    // Native command updates .pre-commit-config.yaml\n    return &amp;ApplyResult{Updated: countUpdates(output)}, err\n}\n</code></pre>"},{"location":"architecture/#error-handling","title":"Error Handling","text":"<p>Errors categorized by severity:</p> <ul> <li>Fatal: Stop execution (invalid config, missing binary)</li> <li>Retryable: Temporary failures (network timeout, rate limit)</li> <li>Skippable: Non-critical (single integration failure)</li> </ul>"},{"location":"architecture/#performance","title":"Performance","text":"<p>Current:</p> <ul> <li>Parallel integration detection</li> <li>Sequential registry queries (network bound)</li> <li>Single-threaded manifest rewriting</li> </ul> <p>Future:</p> <ul> <li>Registry response caching</li> <li>Parallel registry queries with semaphore</li> <li>Batch updates for monorepos</li> </ul>"},{"location":"architecture/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests: Per-integration testing with testdata fixtures</li> <li>Integration tests: End-to-end with real registries</li> <li>Golden file tests: Manifest rewriting verification</li> <li>Target coverage: &gt;80% overall, &gt;80% for core engine</li> </ul>"},{"location":"architecture/#file-structure","title":"File Structure","text":"<pre><code>uptool/\n\u251c\u2500\u2500 cmd/uptool/              # CLI entry point\n\u2502   \u251c\u2500\u2500 main.go\n\u2502   \u2514\u2500\u2500 cmd/                 # Command handlers\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 engine/              # Core orchestration\n\u2502   \u251c\u2500\u2500 integrations/        # npm, helm, terraform, etc.\n\u2502   \u251c\u2500\u2500 datasource/          # Registry clients\n\u2502   \u251c\u2500\u2500 rewrite/             # Format-preserving updates\n\u2502   \u251c\u2500\u2500 resolve/             # Version resolution\n\u2502   \u2514\u2500\u2500 policy/              # Update policy engine\n\u251c\u2500\u2500 testdata/                # Test fixtures\n\u2514\u2500\u2500 examples/                # Sample configs\n</code></pre>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<ol> <li>New Integration: Implement <code>Integration</code> interface in <code>internal/integrations/</code></li> <li>New Datasource: Add client in <code>internal/datasource/</code></li> <li>New Format: Add rewriter in <code>internal/rewrite/</code></li> <li>Plugin: External <code>.so</code> implementing integration interface</li> </ol>"},{"location":"architecture/#see-also","title":"See Also","text":"<ul> <li>Plugin Development - Create custom integrations</li> <li>CONTRIBUTING.md - Development guidelines</li> <li>Integration Examples - Source code examples</li> </ul>"},{"location":"configuration/","title":"Configuration Reference","text":"<p>uptool can be configured using a <code>uptool.yaml</code> file in your repository root. Configuration is optional \u2014 if no file exists, uptool runs all integrations with sensible defaults.</p> <p>You can specify a custom config file path using the <code>--config</code> flag:</p> <pre><code>uptool scan --config /path/to/custom-config.yaml\nuptool plan --config ./configs/production.yaml\nuptool update --config ../shared-uptool.yaml\n</code></pre>"},{"location":"configuration/#json-schema","title":"JSON Schema","text":"<p>uptool provides a JSON Schema for editor validation and autocompletion. Add this comment to the top of your <code>uptool.yaml</code>:</p> <pre><code># yaml-language-server: $schema=https://raw.githubusercontent.com/santosr2/uptool/main/schemas/uptool.schema.json\nversion: 1\n# ...\n</code></pre>"},{"location":"configuration/#vs-code-setup","title":"VS Code Setup","text":"<p>For automatic schema validation in VS Code with the YAML extension:</p> <ol> <li>Install the Red Hat YAML extension</li> <li>Add to your <code>.vscode/settings.json</code>:</li> </ol> <pre><code>{\n  \"yaml.schemas\": {\n    \"https://raw.githubusercontent.com/santosr2/uptool/main/schemas/uptool.schema.json\": [\"uptool.yaml\", \"uptool.yml\"]\n  }\n}\n</code></pre> <p>Or for local development, reference the local schema:</p> <pre><code>{\n  \"yaml.schemas\": {\n    \"./schemas/uptool.schema.json\": [\"uptool.yaml\", \"uptool.yml\"]\n  }\n}\n</code></pre>"},{"location":"configuration/#quick-start","title":"Quick Start","text":"<p>Create <code>uptool.yaml</code> in your repository root:</p> <pre><code># yaml-language-server: $schema=https://raw.githubusercontent.com/santosr2/uptool/main/schemas/uptool.schema.json\nversion: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"configuration/#configuration-schema","title":"Configuration Schema","text":""},{"location":"configuration/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>version: 1                    # Configuration format version (required)\n\nintegrations:                 # List of integration configurations\n  - id: &lt;integration_id&gt;      # Integration identifier\n    enabled: true|false       # Enable/disable this integration\n    match:                    # Optional: File matching rules\n      files: [...]            # List of file patterns to include\n      exclude: [...]          # List of file patterns to exclude\n    policy:                   # Update policy for this integration\n      update: none|patch|minor|major\n      allow_prerelease: true|false\n      pin: true|false\n      cadence: daily|weekly|monthly  # Update frequency (optional)\n\norg_policy:                   # Optional: Organization-level policies\n  require_signoff_from: [...]  # List of required approvers\n  signing:                    # Artifact signing verification\n    cosign_verify: true|false\n  auto_merge:                 # Automatic PR merging\n    enabled: true|false\n    guards: [...]             # Required conditions\n</code></pre>"},{"location":"configuration/#configuration-fields","title":"Configuration Fields","text":""},{"location":"configuration/#version","title":"version","text":"<p>Type: <code>integer</code> | Required: Yes | Default: N/A</p> <p>The configuration format version. Currently only <code>1</code> is supported.</p>"},{"location":"configuration/#integrations","title":"integrations","text":"<p>Type: <code>array</code> | Required: No | Default: All integrations enabled</p> <p>List of integration configurations.</p>"},{"location":"configuration/#id","title":"id","text":"<p>Type: <code>string</code> | Required: Yes</p> <p>Allowed values: <code>npm</code>, <code>helm</code>, <code>terraform</code>, <code>tflint</code>, <code>precommit</code>, <code>asdf</code>, <code>mise</code></p> <p>The integration identifier.</p>"},{"location":"configuration/#enabled","title":"enabled","text":"<p>Type: <code>boolean</code> | Required: No | Default: <code>true</code></p> <p>Whether this integration should run. CLI flags <code>--only</code> and <code>--exclude</code> override this setting.</p>"},{"location":"configuration/#match","title":"match","text":"<p>Type: <code>object</code> | Required: No</p> <p>File matching rules for this integration. Supports both include patterns (<code>files</code>) and exclude patterns (<code>exclude</code>).</p> <p>match.files - Array of glob patterns to include:</p> <pre><code>- id: npm\n  match:\n    files:\n      - \"package.json\"           # Root package.json\n      - \"apps/*/package.json\"    # Monorepo packages\n      - \"packages/*/package.json\"\n</code></pre> <p>match.exclude - Array of glob patterns to exclude (applied after <code>files</code>):</p> <pre><code>- id: npm\n  match:\n    files:\n      - \"package.json\"\n      - \"apps/*/package.json\"\n      - \"libs/*/package.json\"\n    exclude:\n      - \"libs/*/package.json\"              # Exclude library packages\n      - \"node_modules/**/package.json\"     # Exclude dependencies\n</code></pre> <p>Matching Logic:</p> <ol> <li>Files are first matched against <code>files</code> patterns (if specified)</li> <li>Then filtered out if they match any <code>exclude</code> pattern</li> <li>If no <code>files</code> patterns specified, all detected files are included (before applying <code>exclude</code>)</li> </ol> <p>Common Use Cases:</p> <ul> <li>Exclude vendor directories: <code>vendor/**</code></li> <li>Exclude build artifacts: <code>dist/**</code>, <code>build/**</code></li> <li>Exclude test fixtures: <code>testdata/**</code>, <code>fixtures/**</code></li> <li>Exclude specific paths: <code>legacy/old-app/**</code></li> </ul> <p>Default patterns by integration:</p> Integration Default Patterns npm <code>package.json</code> helm <code>Chart.yaml</code>, <code>*/Chart.yaml</code>, <code>charts/*/Chart.yaml</code> terraform <code>*.tf</code>, <code>**/*.tf</code> tflint <code>.tflint.hcl</code> precommit <code>.pre-commit-config.yaml</code> asdf <code>.tool-versions</code> mise <code>mise.toml</code>, <code>.mise.toml</code>"},{"location":"configuration/#policy","title":"policy","text":"<p>Type: <code>object</code> | Required: No</p> <p>Update policy for this integration.</p> <p>policy.update - Maximum version bump to allow:</p> Value Allows Example <code>none</code> No updates Scan/plan only <code>patch</code> Patch updates only 1.2.3 \u2192 1.2.4 <code>minor</code> Patch + minor 1.2.3 \u2192 1.3.0 <code>major</code> All updates 1.2.3 \u2192 2.0.0 <p>Default: <code>major</code> (when no config file exists, allows all stable updates)</p> <p>policy.allow_prerelease - Include pre-release versions:</p> <p>Type: <code>boolean</code> | Default: <code>false</code></p> <p>When <code>true</code>, considers versions like <code>1.2.3-alpha20250708</code>, <code>1.2.3-beta2</code>, <code>1.2.3-rc1</code>.</p> <p>policy.pin - Write exact versions or ranges:</p> <p>Type: <code>boolean</code> | Default: Depends on integration</p> Integration pin: true pin: false npm <code>\"4.19.2\"</code> <code>\"^4.19.2\"</code> (preserves constraint) helm <code>12.0.0</code> <code>12.0.0</code> (always pinned) terraform <code>\"5.8.1\"</code> <code>\"5.8.1\"</code> (always pinned) mise <code>\"1.25\"</code> <code>\"1.25\"</code> (always pinned) <p>policy.cadence - Update frequency for scheduled runs:</p> <p>Type: <code>string</code> | Default: None</p> <p>Values: <code>daily</code>, <code>weekly</code>, <code>monthly</code></p> <p>Controls how often to check for updates in automated scenarios (primarily for GitHub Actions integration).</p> <p>policy.enabled - Enable/disable policy enforcement for this integration:</p> <p>Type: <code>boolean</code> | Default: <code>true</code></p> <p>When <code>false</code>, the integration still runs but uses default policy settings instead of configured values:</p> <ul> <li><code>update: major</code> (allow all updates)</li> <li><code>allow_prerelease: false</code> (no pre-releases)</li> <li><code>pin: &lt;default per integration&gt;</code></li> <li>Respects manifest constraints (<code>^</code>, <code>~</code>, <code>&gt;=</code>, etc.)</li> </ul> <p>When <code>true</code>, the configured policy settings are applied.</p> <p>Note: This is different from <code>integrations[*].enabled</code>, which controls whether the integration is registered at all. Use <code>policy.enabled: false</code> to temporarily disable policy restrictions without removing the integration.</p> <p>Use case: Temporarily allow all updates for an integration during major version upgrades without modifying other policy settings.</p>"},{"location":"configuration/#policy-precedence","title":"Policy Precedence","text":"<p>uptool follows a clear precedence order when determining which updates to allow:</p>"},{"location":"configuration/#1-cli-flags-highest-priority","title":"1. CLI Flags (Highest Priority)","text":"<p>Command-line flags always override configuration file settings:</p> <pre><code># Override uptool.yaml and allow all updates\nuptool update --update-level=major\n\n# Allow prereleases regardless of config\nuptool update --allow-prerelease\n</code></pre>"},{"location":"configuration/#2-uptoolyaml-integration-policy","title":"2. uptool.yaml Integration Policy","text":"<p>Per-integration policies in <code>uptool.yaml</code>:</p> <pre><code>integrations:\n  - id: npm\n    policy:\n      update: minor  # Limits npm updates to minor/patch only\n</code></pre>"},{"location":"configuration/#3-manifest-constraints","title":"3. Manifest Constraints","text":"<p>Version constraints in manifest files (package.json, Chart.yaml, etc.):</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\"  // Constraint: only 4.x versions allowed\n  }\n}\n</code></pre> <p>Even if <code>update: major</code> is set, uptool respects the <code>^4.18.0</code> constraint and won't propose <code>express@5.0.0</code>.</p>"},{"location":"configuration/#4-default-behavior-lowest-priority","title":"4. Default Behavior (Lowest Priority)","text":"<p>If no policy or constraints exist, uptool allows all stable updates (equivalent to <code>update: major</code>).</p>"},{"location":"configuration/#precedence-example","title":"Precedence Example","text":"<p>Given this configuration:</p> <pre><code>integrations:\n  - id: npm\n    policy:\n      update: minor  # Only minor/patch updates\n</code></pre> <p>And this package.json:</p> <pre><code>{\n  \"dependencies\": {\n    \"lodash\": \"^4.17.20\"  // Constraint allows 4.x only\n  }\n}\n</code></pre> <p>Result:</p> <ul> <li>\u2705 <code>lodash@4.17.21</code> - Allowed (patch update, within 4.x constraint)</li> <li>\u2705 <code>lodash@4.18.0</code> - Allowed (minor update, within 4.x constraint)</li> <li>\u274c <code>lodash@5.0.0</code> - Blocked (major update exceeds policy + constraint)</li> </ul> <p>Running with <code>--update-level=major</code>:</p> <ul> <li>\u2705 <code>lodash@5.0.0</code> - Now allowed (CLI flag overrides policy, but constraint needs manual update)</li> </ul>"},{"location":"configuration/#policy-best-practices","title":"Policy Best Practices","text":""},{"location":"configuration/#conservative-production","title":"Conservative (Production)","text":"<p>For production systems requiring stability:</p> <pre><code>integrations:\n  # Runtime dependencies: patch updates only\n  - id: mise\n    policy:\n      update: patch\n      pin: true\n\n  # Application dependencies: minor updates\n  - id: npm\n    policy:\n      update: minor\n      pin: true\n      cadence: monthly\n\n  # Infrastructure: patch updates only\n  - id: terraform\n    policy:\n      update: patch\n      cadence: monthly\n\n  - id: helm\n    policy:\n      update: patch\n      cadence: monthly\n</code></pre>"},{"location":"configuration/#moderate-staging","title":"Moderate (Staging)","text":"<p>Balanced approach for staging environments:</p> <pre><code>integrations:\n  - id: npm\n    policy:\n      update: minor  # Allow minor updates\n      pin: false     # Preserve version ranges\n\n  - id: terraform\n    policy:\n      update: minor\n\n  - id: helm\n    policy:\n      update: minor\n</code></pre>"},{"location":"configuration/#aggressive-development","title":"Aggressive (Development)","text":"<p>Keep development tools up-to-date:</p> <pre><code>integrations:\n  - id: precommit\n    policy:\n      update: major  # Allow all updates\n      cadence: weekly\n\n  - id: npm\n    match:\n      files: [\"package.json\"]  # Root only\n    policy:\n      update: major\n      allow_prerelease: false\n      cadence: weekly\n</code></pre>"},{"location":"configuration/#monorepo-example","title":"Monorepo Example","text":"<p>Different policies for different parts of a monorepo:</p> <pre><code>integrations:\n  # Production apps: conservative\n  - id: npm\n    match:\n      files: [\"apps/*/package.json\"]\n    policy:\n      update: patch\n      pin: true\n\n  # Shared libraries: moderate\n  - id: npm\n    match:\n      files: [\"packages/*/package.json\"]\n    policy:\n      update: minor\n      pin: false\n\n  # Development tools: aggressive\n  - id: precommit\n    policy:\n      update: major\n</code></pre> <p>Note: Multiple configurations for the same integration ID use the last matching configuration.</p>"},{"location":"configuration/#org_policy","title":"org_policy","text":"<p>Type: <code>object</code> | Required: No</p> <p>Organization-level policies for governance and automation.</p> <p>org_policy.require_signoff_from - Required approvers:</p> <p>Type: <code>array of strings</code> | Default: None</p> <p>List of email addresses or team identifiers that must approve changes.</p> <pre><code>org_policy:\n  require_signoff_from:\n    - \"platform-team@company.com\"\n    - \"security-team@company.com\"\n</code></pre> <p>org_policy.signing - Artifact signing verification:</p> <p>Type: <code>object</code> | Default: None</p> <pre><code>org_policy:\n  signing:\n    cosign_verify: true  # Verify signatures with Cosign\n</code></pre> <p>org_policy.auto_merge - Automatic PR merging:</p> <p>Type: <code>object</code> | Default: None</p> <pre><code>org_policy:\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"           # All CI checks must pass\n      - \"codeowners-approve\"  # CODEOWNERS must approve\n</code></pre>"},{"location":"configuration/#complete-examples","title":"Complete Examples","text":""},{"location":"configuration/#conservative-production_1","title":"Conservative (Production)","text":"<p>For production systems requiring stability:</p> <pre><code>version: 1\n\nintegrations:\n  # Only patch updates for runtime dependencies\n  - id: mise\n    policy:\n      update: patch\n\n  - id: npm\n    policy:\n      update: patch\n\n  # Minor updates for infrastructure\n  - id: terraform\n    policy:\n      update: minor\n\n  - id: helm\n    policy:\n      update: minor\n</code></pre>"},{"location":"configuration/#comprehensive-all-features","title":"Comprehensive (All Features)","text":"<p>Full configuration with all options:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    match:\n      files:\n        - \"package.json\"\n        - \"apps/*/package.json\"     # Monorepo support\n        - \"packages/*/package.json\"\n    policy:\n      update: minor\n      allow_prerelease: false\n      pin: false  # Use version ranges\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: terraform\n    enabled: true\n    match:\n      files:\n        - \"infrastructure/**/*.tf\"\n        - \"modules/**/*.tf\"\n    policy:\n      update: minor\n      allow_prerelease: false\n\n  - id: precommit\n    enabled: true\n    policy:\n      update: major  # Aggressive for dev tools\n\n  - id: tflint\n    enabled: true\n    policy:\n      update: major\n\n  - id: asdf\n    enabled: true\n    policy:\n      update: patch  # Conservative for runtimes\n\n  - id: mise\n    enabled: true\n    policy:\n      update: patch  # Conservative for runtimes\n</code></pre>"},{"location":"configuration/#configuration-precedence","title":"Configuration Precedence","text":"<p>Settings are applied in this order (later overrides earlier):</p> <ol> <li>Integration defaults (hardcoded in code)</li> <li><code>uptool.yaml</code> configuration (if exists)</li> <li>CLI flags (<code>--only</code>, <code>--exclude</code>)</li> </ol> <p>Example:</p> <pre><code># uptool.yaml\nintegrations:\n  - id: npm\n    enabled: false\n</code></pre> <pre><code># CLI overrides config file\nuptool update --only=npm  # npm WILL update despite enabled: false\n</code></pre>"},{"location":"configuration/#validation","title":"Validation","text":"<p>uptool validates configuration on startup. Invalid values log warnings and use defaults:</p> <pre><code>WARN: Unknown integration 'unknown_integration' in config, skipping\nWARN: Invalid update policy 'invalid_value' for npm, using default 'minor'\n</code></pre>"},{"location":"configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Start conservative: Use <code>patch</code> or <code>minor</code> for production</li> <li>Separate policies: Conservative for runtime, aggressive for dev tools</li> <li>Explicit paths: Avoid broad wildcards in monorepos (<code>apps/*/package.json</code> not <code>**/package.json</code>)</li> <li>Document decisions: Add comments explaining policy choices</li> </ol>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":"<p>Config not loading: Check <code>uptool.yaml</code> exists in root, valid YAML syntax, run with <code>-v</code></p> <p>Integration not running: Verify <code>enabled: true</code>, no CLI overrides (<code>--exclude</code>), files match pattern</p> <p>Policy not applied: Policy applies to <code>uptool update</code>, bypassed with <code>--only</code> flag</p>"},{"location":"configuration/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command documentation</li> <li>Integration Guides - Integration-specific details</li> <li>GitHub Action Usage - CI/CD configuration</li> <li>Examples - Sample configurations</li> </ul>"},{"location":"environments/","title":"GitHub Environments Setup","text":"<p>uptool uses GitHub Environments with approval gates to control releases. This provides an additional layer of security and creates an audit trail for all releases.</p>"},{"location":"environments/#overview","title":"Overview","text":"<p>Three environments are configured in the release workflows:</p> <ol> <li>pre-release - Used for creating pre-release versions (rc/beta/alpha)</li> <li>production - Used for promoting pre-releases to stable versions</li> <li>patch-release - Used for creating patch releases on release branches</li> </ol> <p>All environments require manual approval from designated reviewers before the workflow can proceed with creating/promoting releases.</p>"},{"location":"environments/#environment-configuration","title":"Environment Configuration","text":""},{"location":"environments/#prerequisites","title":"Prerequisites","text":"<ul> <li>Repository administrator access</li> <li>Appropriate repository permissions (Settings \u2192 Environments)</li> </ul>"},{"location":"environments/#creating-environments","title":"Creating Environments","text":""},{"location":"environments/#1-navigate-to-environments","title":"1. Navigate to Environments","text":"<ol> <li>Go to your repository on GitHub</li> <li>Click Settings (top menu)</li> <li>In the left sidebar, click Environments</li> </ol>"},{"location":"environments/#2-create-pre-release-environment","title":"2. Create Pre-Release Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>pre-release</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve pre-releases</li> <li>Recommended: At least 1 reviewer</li> <li> <p>Prevents accidental pre-release creation</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes (no automatic delay)</li> <li> <p>Or add a delay if desired</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add rule: <code>main</code> branch only</li> <li>This ensures only main branch can create releases</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> <li>GitHub token is automatically provided</li> </ul> <p>Save the environment</p>"},{"location":"environments/#3-create-production-environment","title":"3. Create Production Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>production</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve stable releases</li> <li>Recommended: At least 2 reviewers for production</li> <li> <p>Requires multiple approvals for critical releases</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes for immediate review</li> <li> <p>Or set to 10-30 minutes for time to review changes</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add rule: <code>main</code> branch only</li> <li> <p>Ensures only main branch can promote to stable</p> </li> <li> <p>\u26a0\ufe0f Prevent self-review (recommended)</p> </li> <li>Enable this to require approval from someone other than the workflow trigger</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> </ul> <p>Save the environment</p>"},{"location":"environments/#4-create-patch-release-environment","title":"4. Create Patch Release Environment","text":"<ol> <li>Click New environment</li> <li>Name: <code>patch-release</code></li> <li>Click Configure environment</li> </ol> <p>Configure the following protection rules:</p> <ul> <li>\u2705 Required reviewers</li> <li>Add maintainers who should approve patch releases</li> <li>Recommended: At least 1 reviewer (can be same as pre-release)</li> <li> <p>Ensures security/bug fixes are reviewed before release</p> </li> <li> <p>\u2705 Wait timer (optional)</p> </li> <li>Set to 0 minutes for immediate review</li> <li> <p>Patch releases are typically urgent (security fixes)</p> </li> <li> <p>\u2705 Deployment branches and tags</p> </li> <li>Select: Selected branches and tags</li> <li>Add pattern: <code>release-*</code> (for release branches)</li> <li> <p>This ensures only release branches can create patch releases</p> </li> <li> <p>\u26a0\ufe0f Prevent self-review (recommended)</p> </li> <li>Enable this for security patches especially</li> </ul> <p>Environment secrets (if needed):</p> <ul> <li>No additional secrets required for basic setup</li> </ul> <p>Save the environment</p>"},{"location":"environments/#approval-workflow","title":"Approval Workflow","text":""},{"location":"environments/#pre-release-creation","title":"Pre-Release Creation","text":"<p>When someone triggers the Pre-Release workflow:</p> <ol> <li>Workflow calculates version and updates files</li> <li>Tests run automatically</li> <li>Workflow pauses at the <code>build</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are built and pre-release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Pre-release version (e.g., <code>v0.2.0-rc1</code>)</li> <li>Commit SHA being released</li> <li>Link to the release page (once approved)</li> <li>Comment field for approval notes</li> </ul>"},{"location":"environments/#stable-release-promotion","title":"Stable Release Promotion","text":"<p>When someone triggers the Promote to Stable Release workflow:</p> <ol> <li>Workflow validates pre-release tag exists</li> <li>Updates version files to stable</li> <li>Tests run automatically</li> <li>Workflow pauses at the <code>promote</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are promoted and stable release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Pre-release being promoted (e.g., <code>v0.2.0-rc1</code>)</li> <li>Stable version (e.g., <code>v0.2.0</code>)</li> <li>Link to the stable release page (once approved)</li> </ul>"},{"location":"environments/#patch-release-creation","title":"Patch Release Creation","text":"<p>When someone triggers the Patch Release workflow:</p> <ol> <li>Workflow validates release branch exists</li> <li>Updates version files on release branch</li> <li>Builds binaries and generates SBOMs</li> <li>Workflow pauses at the <code>release</code> job</li> <li>GitHub sends notification to required reviewers</li> <li>Reviewer(s) must approve or reject the deployment</li> <li>If approved: artifacts are signed and patch release is created</li> <li>If rejected: workflow is cancelled</li> </ol> <p>Approval screen shows:</p> <ul> <li>Release branch (e.g., <code>release-0.1</code>)</li> <li>Patch version (e.g., <code>v0.1.1</code>)</li> <li>Patch type (security or bugfix)</li> <li>Commits included in patch</li> <li>Link to the patch release page (once approved)</li> </ul>"},{"location":"environments/#approving-a-deployment","title":"Approving a Deployment","text":""},{"location":"environments/#as-a-reviewer","title":"As a Reviewer","text":"<p>When you receive a deployment approval request:</p> <ol> <li>Check your email or GitHub notifications</li> <li>Go to Actions tab in the repository</li> <li>Find the workflow run waiting for approval</li> <li>Review the details:</li> <li>Check the version being released</li> <li>Review the commits included</li> <li>Verify tests passed</li> <li> <p>Check CHANGELOG updates</p> </li> <li> <p>Click Review deployments</p> </li> <li>Select the environment (<code>pre-release</code>, <code>production</code>, or <code>patch-release</code>)</li> <li>Add a comment (optional but recommended):</li> </ol> <pre><code>Approved: Version v0.2.0 includes security fixes\n</code></pre> <ol> <li>Click Approve and deploy or Reject</li> </ol>"},{"location":"environments/#review-checklist","title":"Review Checklist","text":"<p>Before approving a pre-release:</p> <ul> <li> Version number is correct</li> <li> All tests passed</li> <li> No breaking changes without documentation</li> <li> CHANGELOG is updated</li> <li> Commit messages follow conventional commits</li> </ul> <p>Before approving a stable release:</p> <ul> <li> Pre-release was tested successfully</li> <li> No critical issues reported</li> <li> Documentation is accurate</li> <li> Version matches what was tested</li> <li> All artifacts are present</li> </ul> <p>Before approving a patch release:</p> <ul> <li> Patch is on correct release branch (e.g., <code>release-0.1</code>)</li> <li> Version increment is correct (patch only)</li> <li> Security vulnerability is properly fixed (if security patch)</li> <li> Changes are minimal and targeted (no feature additions)</li> <li> All tests passed on release branch</li> <li> No conflicts with existing stable releases</li> </ul>"},{"location":"environments/#viewing-deployment-history","title":"Viewing Deployment History","text":"<p>GitHub tracks all deployments in the environment:</p> <ol> <li>Go to Settings \u2192 Environments</li> <li>Click on <code>pre-release</code>, <code>production</code>, or <code>patch-release</code></li> <li>View Deployment history:</li> <li>Who triggered the workflow</li> <li>Who approved/rejected</li> <li>When it was deployed</li> <li>Links to workflow runs</li> <li>Comments from reviewers</li> </ol> <p>This creates a complete audit trail for compliance.</p>"},{"location":"environments/#bypassing-approval-not-recommended","title":"Bypassing Approval (Not Recommended)","text":"<p>Warning: Only repository administrators can bypass environment protection rules.</p> <p>If you need to bypass approval (emergency only):</p> <ol> <li>Go to Settings \u2192 Environments</li> <li>Select the environment</li> <li>Temporarily remove Required reviewers</li> <li>Run the workflow</li> <li>Immediately re-enable required reviewers</li> </ol> <p>Better approach: Add yourself as an approved reviewer if needed.</p>"},{"location":"environments/#troubleshooting","title":"Troubleshooting","text":"<p>Workflow stuck waiting: Check Actions tab for \"Review deployments\" button, verify you're a required reviewer</p> <p>Cannot approve: Ensure you're listed as reviewer and didn't trigger the workflow yourself (if self-review prevented)</p> <p>Environment not found: Verify environment names in workflow files match Settings \u2192 Environments exactly</p>"},{"location":"environments/#security-best-practices","title":"Security Best Practices","text":""},{"location":"environments/#required-reviewers","title":"Required Reviewers","text":"<p>Pre-release environment:</p> <ul> <li>Minimum: 1 reviewer</li> <li>Recommended: 1-2 reviewers</li> <li>Should include: Project maintainers</li> </ul> <p>Production environment:</p> <ul> <li>Minimum: 2 reviewers</li> <li>Recommended: 2-3 reviewers</li> <li>Should include: Senior maintainers, security lead</li> </ul> <p>Patch release environment:</p> <ul> <li>Minimum: 1 reviewer</li> <li>Recommended: 1-2 reviewers (can be same as pre-release)</li> <li>Should include: Security lead (for security patches), maintainers</li> <li>Note: Security patches should be expedited but still reviewed</li> </ul>"},{"location":"environments/#branch-protection","title":"Branch Protection","text":"<p>Combine environment protection with branch protection:</p> <ol> <li>Go to Settings \u2192 Branches</li> <li>Add rule for <code>main</code> branch:</li> <li>\u2705 Require pull request reviews (at least 1)</li> <li>\u2705 Require status checks to pass</li> <li>\u2705 Require branches to be up to date</li> <li> <p>\u2705 Include administrators</p> </li> <li> <p>Add rule for <code>release-*</code> pattern (for patch release branches):</p> </li> <li>\u2705 Require pull request reviews (at least 1)</li> <li>\u2705 Require status checks to pass</li> <li>\u2705 Include administrators</li> <li>\u2705 Restrict who can push (maintainers only)</li> </ol> <p>This ensures:</p> <ul> <li>Code is reviewed before merging</li> <li>Tests pass before merging</li> <li>Releases require additional approval</li> <li>Patch releases are protected and audited</li> </ul>"},{"location":"environments/#audit-trail","title":"Audit Trail","text":"<p>GitHub automatically logs:</p> <ul> <li>Who triggered the workflow</li> <li>Who approved/rejected</li> <li>When deployment occurred</li> <li>Environment variables used</li> <li>Workflow run details</li> </ul> <p>Export deployment logs regularly for compliance:</p> <ol> <li>Go to Settings \u2192 Environments \u2192 [Environment]</li> <li>View deployment history</li> <li>Document approvals in release notes</li> </ol>"},{"location":"environments/#example-release-flow","title":"Example Release Flow","text":""},{"location":"environments/#standard-release-flow","title":"Standard Release Flow","text":"<ol> <li>Pre-Release: Trigger workflow \u2192 Reviewer approves \u2192 <code>v0.2.0-rc1</code> created</li> <li>Testing: Test artifacts, fix issues, create new RC if needed</li> <li>Promotion: Trigger promote workflow \u2192 Multiple reviewers approve \u2192 <code>v0.2.0</code> created</li> <li>Audit: All approvals logged in environment history</li> </ol>"},{"location":"environments/#patch-release-flow","title":"Patch Release Flow","text":"<ol> <li>Security Fix: Vulnerability discovered in <code>v0.1.0</code></li> <li>Create Branch: Create <code>release-0.1</code> from <code>v0.1.0</code> tag (if not exists)</li> <li>Apply Fix: Cherry-pick security fix to release branch</li> <li>Patch Release: Trigger patch workflow \u2192 Reviewer approves \u2192 <code>v0.1.1</code> created</li> <li>Audit: Patch release approval logged in patch-release environment history</li> </ol>"},{"location":"environments/#see-also","title":"See Also","text":"<ul> <li>GitHub Environments Documentation</li> <li>Deployment Protection Rules</li> <li>Version Management Guide</li> <li>Contributing Guide</li> </ul>"},{"location":"guards/","title":"Guard Plugins","text":"<p>Guard plugins are extensible checks that determine whether a Pull Request meets your organization's requirements for auto-merge. uptool provides built-in guards and supports custom guard plugins for organization-specific workflows.</p>"},{"location":"guards/#overview","title":"Overview","text":"<p>Guards enable you to:</p> <ul> <li>Enforce quality gates before auto-merging dependency updates</li> <li>Integrate with external systems (Slack, JIRA, custom APIs)</li> <li>Implement custom approval workflows beyond GitHub's built-in features</li> <li>Create reusable policy checks across multiple repositories</li> </ul>"},{"location":"guards/#architecture","title":"Architecture","text":""},{"location":"guards/#guard-interface","title":"Guard Interface","text":"<p>All guards implement a simple interface:</p> <pre><code>// Guard represents a pluggable auto-merge guard check.\ntype Guard interface {\n    // Name returns the unique identifier for this guard (e.g., \"ci-green\")\n    Name() string\n\n    // Description returns a human-readable description\n    Description() string\n\n    // Check executes the guard logic and returns true if satisfied\n    Check(ctx context.Context, env *Environment) (bool, error)\n}\n</code></pre>"},{"location":"guards/#environment-context","title":"Environment Context","text":"<p>Guards receive GitHub context via the <code>Environment</code> struct:</p> <pre><code>type Environment struct {\n    GitHubRepo     string // Format: \"owner/repo\"\n    GitHubToken    string // GitHub API token\n    GitHubPRNumber string // PR number (validated numeric)\n}\n</code></pre>"},{"location":"guards/#registry","title":"Registry","text":"<p>Guards self-register via a global registry:</p> <pre><code>import \"github.com/santosr2/uptool/internal/policy/guards\"\n\nfunc init() {\n    guards.Register(&amp;MyCustomGuard{})\n}\n</code></pre>"},{"location":"guards/#built-in-guards","title":"Built-in Guards","text":"<p>uptool includes three production-ready guards:</p>"},{"location":"guards/#ci-green","title":"ci-green","text":"<p>File: <code>internal/policy/guards/builtin/ci_green.go</code></p> <p>Purpose: Verify all CI checks pass (SUCCESS or SKIPPED).</p> <p>Implementation:</p> <pre><code>type CIGreenGuard struct{}\n\nfunc (g *CIGreenGuard) Name() string {\n    return \"ci-green\"\n}\n\nfunc (g *CIGreenGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // Uses `gh pr checks` to verify CI status\n    cmd := exec.CommandContext(ctx, \"gh\", \"pr\", \"checks\", env.GitHubPRNumber, \"--json\", \"state\")\n    // Parses JSON and checks all states are SUCCESS or SKIPPED\n}\n</code></pre>"},{"location":"guards/#codeowners-approve","title":"codeowners-approve","text":"<p>File: <code>internal/policy/guards/builtin/codeowners.go</code></p> <p>Purpose: Require approval from repository CODEOWNERS.</p> <p>Implementation:</p> <pre><code>type CodeownersApproveGuard struct{}\n\nfunc (g *CodeownersApproveGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // Uses `gh api` to fetch PR reviews\n    // Checks if any reviewer is a CODEOWNER\n}\n</code></pre>"},{"location":"guards/#security-scan","title":"security-scan","text":"<p>File: <code>internal/policy/guards/builtin/security_scan.go</code></p> <p>Purpose: Verify security scans (CodeQL, Trivy, SAST) pass.</p> <p>Implementation:</p> <pre><code>type SecurityScanGuard struct{}\n\nfunc (g *SecurityScanGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // Uses `gh api` to fetch workflow runs\n    // Filters for security-related workflows\n    // Verifies all completed successfully\n}\n</code></pre>"},{"location":"guards/#creating-custom-guards","title":"Creating Custom Guards","text":""},{"location":"guards/#step-1-implement-the-guard-interface","title":"Step 1: Implement the Guard Interface","text":"<p>Create a new Go file implementing the <code>Guard</code> interface:</p> <pre><code>// examples/guards/custom/slack_approval.go\npackage custom\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n\n    \"github.com/santosr2/uptool/internal/policy/guards\"\n)\n\n// SlackApprovalGuard checks if a PR has been approved via Slack thumbs-up reaction.\ntype SlackApprovalGuard struct{}\n\n// Name returns the guard's unique identifier.\nfunc (g *SlackApprovalGuard) Name() string {\n    return \"slack-approval\"\n}\n\n// Description returns a human-readable description of the guard.\nfunc (g *SlackApprovalGuard) Description() string {\n    return \"Verifies that the PR has been approved via Slack thumbs-up reaction\"\n}\n\n// Check verifies that the PR announcement in Slack has a thumbs-up reaction.\nfunc (g *SlackApprovalGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // 1. Get configuration from environment\n    slackToken := os.Getenv(\"SLACK_BOT_TOKEN\")\n    if slackToken == \"\" {\n        return false, fmt.Errorf(\"SLACK_BOT_TOKEN not set\")\n    }\n\n    channelID := os.Getenv(\"SLACK_CHANNEL_ID\")\n    if channelID == \"\" {\n        return false, fmt.Errorf(\"SLACK_CHANNEL_ID not set\")\n    }\n\n    // 2. Search for message about this PR\n    prURL := fmt.Sprintf(\"https://github.com/%s/pull/%s\", env.GitHubRepo, env.GitHubPRNumber)\n\n    client := &amp;http.Client{Timeout: 10 * time.Second}\n\n    // Search messages in channel\n    searchURL := fmt.Sprintf(\"https://slack.com/api/search.messages?query=%s&amp;count=1\", prURL)\n    req, err := http.NewRequestWithContext(ctx, \"GET\", searchURL, nil)\n    if err != nil {\n        return false, fmt.Errorf(\"creating request: %w\", err)\n    }\n\n    req.Header.Set(\"Authorization\", \"Bearer \"+slackToken)\n    resp, err := client.Do(req)\n    if err != nil {\n        return false, fmt.Errorf(\"searching Slack messages: %w\", err)\n    }\n    defer func() {\n        _ = resp.Body.Close() //nolint:errcheck // Best effort close\n    }()\n\n    var searchResult struct {\n        Messages struct {\n            Matches []struct {\n                TS      string `json:\"ts\"`\n                Channel struct {\n                    ID string `json:\"id\"`\n                } `json:\"channel\"`\n            } `json:\"matches\"`\n        } `json:\"messages\"`\n    }\n\n    if err := json.NewDecoder(resp.Body).Decode(&amp;searchResult); err != nil {\n        return false, fmt.Errorf(\"decoding search result: %w\", err)\n    }\n\n    if len(searchResult.Messages.Matches) == 0 {\n        return false, fmt.Errorf(\"no Slack message found for PR %s\", env.GitHubPRNumber)\n    }\n\n    messageTS := searchResult.Messages.Matches[0].TS\n\n    // 3. Get reactions on the message\n    reactionsURL := fmt.Sprintf(\n        \"https://slack.com/api/reactions.get?channel=%s&amp;timestamp=%s\",\n        channelID,\n        messageTS,\n    )\n\n    req, err = http.NewRequestWithContext(ctx, \"GET\", reactionsURL, nil)\n    if err != nil {\n        return false, fmt.Errorf(\"creating reactions request: %w\", err)\n    }\n\n    req.Header.Set(\"Authorization\", \"Bearer \"+slackToken)\n    resp, err = client.Do(req)\n    if err != nil {\n        return false, fmt.Errorf(\"fetching reactions: %w\", err)\n    }\n    defer func() {\n        _ = resp.Body.Close() //nolint:errcheck // Best effort close\n    }()\n\n    var reactionsResult struct {\n        Message struct {\n            Reactions []struct {\n                Name  string `json:\"name\"`\n                Count int    `json:\"count\"`\n            } `json:\"reactions\"`\n        } `json:\"message\"`\n    }\n\n    if err := json.NewDecoder(resp.Body).Decode(&amp;reactionsResult); err != nil {\n        return false, fmt.Errorf(\"decoding reactions: %w\", err)\n    }\n\n    // 4. Check for thumbs-up reaction\n    for _, reaction := range reactionsResult.Message.Reactions {\n        if reaction.Name == \"+1\" &amp;&amp; reaction.Count &gt; 0 {\n            return true, nil\n        }\n    }\n\n    return false, nil\n}\n</code></pre>"},{"location":"guards/#step-2-register-the-guard","title":"Step 2: Register the Guard","text":"<p>Register via <code>init()</code> function:</p> <pre><code>func init() {\n    guards.Register(&amp;SlackApprovalGuard{})\n}\n</code></pre> <p>Important: This <code>init()</code> function runs automatically when the package is imported.</p>"},{"location":"guards/#step-3-import-the-guard-package","title":"Step 3: Import the Guard Package","text":"<p>There are two approaches to using your custom guard:</p>"},{"location":"guards/#option-a-modify-uptool-source-recommended","title":"Option A: Modify uptool Source (Recommended)","text":"<p>Import your guard package in <code>internal/policy/enforcement.go</code>:</p> <pre><code>import (\n    _ \"github.com/santosr2/uptool/examples/guards/custom\" // Custom guards\n    _ \"github.com/santosr2/uptool/internal/policy/guards/builtin\"\n)\n</code></pre> <p>Then rebuild uptool:</p> <pre><code>go build -o uptool ./cmd/uptool\n</code></pre>"},{"location":"guards/#option-b-go-plugin-future","title":"Option B: Go Plugin (Future)","text":"<p>In a future release, uptool will support loading guards as Go plugins (<code>.so</code> files):</p> <pre><code># Build your guard as a plugin\ngo build -buildmode=plugin -o my_guard.so custom/my_guard.go\n\n# Load it via environment variable\nexport UPTOOL_GUARD_PLUGINS=\"./my_guard.so\"\nuptool check-policy\n</code></pre> <p>Note: Plugin support is planned but not yet implemented.</p>"},{"location":"guards/#step-4-configure-the-guard","title":"Step 4: Configure the Guard","text":"<p>Add your guard to <code>uptool.yaml</code>:</p> <pre><code>org_policy:\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"         # Built-in\n      - \"slack-approval\"   # Your custom guard\n</code></pre>"},{"location":"guards/#step-5-set-environment-variables","title":"Step 5: Set Environment Variables","text":"<p>Custom guards often need configuration via environment variables:</p> <pre><code>export SLACK_BOT_TOKEN=\"xoxb-your-token\"\nexport SLACK_CHANNEL_ID=\"C01234567\"\nexport GITHUB_TOKEN=\"ghp_your_token\"\nexport GITHUB_REPOSITORY=\"owner/repo\"\nexport GITHUB_PR_NUMBER=\"123\"\n\nuptool check-policy\n</code></pre>"},{"location":"guards/#code-generation","title":"Code Generation","text":"<p>uptool uses code generation to automatically maintain the guard registry.</p>"},{"location":"guards/#how-it-works","title":"How It Works","text":"<ol> <li>Generator script: <code>scripts/gen_guards.go</code> scans <code>internal/policy/guards/builtin/</code> for guard files</li> <li>Generated file: <code>internal/policy/guards/builtin/all.go</code> lists all discovered guards</li> <li>Build integration: Running <code>go generate ./internal/policy/guards</code> regenerates the file</li> </ol>"},{"location":"guards/#generated-file-structure","title":"Generated File Structure","text":"<pre><code>// Code generated by scripts/gen_guards.go. DO NOT EDIT.\n\n// Package builtin registers all built-in auto-merge guards.\n// The guards are registered via init() functions in their individual files:\n//   - ci_green.go\n//   - codeowners.go\n//   - security_scan.go\npackage builtin\n\n// This file intentionally blank - guard registration happens via init() functions\n// in individual guard files.\n</code></pre>"},{"location":"guards/#triggering-generation","title":"Triggering Generation","text":"<p>Three ways to regenerate:</p> <pre><code># 1. Via go generate\ngo generate ./internal/policy/guards\n\n# 2. Via generator script\ngo run scripts/gen_guards.go\n\n# 3. Via mise task (runs both integrations and guards)\nmise run generate\n</code></pre>"},{"location":"guards/#adding-new-built-in-guards","title":"Adding New Built-in Guards","text":"<ol> <li>Create <code>internal/policy/guards/builtin/my_guard.go</code></li> <li>Implement the <code>Guard</code> interface</li> <li>Add <code>init()</code> function to register the guard</li> <li>Run <code>go generate ./internal/policy/guards</code></li> <li>The guard is now automatically included in <code>all.go</code></li> </ol> <p>Example:</p> <pre><code># Create new guard\ncat &gt; internal/policy/guards/builtin/jira_linked.go &lt;&lt;'EOF'\npackage builtin\n\nimport (\n    \"context\"\n    \"github.com/santosr2/uptool/internal/policy/guards\"\n)\n\ntype JiraLinkedGuard struct{}\n\nfunc init() {\n    guards.Register(&amp;JiraLinkedGuard{})\n}\n\nfunc (g *JiraLinkedGuard) Name() string {\n    return \"jira-linked\"\n}\n\nfunc (g *JiraLinkedGuard) Description() string {\n    return \"Verifies that the PR is linked to a JIRA ticket\"\n}\n\nfunc (g *JiraLinkedGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // Implementation here\n    return true, nil\n}\nEOF\n\n# Regenerate\ngo generate ./internal/policy/guards\n\n# Verify\ngit diff internal/policy/guards/builtin/all.go\n</code></pre>"},{"location":"guards/#best-practices","title":"Best Practices","text":""},{"location":"guards/#1-validate-inputs","title":"1. Validate Inputs","text":"<p>Always validate environment variables and API responses:</p> <pre><code>func (g *MyGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    token := os.Getenv(\"MY_API_TOKEN\")\n    if token == \"\" {\n        return false, fmt.Errorf(\"MY_API_TOKEN not set\")\n    }\n\n    // Validate env.GitHubPRNumber is numeric (already validated by caller, but defensive)\n    if env.GitHubPRNumber == \"\" {\n        return false, fmt.Errorf(\"PR number is empty\")\n    }\n\n    // Continue with guard logic...\n}\n</code></pre>"},{"location":"guards/#2-use-context-timeouts","title":"2. Use Context Timeouts","text":"<p>Set reasonable timeouts for external API calls:</p> <pre><code>func (g *MyGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    client := &amp;http.Client{\n        Timeout: 10 * time.Second, // Reasonable timeout\n    }\n\n    req, err := http.NewRequestWithContext(ctx, \"GET\", apiURL, nil)\n    // Use ctx to respect upstream cancellation\n}\n</code></pre>"},{"location":"guards/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<p>Return meaningful errors to help with debugging:</p> <pre><code>if resp.StatusCode != http.StatusOK {\n    body, _ := io.ReadAll(resp.Body)\n    return false, fmt.Errorf(\n        \"API returned %d: %s\",\n        resp.StatusCode,\n        string(body),\n    )\n}\n</code></pre>"},{"location":"guards/#4-never-log-secrets","title":"4. Never Log Secrets","text":"<p>Avoid logging tokens, credentials, or sensitive data:</p> <pre><code>// BAD - logs token\nlog.Printf(\"Using token: %s\", token)\n\n// GOOD - no secrets logged\nlog.Printf(\"Making API request to %s\", apiURL)\n</code></pre>"},{"location":"guards/#5-write-tests","title":"5. Write Tests","text":"<p>Create unit tests for your guards:</p> <pre><code>// examples/guards/custom/slack_approval_test.go\npackage custom_test\n\nimport (\n    \"context\"\n    \"testing\"\n\n    \"github.com/santosr2/uptool/examples/guards/custom\"\n    \"github.com/santosr2/uptool/internal/policy/guards\"\n)\n\nfunc TestSlackApprovalGuard_Name(t *testing.T) {\n    g := &amp;custom.SlackApprovalGuard{}\n    if got := g.Name(); got != \"slack-approval\" {\n        t.Errorf(\"Name() = %q, want %q\", got, \"slack-approval\")\n    }\n}\n\nfunc TestSlackApprovalGuard_Check(t *testing.T) {\n    // Use environment variables or mocks for testing\n    t.Setenv(\"SLACK_BOT_TOKEN\", \"test-token\")\n    t.Setenv(\"SLACK_CHANNEL_ID\", \"C123\")\n\n    g := &amp;custom.SlackApprovalGuard{}\n    env := &amp;guards.Environment{\n        GitHubRepo:     \"owner/repo\",\n        GitHubToken:    \"test-gh-token\",\n        GitHubPRNumber: \"42\",\n    }\n\n    // Test with mock HTTP server or skip integration tests\n    t.Skip(\"Integration test - requires Slack API\")\n\n    ctx := context.Background()\n    satisfied, err := g.Check(ctx, env)\n    if err != nil {\n        t.Fatalf(\"Check() error = %v\", err)\n    }\n\n    t.Logf(\"Guard satisfied: %v\", satisfied)\n}\n</code></pre>"},{"location":"guards/#6-add-clear-documentation","title":"6. Add Clear Documentation","text":"<p>Document guard behavior in the <code>Description()</code> method:</p> <pre><code>func (g *MyGuard) Description() string {\n    return \"Verifies that the PR has been approved in the ACME ticketing system \" +\n           \"(requires ACME_API_TOKEN and ACME_PROJECT_ID environment variables)\"\n}\n</code></pre>"},{"location":"guards/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guards/#guard-not-found","title":"Guard Not Found","text":"<p>Error: <code>unknown guard: my-custom-guard</code></p> <p>Cause: Guard not registered in the registry.</p> <p>Solution:</p> <ol> <li>Verify <code>init()</code> function calls <code>guards.Register()</code></li> <li>Ensure guard package is imported (with <code>_</code> blank import if needed)</li> <li>Check that the guard file is in the correct directory</li> </ol>"},{"location":"guards/#guard-always-returns-false","title":"Guard Always Returns False","text":"<p>Symptom: Guard consistently fails even when conditions should pass.</p> <p>Debug steps:</p> <ol> <li>Add debug logging to your <code>Check()</code> method</li> <li>Run <code>uptool check-policy --verbose</code> to see detailed output</li> <li>Verify environment variables are set correctly</li> <li>Check API responses for unexpected formats</li> </ol>"},{"location":"guards/#permission-errors","title":"Permission Errors","text":"<p>Error: <code>403 Forbidden</code> or <code>401 Unauthorized</code></p> <p>Cause: Missing or incorrect API tokens.</p> <p>Solution:</p> <ol> <li>Verify all required environment variables are set</li> <li>Check that API tokens have required permissions</li> <li>Test API access manually with <code>curl</code> or similar tools</li> </ol>"},{"location":"guards/#timeout-errors","title":"Timeout Errors","text":"<p>Error: <code>context deadline exceeded</code></p> <p>Cause: Guard taking too long to execute.</p> <p>Solution:</p> <ol> <li>Increase HTTP client timeout if reasonable</li> <li>Optimize API calls (batch requests, caching)</li> <li>Consider implementing retry logic with backoff</li> </ol>"},{"location":"guards/#examples","title":"Examples","text":""},{"location":"guards/#minimal-guard","title":"Minimal Guard","text":"<pre><code>type SimpleGuard struct{}\n\nfunc init() {\n    guards.Register(&amp;SimpleGuard{})\n}\n\nfunc (g *SimpleGuard) Name() string {\n    return \"simple\"\n}\n\nfunc (g *SimpleGuard) Description() string {\n    return \"Always passes (for testing)\"\n}\n\nfunc (g *SimpleGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    return true, nil\n}\n</code></pre>"},{"location":"guards/#guard-with-external-api","title":"Guard with External API","text":"<p>See <code>examples/guards/custom/slack_approval.go</code> for a complete example.</p>"},{"location":"guards/#guard-with-custom-configuration","title":"Guard with Custom Configuration","text":"<pre><code>type ConfigurableGuard struct {\n    Threshold int\n}\n\nfunc init() {\n    threshold := 3\n    if val := os.Getenv(\"MY_GUARD_THRESHOLD\"); val != \"\" {\n        if parsed, err := strconv.Atoi(val); err == nil {\n            threshold = parsed\n        }\n    }\n\n    guards.Register(&amp;ConfigurableGuard{Threshold: threshold})\n}\n\nfunc (g *ConfigurableGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // Use g.Threshold in logic\n    approvals := getApprovalCount(env)\n    return approvals &gt;= g.Threshold, nil\n}\n</code></pre>"},{"location":"guards/#contributing-built-in-guards","title":"Contributing Built-in Guards","text":"<p>If you create a useful custom guard, consider contributing it as a built-in guard:</p> <ol> <li>Move guard to <code>internal/policy/guards/builtin/</code></li> <li>Add comprehensive unit tests</li> <li>Update documentation in this file</li> <li>Submit a pull request</li> </ol> <p>Example PR:</p> <ul> <li>File: <code>internal/policy/guards/builtin/jira_linked.go</code></li> <li>Tests: <code>internal/policy/guards/builtin/jira_linked_test.go</code></li> <li>Docs: Update this file with guard description</li> <li>Changelog: Add entry to <code>CHANGELOG.md</code></li> </ul>"},{"location":"guards/#related-documentation","title":"Related Documentation","text":"<ul> <li>Organization Policy - Overview of org_policy configuration</li> <li>Configuration - Full configuration reference</li> <li>Architecture - System architecture</li> <li>Guard Examples - Complete guard examples</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This page covers various methods to install uptool on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25+ (if installing from source)</li> <li>Git (for version control)</li> <li>Internet connection (for downloading binaries or building from source)</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-docker-recommended","title":"Method 1: Docker (Recommended)","text":"<p>The easiest way to get started with uptool is using Docker. This method requires no local installation and works across all platforms.</p> <pre><code># Pull the latest stable image\ndocker pull ghcr.io/santosr2/uptool:latest\n\n# Run uptool directly\ndocker run --rm -v \"$PWD:/workspace\" ghcr.io/santosr2/uptool version\n\n# Create an alias for convenience\necho 'alias uptool=\"docker run --rm -v \\\"\\$PWD:/workspace\\\" ghcr.io/santosr2/uptool\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n# Now you can use uptool as a regular command\nuptool scan\n</code></pre> <p>Docker Image Tags</p> <ul> <li><code>latest</code> - Latest stable release</li> <li><code>v1.0.0</code> - Specific version (immutable)</li> <li><code>v1</code> - Latest v1.x.x release (mutable)</li> <li><code>v1.0</code> - Latest v1.0.x patch (mutable)</li> <li><code>v1.0.0-rc1</code> - Pre-release versions</li> </ul> <p>Multi-platform Support</p> <p>The Docker image supports both <code>linux/amd64</code> and <code>linux/arm64</code> architectures automatically.</p>"},{"location":"installation/#method-2-go-install-for-go-users","title":"Method 2: Go Install (For Go users)","text":"<p>If you have Go 1.25+ installed:</p> <pre><code>go install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre> <p>This will install the latest version of uptool to your <code>$GOPATH/bin</code> directory.</p> <p>Add to PATH</p> <p>Ensure <code>$GOPATH/bin</code> is in your <code>$PATH</code>: <pre><code>export PATH=\"$PATH:$(go env GOPATH)/bin\"\n</code></pre></p>"},{"location":"installation/#method-3-pre-built-binaries","title":"Method 3: Pre-built Binaries","text":"<p>Download pre-compiled binaries from the GitHub Releases page.</p> Linux (AMD64) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-linux-amd64\nchmod +x uptool-linux-amd64\nsudo mv uptool-linux-amd64 /usr/local/bin/uptool\n</code></pre> Linux (ARM64) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-linux-arm64\nchmod +x uptool-linux-arm64\nsudo mv uptool-linux-arm64 /usr/local/bin/uptool\n</code></pre> macOS (Apple Silicon) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-darwin-arm64\nchmod +x uptool-darwin-arm64\nsudo mv uptool-darwin-arm64 /usr/local/bin/uptool\n</code></pre> macOS (Intel) <pre><code>curl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-darwin-amd64\nchmod +x uptool-darwin-amd64\nsudo mv uptool-darwin-amd64 /usr/local/bin/uptool\n</code></pre> Windows (AMD64) <pre><code># Download from GitHub Releases\nInvoke-WebRequest -Uri https://github.com/santosr2/uptool/releases/latest/download/uptool-windows-amd64.exe -OutFile uptool.exe\n\n# Move to a directory in your PATH\nMove-Item uptool.exe C:\\Windows\\System32\\uptool.exe\n</code></pre>"},{"location":"installation/#method-3-build-from-source","title":"Method 3: Build from Source","text":"<p>Clone the repository and build from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/santosr2/uptool.git\ncd uptool\n\n# Build the binary\nmise run build\n\n# Install to $GOPATH/bin\nmise run install\n\n# Or manually copy the binary\nsudo cp dist/uptool /usr/local/bin/\n</code></pre>"},{"location":"installation/#method-4-using-mise-development-environment","title":"Method 4: Using mise (Development Environment)","text":"<p>If you use mise for managing development tools:</p> <pre><code># Add to your mise.toml\necho 'uptool = \"latest\"' &gt;&gt; mise.toml\n\n# Install\nmise install\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify the installation by checking the version:</p> <pre><code>uptool version\n</code></pre> <p>Expected output:</p> <pre><code>uptool version main\n</code></pre>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>After installation, you may want to configure uptool for your project. See the Configuration Guide for details.</p>"},{"location":"installation/#updating-uptool","title":"Updating uptool","text":""},{"location":"installation/#docker","title":"Docker","text":"<p>Docker images are always up-to-date when you pull:</p> <pre><code># Pull the latest stable release\ndocker pull ghcr.io/santosr2/uptool:latest\n\n# Or pull a specific version\ndocker pull ghcr.io/santosr2/uptool:v1.0.0\n</code></pre>"},{"location":"installation/#go-install","title":"Go Install","text":"<pre><code>go install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre>"},{"location":"installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release and replace your existing binary.</p>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>cd uptool\ngit pull origin main\nmise run build\nsudo cp dist/uptool /usr/local/bin/\n</code></pre>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":""},{"location":"installation/#go-install_1","title":"Go Install","text":"<pre><code>rm $(which uptool)\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<pre><code>sudo rm /usr/local/bin/uptool\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started with your first project</li> <li>Configuration - Learn about uptool configuration</li> <li>GitHub Action Usage - Use uptool in CI/CD</li> </ul>"},{"location":"manifests/","title":"Manifest Files Reference","text":"<p>uptool is a manifest-first dependency updater. This document catalogs all supported manifest file types across different ecosystems.</p>"},{"location":"manifests/#philosophy-manifest-first","title":"Philosophy: Manifest-First","text":"<p>uptool updates manifest files (source of truth) rather than lockfiles or resolved dependencies:</p> <ol> <li>Manifests declare intent - They specify which versions you want</li> <li>Lockfiles are generated - They record resolved versions</li> <li>Update manifests first - Changes propagate to lockfiles via native tools</li> </ol> <p>This ensures your declared dependencies stay current, not just resolved versions.</p>"},{"location":"manifests/#supported-manifest-types","title":"Supported Manifest Types","text":""},{"location":"manifests/#javascriptnodejs-npm","title":"JavaScript/Node.js (npm)","text":"<p>Integration: <code>npm</code></p> <p>Manifest Files:</p> <ul> <li><code>package.json</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>dependencies</code></li> <li><code>devDependencies</code></li> <li><code>peerDependencies</code></li> <li><code>optionalDependencies</code></li> </ul> <p>Update Strategy:</p> <ul> <li>Custom JSON rewriting</li> <li>Preserves version constraint prefixes (<code>^</code>, <code>~</code>, <code>&gt;=</code>, etc.)</li> <li>Preserves formatting and key order</li> </ul> <p>Example:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",     // Updated to \"^4.19.2\"\n    \"lodash\": \"~4.17.20\"       // Updated to \"~4.17.21\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"&gt;=29.0.0\"         // Updated to \"&gt;=29.7.0\"\n  }\n}\n</code></pre> <p>Registry: npm Registry API (<code>https://registry.npmjs.org</code>)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>package-lock.json</code> directly</li> <li>Run <code>npm install</code> after updating to regenerate lockfile</li> <li>Workspace support: Yes (monorepos with <code>workspaces</code> field)</li> </ul>"},{"location":"manifests/#kuberneteshelm","title":"Kubernetes/Helm","text":"<p>Integration: <code>helm</code></p> <p>Manifest Files:</p> <ul> <li><code>Chart.yaml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>dependencies[].version</code> - Chart dependencies</li> </ul> <p>Update Strategy:</p> <ul> <li>YAML parsing and rewriting</li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>apiVersion: v2\nname: my-app\ndependencies:\n  - name: postgresql\n    version: 12.0.0           # Updated to 18.1.8\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 17.0.0           # Updated to 23.2.12\n    repository: https://charts.bitnami.com/bitnami\n</code></pre> <p>Registry: Helm chart repositories (index.yaml)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>Chart.lock</code></li> <li>Run <code>helm dependency update</code> after to regenerate lockfile</li> <li>Only updates dependency versions, not chart metadata</li> </ul>"},{"location":"manifests/#terraform","title":"Terraform","text":"<p>Integration: <code>terraform</code></p> <p>Manifest Files:</p> <ul> <li><code>*.tf</code> (any Terraform file)</li> <li><code>main.tf</code>, <code>modules.tf</code>, <code>providers.tf</code>, etc.</li> </ul> <p>What Gets Updated:</p> <ul> <li><code>module</code> block <code>version</code> attributes</li> <li>Module source versions in git URLs (future)</li> <li>Provider versions (future)</li> </ul> <p>Update Strategy:</p> <ul> <li>HCL parsing and rewriting via <code>hashicorp/hcl</code></li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"           # Updated to \"5.13.0\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 4.0\"          # Updated to \"~&gt; 5.0\"\n}\n</code></pre> <p>Registry: Terraform Registry API (<code>https://registry.terraform.io</code>)</p> <p>Notes:</p> <ul> <li>Does NOT update <code>.terraform.lock.hcl</code></li> <li>Run <code>terraform init -upgrade</code> after to regenerate lockfile</li> <li>Version constraints are preserved</li> </ul>"},{"location":"manifests/#tflint","title":"tflint","text":"<p>Integration: <code>tflint</code></p> <p>Manifest Files:</p> <ul> <li><code>.tflint.hcl</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>plugin</code> block <code>version</code> attributes</li> </ul> <p>Update Strategy:</p> <ul> <li>HCL parsing and rewriting</li> <li>Preserves comments and formatting</li> </ul> <p>Example:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"          # Updated to \"0.44.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.20.0\"          # Updated to \"0.28.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n</code></pre> <p>Registry: GitHub Releases (for plugins)</p> <p>Notes:</p> <ul> <li>Plugin sources must be valid GitHub repository paths</li> <li>Follows semantic versioning</li> </ul>"},{"location":"manifests/#pre-commit-hooks","title":"Pre-Commit Hooks","text":"<p>Integration: <code>precommit</code></p> <p>Manifest Files:</p> <ul> <li><code>.pre-commit-config.yaml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>repos[].rev</code> - Hook repository revisions</li> </ul> <p>Update Strategy:</p> <ul> <li>Native command: <code>pre-commit autoupdate</code></li> <li>Uses pre-commit's built-in update mechanism</li> <li>This is because <code>pre-commit autoupdate</code> updates the manifest directly</li> </ul> <p>Example:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0               # Updated to v6.0.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n\n  - repo: https://github.com/psf/black\n    rev: 22.10.0              # Updated to 24.10.0\n    hooks:\n      - id: black\n</code></pre> <p>Registry: GitHub Releases (for hook repositories)</p> <p>Notes:</p> <ul> <li>Uses native <code>pre-commit autoupdate</code> command</li> <li>Respects minimum_pre_commit_version</li> <li>Does NOT create <code>.pre-commit-config.yaml.lock</code> (pre-commit doesn't use lockfiles)</li> </ul>"},{"location":"manifests/#asdf-version-manager","title":"asdf Version Manager","text":"<p>Integration: <code>asdf</code></p> <p>Manifest Files:</p> <ul> <li><code>.tool-versions</code></li> </ul> <p>What Gets Updated:</p> <ul> <li>Tool versions (e.g., <code>go 1.23.0</code> \u2192 <code>go 1.25.0</code>)</li> </ul> <p>Update Strategy:</p> <ul> <li>Line-based parsing and rewriting</li> <li>Preserves formatting and comments</li> </ul> <p>Example:</p> <pre><code># Development tools\ngo 1.23.0                     # Updated to 1.25.0\nnodejs 20.10.0                # Updated to 22.12.0\nterraform 1.5.0               # Updated to 1.10.5\n\n# Build tools\npython 3.11.0                 # Updated to 3.13.1\n</code></pre> <p>Registry: GitHub Releases (per tool via asdf plugin mapping)</p> <p>Notes:</p> <ul> <li>Does NOT update installed versions</li> <li>Run <code>asdf install</code> after to install new versions</li> <li>Supports multiple versions per tool (space-separated)</li> </ul>"},{"location":"manifests/#mise-version-manager","title":"mise Version Manager","text":"<p>Integration: <code>mise</code></p> <p>Manifest Files:</p> <ul> <li><code>mise.toml</code></li> <li><code>.mise.toml</code></li> </ul> <p>What Gets Updated:</p> <ul> <li><code>[tools]</code> section tool versions</li> </ul> <p>Update Strategy:</p> <ul> <li>TOML parsing and rewriting</li> <li>Supports both string format and map format</li> <li>Preserves comments and formatting</li> </ul> <p>Example (String Format):</p> <pre><code>[tools]\ngo = \"1.23\"                   # Updated to \"1.25\"\nnode = \"20\"                   # Updated to \"22\"\ngolangci-lint = \"2.6\"         # Updated to \"2.7\"\nterraform = \"1.5.0\"           # Updated to \"1.10.5\"\n</code></pre> <p>Example (Map Format):</p> <pre><code>[tools]\ngo = { version = \"1.23\" }     # Updated to { version = \"1.25\" }\nnode = { version = \"20\", path = \".nvmrc\" }\n</code></pre> <p>Registry: GitHub Releases (per tool)</p> <p>Notes:</p> <ul> <li>Does NOT install new versions automatically</li> <li>Run <code>mise install</code> after to install new versions</li> <li>Supports both mise.toml and .mise.toml (hidden file)</li> </ul>"},{"location":"manifests/#manifest-detection","title":"Manifest Detection","text":"<p>uptool automatically detects manifest files by:</p> <ol> <li>Filename matching: Exact matches like <code>package.json</code>, <code>Chart.yaml</code></li> <li>Pattern matching: Glob patterns like <code>*.tf</code>, <code>mise.toml</code></li> <li>Directory walking: Recursively scans from repository root</li> </ol>"},{"location":"manifests/#detection-order","title":"Detection Order","text":"<p>Each integration defines its own detection logic:</p> <pre><code>// Example: npm integration\nfunc Detect(ctx context.Context, repoRoot string) ([]*Manifest, error) {\n    // Look for package.json files\n    matches, err := filepath.Glob(filepath.Join(repoRoot, \"**/package.json\"))\n    // ...\n}\n</code></pre>"},{"location":"manifests/#ignored-directories","title":"Ignored Directories","text":"<p>By default, uptool skips:</p> <ul> <li><code>.git/</code></li> <li><code>node_modules/</code></li> <li><code>vendor/</code></li> <li><code>.terraform/</code></li> <li><code>dist/</code>, <code>build/</code></li> </ul>"},{"location":"manifests/#manifest-first-principles","title":"Manifest-First Principles","text":""},{"location":"manifests/#do-update-manifests","title":"\u2705 DO: Update Manifests","text":"<pre><code># Good: Updates package.json (manifest)\nuptool update --only=npm\n\n# Then regenerate lockfile\nnpm install\n</code></pre>"},{"location":"manifests/#dont-rely-on-lockfile-only-tools","title":"\u274c DON'T: Rely on Lockfile-Only Tools","text":"<pre><code># Bad: npm update only updates package-lock.json\nnpm update\n\n# package.json still has old versions!\n</code></pre>"},{"location":"manifests/#why-manifest-first","title":"Why Manifest-First?","text":"<ol> <li>Intent over resolution: Manifests declare what you want, lockfiles record what you got</li> <li>Portability: Manifests work across environments, lockfiles don't</li> <li>Auditability: Changes to manifests are explicit in version control</li> <li>Consistency: Everyone gets the same declared versions</li> </ol>"},{"location":"manifests/#native-commands-vs-custom-rewriting","title":"Native Commands vs Custom Rewriting","text":""},{"location":"manifests/#when-native-commands-are-used","title":"When Native Commands Are Used","text":"<p>uptool uses native commands only when they update the manifest:</p> Integration Native Command Reason <code>precommit</code> <code>pre-commit autoupdate</code> Updates <code>.pre-commit-config.yaml</code> directly"},{"location":"manifests/#when-custom-rewriting-is-used","title":"When Custom Rewriting Is Used","text":"<p>All other integrations use custom parsing/rewriting:</p> Integration Reason <code>npm</code> <code>npm update</code> only updates lockfile <code>helm</code> <code>helm dependency update</code> only updates Chart.lock <code>terraform</code> <code>terraform init -upgrade</code> only updates .terraform.lock.hcl <code>tflint</code> No native update command exists <code>asdf</code> <code>.tool-versions</code> is plain text, no native update <code>mise</code> <code>mise.toml</code> is TOML, custom parsing needed"},{"location":"manifests/#configuration","title":"Configuration","text":"<p>You can configure which manifests to process via <code>uptool.yaml</code>:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor              # Only minor/patch updates\n\n  - id: helm\n    enabled: true\n    policy:\n      update: minor\n\n  - id: terraform\n    enabled: false               # Disable Terraform updates\n</code></pre> <p>See configuration.md for complete reference.</p>"},{"location":"manifests/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference - Configure update policies</li> <li>Troubleshooting Guide - Common issues and solutions</li> <li>Integration Guides - Detailed integration documentation</li> </ul>"},{"location":"overview/","title":"Overview","text":"<p>Universal, manifest-first dependency updater for multiple ecosystems.</p>"},{"location":"overview/#what-is-uptool","title":"What is uptool?","text":"<p>Updates manifest files directly (package.json, Chart.yaml, *.tf) instead of just lockfiles, preserving your declared dependencies while keeping them current.</p>"},{"location":"overview/#manifest-first-philosophy","title":"Manifest-First Philosophy","text":"<ol> <li>Update manifests first (package.json, Chart.yaml, *.tf)</li> <li>Use native commands only when they update manifests (<code>pre-commit autoupdate</code> \u2705, <code>npm update</code> \u274c)</li> <li>Then run lockfile updates (<code>npm install</code>, <code>terraform init</code>)</li> </ol>"},{"location":"overview/#supported-integrations","title":"Supported Integrations","text":"<p>npm, Helm, Terraform, tflint, pre-commit, GitHub Actions, Docker, asdf (experimental), mise (experimental)</p> <p>See Integrations for complete list.</p>"},{"location":"overview/#key-features","title":"Key Features","text":"<p>Multi-ecosystem support \u2022 Manifest-first updates \u2022 CLI &amp; GitHub Action \u2022 Safe by default \u2022 Concurrent execution \u2022 Flexible filtering</p>"},{"location":"overview/#documentation","title":"Documentation","text":"<ul> <li>Installation \u2022 Quick Start \u2022 Configuration</li> <li>CLI Reference \u2022 Integrations \u2022 GitHub Action</li> <li>Architecture \u2022 Main README</li> </ul>"},{"location":"patch-release-workflow/","title":"Patch Release Workflow Guide","text":"<p>This guide explains how to manage security patches and bug fixes for previous minor versions of uptool, in accordance with our Security Policy.</p>"},{"location":"patch-release-workflow/#overview","title":"Overview","text":"<p>uptool supports multiple minor versions simultaneously:</p> <ul> <li>Latest minor version (e.g., 0.2.x): Full support (features, bug fixes, security patches)</li> <li>Previous minor version (e.g., 0.1.x): Security patches only for 6 months after next minor release</li> <li>Older versions: No support</li> </ul>"},{"location":"patch-release-workflow/#workflow-files","title":"Workflow Files","text":""},{"location":"patch-release-workflow/#1-create-release-branch-create-release-branchyml","title":"1. Create Release Branch (<code>create-release-branch.yml</code>)","text":"<p>Purpose: Create a long-lived release branch for a minor version to enable backporting.</p> <p>When to use: After releasing a new minor version (e.g., after v0.2.0 is released, create <code>release-0.1</code> for backports).</p> <p>How to use:</p> <ol> <li>Go to Actions \u2192 Create Release Branch</li> <li>Click Run workflow</li> <li>Enter the minor version (e.g., <code>0.1</code>)</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Creates a <code>release-X.Y</code> branch from the latest <code>vX.Y.Z</code> tag</li> <li>Adds branch protection rules</li> <li>Creates a README explaining the branch purpose</li> </ul> <p>Example:</p> <pre><code>Input: 0.1\nResult: Creates branch `release-0.1` from tag `v0.1.0`\n</code></pre>"},{"location":"patch-release-workflow/#2-patch-release-patch-releaseyml","title":"2. Patch Release (<code>patch-release.yml</code>)","text":"<p>Purpose: Create a patch release (e.g., v0.1.1) from a release branch with security or bug fixes.</p> <p>When to use: After cherry-picking fixes to a release branch.</p> <p>How to use:</p> <ol> <li>Cherry-pick fixes to the release branch:</li> </ol> <pre><code>git checkout release-0.1\ngit cherry-pick &lt;commit-sha&gt;\ngit push origin release-0.1\n</code></pre> <ol> <li>Go to Actions \u2192 Patch Release</li> <li>Click Run workflow</li> <li>Configure:</li> <li>Release branch: <code>release-0.1</code></li> <li>Patch type: <code>security</code> or <code>bugfix</code></li> <li>Changelog notes (optional): Additional context</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Calculates the next patch version (e.g., 0.1.0 \u2192 0.1.1)</li> <li>Updates version files</li> <li>Builds and signs binaries for all platforms</li> <li>Generates SBOM</li> <li>Creates a GitHub release</li> <li>Updates the mutable minor tag (e.g., <code>v0.1</code> \u2192 <code>v0.1.1</code>)</li> </ul> <p>Example:</p> <pre><code>Branch: release-0.1\nCurrent: v0.1.0\nNext: v0.1.1 (security patch)\n</code></pre>"},{"location":"patch-release-workflow/#3-coordinate-security-patches-security-patchyml","title":"3. Coordinate Security Patches (<code>security-patch.yml</code>)","text":"<p>Purpose: Automate cherry-picking security fixes to multiple release branches.</p> <p>When to use: When a security vulnerability affects multiple versions.</p> <p>How to use:</p> <ol> <li> <p>Fix the vulnerability on <code>main</code> and note the commit SHA(s)</p> </li> <li> <p>Go to Actions \u2192 Coordinate Security Patches</p> </li> <li>Click Run workflow</li> <li>Configure:</li> <li>Advisory ID: <code>GHSA-xxxx-xxxx-xxxx</code> (if applicable)</li> <li>Affected versions: <code>0.1.x,0.2.x</code> (comma-separated)</li> <li>Severity: <code>critical</code>, <code>high</code>, <code>medium</code>, or <code>low</code></li> <li>Description: Brief explanation of the vulnerability</li> <li>Fix commits: <code>abc123,def456</code> (commit SHAs from main)</li> <li>Click Run workflow</li> </ol> <p>What it does:</p> <ul> <li>Identifies which release branches need patches</li> <li>Creates patch branches for each affected version</li> <li>Cherry-picks the fix commits</li> <li>Creates PRs for each release branch</li> <li>If cherry-pick fails, creates an issue for manual backporting</li> </ul> <p>Example:</p> <pre><code>Affected: 0.1.x, 0.2.x\nCommits: abc123, def456\nResult:\n  - PR to release-0.1\n  - PR to release-0.2\n</code></pre>"},{"location":"patch-release-workflow/#quick-examples","title":"Quick Examples","text":"<p>Security patch: Fix on main \u2192 Run \"Coordinate Security Patches\" workflow \u2192 Review automated PRs \u2192 Run \"Patch Release\" for each branch \u2192 Publish advisory</p> <p>Bug fix: Cherry-pick to release branch \u2192 Run \"Patch Release\" workflow</p> <p>New release branch: Automatically created when promoting to stable (or use \"Create Release Branch\" workflow)</p>"},{"location":"patch-release-workflow/#release-branch-management","title":"Release Branch Management","text":""},{"location":"patch-release-workflow/#branch-naming","title":"Branch Naming","text":"<ul> <li>Format: <code>release-X.Y</code></li> <li>Examples: <code>release-0.1</code>, <code>release-1.0</code>, <code>release-1.2</code></li> </ul>"},{"location":"patch-release-workflow/#branch-protection","title":"Branch Protection","text":"<p>Release branches have the same protection as <code>main</code>:</p> <ul> <li>Required status checks</li> <li>Required PR reviews</li> <li>No force pushes</li> <li>No deletions</li> </ul>"},{"location":"patch-release-workflow/#support-timeline","title":"Support Timeline","text":"<pre><code>Timeline: Support for release-0.1\n\n0.1.0 released \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 0.2.0 released \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 +6 months \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\n     \u2502                            \u2502                            \u2502\n     \u251c\u2500 Full support              \u251c\u2500 Security patches only     \u251c\u2500 Archive\n     \u2502                            \u2502                            \u2502\nrelease-0.1 created               \u2502                       End of support\n</code></pre>"},{"location":"patch-release-workflow/#end-of-support","title":"End of Support","text":"<p>When a release branch reaches end of support:</p> <ol> <li>Announce end of support (1 month before)</li> <li>Final patch release (if needed)</li> <li>Archive the branch:</li> </ol> <pre><code>git tag archive/release-0.1 release-0.1\ngit push origin archive/release-0.1\n</code></pre> <ol> <li>Update documentation</li> <li>Close remaining PRs/issues for that branch</li> </ol>"},{"location":"patch-release-workflow/#versioning","title":"Versioning","text":""},{"location":"patch-release-workflow/#version-tags","title":"Version Tags","text":"<ul> <li>Immutable tags: <code>v0.1.0</code>, <code>v0.1.1</code>, <code>v0.2.0</code> (never change)</li> <li>Mutable tags: <code>v0.1</code>, <code>v0.2</code>, <code>v0</code> (updated with each patch)</li> </ul>"},{"location":"patch-release-workflow/#tag-updates","title":"Tag Updates","text":"<p>When creating a patch release (e.g., v0.1.1):</p> <ol> <li>Create immutable tag: <code>v0.1.1</code></li> <li>Update mutable minor tag: <code>v0.1</code> \u2192 <code>v0.1.1</code></li> <li>Do NOT update major tag: <code>v0</code> stays at latest minor (e.g., <code>v0.2.0</code>)</li> </ol>"},{"location":"patch-release-workflow/#github-action-pinning","title":"GitHub Action Pinning","text":"<p>Users can pin to different levels:</p> <pre><code># Exact version (most secure, no automatic updates)\n- uses: santosr2/uptool@main\n\n# Minor version (gets security patches automatically)\n- uses: santosr2/uptool@v0.2\n\n# Major version (gets all updates in v0.x)\n- uses: santosr2/uptool@v0\n</code></pre>"},{"location":"patch-release-workflow/#troubleshooting","title":"Troubleshooting","text":"<p>Cherry-pick conflicts: Check created issue for manual backport instructions, resolve conflicts manually, run Patch Release workflow</p> <p>Missing release branch: Run \"Create Release Branch\" workflow first</p> <p>Failed workflow: Check logs, fix issues on release branch, re-run</p> <p>Wrong version: Delete tag, fix version files, re-run workflow</p>"},{"location":"patch-release-workflow/#best-practices","title":"Best Practices","text":"<ul> <li>Only backport critical security fixes and bugs</li> <li>Test patches thoroughly before release</li> <li>Announce security updates via advisories and releases</li> <li>Follow semantic versioning strictly</li> <li>Never change immutable tags or mix features with patches</li> </ul>"},{"location":"patch-release-workflow/#faq","title":"FAQ","text":"<p>When to create release branch? After releasing a new minor version (automated via Promote workflow)</p> <p>Support duration? 6 months security patches after next minor release</p> <p>Backport features? No, only security fixes and critical bugs</p> <p>Cherry-pick conflicts? Workflow creates an issue with manual instructions</p> <p>Update mutable tags? Automatic via workflow</p>"},{"location":"patch-release-workflow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Policy - Support timelines and reporting</li> <li>Contributing Guide - Development workflow</li> <li>Versioning Guide - Semantic versioning details</li> <li>Release Process - Main branch releases</li> </ul>"},{"location":"patch-release-workflow/#support","title":"Support","text":"<p>For questions about patch releases:</p> <ul> <li>GitHub Discussions: https://github.com/santosr2/uptool/discussions</li> <li>Security Issues: https://github.com/santosr2/uptool/security/advisories</li> </ul> <p>Last Updated: 2025-01-16 Maintained By: uptool maintainers</p>"},{"location":"plugin-development/","title":"Plugin Development","text":"<p>Create external plugins to extend uptool with custom integrations.</p>"},{"location":"plugin-development/#overview","title":"Overview","text":"<p>Built-in vs Plugin:</p> <ul> <li>Built-in: Compiled into uptool (npm, Helm, Terraform) - for widely-used ecosystems</li> <li>Plugin: External <code>.so</code> library - for custom/experimental/proprietary integrations</li> </ul> <p>Plugins allow custom integrations without forking uptool.</p>"},{"location":"plugin-development/#plugin-interface","title":"Plugin Interface","text":"<p>Implement the <code>engine.Integration</code> interface:</p> <pre><code>type Integration interface {\n    Name() string\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n    Plan(ctx context.Context, manifest *Manifest, planCtx *PlanContext) (*UpdatePlan, error)\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p>Export a <code>RegisterWith</code> function:</p> <pre><code>func RegisterWith(register func(name string, constructor func() engine.Integration)) {\n    register(\"yourintegration\", New)\n}\n</code></pre>"},{"location":"plugin-development/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugin-development/#1-project-structure","title":"1. Project Structure","text":"<pre><code>my-plugin/\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 plugin.go       # Integration implementation\n\u2514\u2500\u2500 main.go         # Plugin entry point\n</code></pre>"},{"location":"plugin-development/#2-implement-integration","title":"2. Implement Integration","text":"<pre><code>// plugin.go\npackage main\n\nimport (\n    \"context\"\n    \"github.com/santosr2/uptool/internal/engine\"\n)\n\ntype MyIntegration struct{}\n\nfunc New() engine.Integration {\n    return &amp;MyIntegration{}\n}\n\nfunc (i *MyIntegration) Name() string {\n    return \"myintegration\"\n}\n\nfunc (i *MyIntegration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error) {\n    // Find manifest files\n    return manifests, nil\n}\n\nfunc (i *MyIntegration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error) {\n    // Query registry for updates, use planCtx for policy settings\n    return plan, nil\n}\n\nfunc (i *MyIntegration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error) {\n    // Update manifest file\n    return result, nil\n}\n\nfunc (i *MyIntegration) Validate(ctx context.Context, manifest *engine.Manifest) error {\n    // Validate manifest syntax\n    return nil\n}\n</code></pre>"},{"location":"plugin-development/#3-plugin-entry-point","title":"3. Plugin Entry Point","text":"<pre><code>// main.go\npackage main\n\nimport \"github.com/santosr2/uptool/internal/engine\"\n\nfunc RegisterWith(register func(name string, constructor func() engine.Integration)) {\n    register(\"myintegration\", New)\n}\n\nfunc main() {}\n</code></pre>"},{"location":"plugin-development/#4-build-plugin","title":"4. Build Plugin","text":"<pre><code># Build as shared library\ngo build -buildmode=plugin -o myintegration.so .\n</code></pre>"},{"location":"plugin-development/#plugin-discovery","title":"Plugin Discovery","text":"<p>uptool searches for plugins in these locations (in order):</p> <ol> <li><code>./plugins/</code> - Current directory</li> <li><code>~/.config/uptool/plugins/</code> - User config</li> <li><code>/etc/uptool/plugins/</code> - System-wide</li> <li><code>$UPTOOL_PLUGIN_DIR</code> - Custom location</li> </ol> <p>Install:</p> <pre><code>mkdir -p ~/.config/uptool/plugins\ncp myintegration.so ~/.config/uptool/plugins/\n</code></pre> <p>Verify:</p> <pre><code>uptool list --experimental\n# Should show \"myintegration\"\n</code></pre>"},{"location":"plugin-development/#testing","title":"Testing","text":""},{"location":"plugin-development/#unit-tests","title":"Unit Tests","text":"<pre><code>// plugin_test.go\npackage main\n\nimport (\n    \"context\"\n    \"testing\"\n)\n\nfunc TestDetect(t *testing.T) {\n    integration := New()\n    manifests, err := integration.Detect(context.Background(), \"./testdata\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    if len(manifests) != 1 {\n        t.Errorf(\"expected 1 manifest, got %d\", len(manifests))\n    }\n}\n</code></pre>"},{"location":"plugin-development/#integration-testing","title":"Integration Testing","text":"<pre><code># Build and test\ngo build -buildmode=plugin -o myintegration.so .\ncp myintegration.so ~/.config/uptool/plugins/\nuptool scan --only=myintegration\n</code></pre>"},{"location":"plugin-development/#best-practices","title":"Best Practices","text":"<ol> <li>Version compatibility: Match uptool's Go version and dependencies</li> <li>Error handling: Return descriptive errors with context</li> <li>Logging: Use structured logging, avoid print statements</li> <li>Context: Respect context cancellation</li> <li>Resource cleanup: Close files, network connections</li> <li>Testing: &gt;80% coverage target</li> <li>Documentation: Add README with usage examples</li> </ol>"},{"location":"plugin-development/#example-plugin","title":"Example Plugin","text":"<p>See <code>examples/plugins/python/</code> for a complete example:</p> <ul> <li>Detects <code>pyproject.toml</code>, <code>requirements.txt</code>, <code>Pipfile</code></li> <li>Queries PyPI registry</li> <li>Updates dependency versions</li> </ul>"},{"location":"plugin-development/#distribution","title":"Distribution","text":""},{"location":"plugin-development/#github-release","title":"GitHub Release","text":"<pre><code># .goreleaser.yml\nbuilds:\n  - id: plugin\n    main: .\n    flags:\n      - -buildmode=plugin\n    goos: [linux, darwin]\n    goarch: [amd64, arm64]\n</code></pre>"},{"location":"plugin-development/#installation-script","title":"Installation Script","text":"<pre><code>#!/bin/bash\nPLUGIN_DIR=\"${HOME}/.config/uptool/plugins\"\nmkdir -p \"$PLUGIN_DIR\"\ncurl -LO \"https://github.com/you/plugin/releases/latest/download/plugin-$(uname -s)-$(uname -m).so\"\nmv plugin-*.so \"$PLUGIN_DIR/myplugin.so\"\n</code></pre>"},{"location":"plugin-development/#limitations","title":"Limitations","text":"<ul> <li>Plugin must be compiled with same Go version as uptool</li> <li>Shared libraries are OS/arch specific</li> <li>Cannot modify core engine behavior</li> <li>Plugin crashes may crash uptool</li> </ul>"},{"location":"plugin-development/#see-also","title":"See Also","text":"<ul> <li>Integration Examples - Built-in integration code</li> <li>API Reference - Engine API documentation</li> <li>CONTRIBUTING.md - Development guidelines</li> </ul>"},{"location":"policy/","title":"Organization Policy","text":"<p>uptool supports organization-wide policies to enforce governance, security, and compliance requirements for dependency updates. These policies ensure that all dependency updates meet your organization's standards before being merged.</p>"},{"location":"policy/#overview","title":"Overview","text":"<p>Organization policies enable you to:</p> <ul> <li>Require signoffs from team members before merging updates</li> <li>Verify artifact signatures using Cosign to ensure supply chain security</li> <li>Auto-merge pull requests when all configured guards pass</li> <li>Enforce custom checks via extensible guard plugins</li> </ul>"},{"location":"policy/#configuration","title":"Configuration","text":"<p>Configure organization policies in your <code>uptool.yaml</code>:</p> <pre><code>version: 1\n\norg_policy:\n  # Require signoff from specific GitHub users\n  require_signoff_from:\n    - \"@security-team\"\n    - \"@platform-leads\"\n\n  # Verify artifact signatures with Cosign\n  signing:\n    cosign_verify: true\n\n  # Auto-merge configuration\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"             # All CI checks must pass\n      - \"codeowners-approve\"   # CODEOWNERS must approve\n      - \"security-scan\"        # Security scans must pass\n      - \"custom-guard\"         # Your custom guard plugin\n</code></pre>"},{"location":"policy/#policy-components","title":"Policy Components","text":""},{"location":"policy/#require-signoff","title":"Require Signoff","text":"<p>Require approval from specific GitHub users or teams before merging dependency updates:</p> <pre><code>org_policy:\n  require_signoff_from:\n    - \"@security-team\"\n    - \"@alice\"\n    - \"@bob\"\n</code></pre> <p>How it works: The <code>check-policy</code> command verifies that the specified users have approved the PR.</p>"},{"location":"policy/#signing-verification","title":"Signing Verification","text":"<p>Verify artifact signatures to ensure integrity and authenticity:</p> <pre><code>org_policy:\n  signing:\n    cosign_verify: true\n</code></pre> <p>How it works: Uses Cosign to verify artifact signatures. Requires cosign binary in PATH.</p>"},{"location":"policy/#auto-merge","title":"Auto-Merge","text":"<p>Automatically merge pull requests when all guards pass:</p> <pre><code>org_policy:\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"\n      - \"codeowners-approve\"\n      - \"security-scan\"\n</code></pre> <p>How it works: The <code>check-policy</code> command evaluates all configured guards. If all guards pass, the PR is marked as ready for auto-merge.</p>"},{"location":"policy/#built-in-guards","title":"Built-in Guards","text":"<p>uptool provides three built-in guards out-of-the-box:</p>"},{"location":"policy/#ci-green","title":"ci-green","text":"<p>Purpose: Ensure all CI checks pass before merging.</p> <p>Checks:</p> <ul> <li>All CI workflow runs are in <code>SUCCESS</code> or <code>SKIPPED</code> state</li> <li>No failed or pending checks</li> </ul> <p>Usage:</p> <pre><code>org_policy:\n  auto_merge:\n    guards:\n      - \"ci-green\"\n</code></pre> <p>Environment variables required:</p> <ul> <li><code>GITHUB_TOKEN</code> - GitHub API token</li> <li><code>GITHUB_REPOSITORY</code> - Repository in <code>owner/repo</code> format</li> <li><code>GITHUB_PR_NUMBER</code> - Pull request number</li> </ul>"},{"location":"policy/#codeowners-approve","title":"codeowners-approve","text":"<p>Purpose: Require approval from repository CODEOWNERS.</p> <p>Checks:</p> <ul> <li>At least one CODEOWNER has approved the PR</li> <li>Uses GitHub's PR review API</li> </ul> <p>Usage:</p> <pre><code>org_policy:\n  auto_merge:\n    guards:\n      - \"codeowners-approve\"\n</code></pre> <p>Environment variables required:</p> <ul> <li><code>GITHUB_TOKEN</code> - GitHub API token</li> <li><code>GITHUB_REPOSITORY</code> - Repository in <code>owner/repo</code> format</li> <li><code>GITHUB_PR_NUMBER</code> - Pull request number</li> </ul>"},{"location":"policy/#security-scan","title":"security-scan","text":"<p>Purpose: Verify that security scans (CodeQL, Trivy, SAST) pass.</p> <p>Checks:</p> <ul> <li>CodeQL analysis completed without critical/high findings</li> <li>Container image scans pass (if applicable)</li> <li>SAST tools report no security vulnerabilities</li> </ul> <p>Usage:</p> <pre><code>org_policy:\n  auto_merge:\n    guards:\n      - \"security-scan\"\n</code></pre> <p>Environment variables required:</p> <ul> <li><code>GITHUB_TOKEN</code> - GitHub API token</li> <li><code>GITHUB_REPOSITORY</code> - Repository in <code>owner/repo</code> format</li> <li><code>GITHUB_PR_NUMBER</code> - Pull request number</li> </ul>"},{"location":"policy/#custom-guard-plugins","title":"Custom Guard Plugins","text":"<p>uptool's guard system is fully extensible via Go plugins. You can create custom guards to implement organization-specific workflows.</p> <p>See Guard Plugins Documentation for complete details on creating custom guards.</p>"},{"location":"policy/#quick-example","title":"Quick Example","text":"<pre><code>package custom\n\nimport (\n    \"context\"\n    \"github.com/santosr2/uptool/internal/policy/guards\"\n)\n\ntype MyCustomGuard struct{}\n\nfunc init() {\n    guards.Register(&amp;MyCustomGuard{})\n}\n\nfunc (g *MyCustomGuard) Name() string {\n    return \"my-custom-guard\"\n}\n\nfunc (g *MyCustomGuard) Description() string {\n    return \"Checks my custom approval workflow\"\n}\n\nfunc (g *MyCustomGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // Your custom logic here\n    return true, nil\n}\n</code></pre> <p>Then reference it in your configuration:</p> <pre><code>org_policy:\n  auto_merge:\n    guards:\n      - \"my-custom-guard\"\n</code></pre>"},{"location":"policy/#running-policy-checks","title":"Running Policy Checks","text":"<p>Use the <code>uptool check-policy</code> command to validate policies:</p> <pre><code># Check all policies for a PR\nuptool check-policy\n\n# Set environment variables for GitHub context\nexport GITHUB_TOKEN=\"ghp_your_token\"\nexport GITHUB_REPOSITORY=\"owner/repo\"\nexport GITHUB_PR_NUMBER=\"123\"\n\nuptool check-policy\n</code></pre>"},{"location":"policy/#github-action-integration","title":"GitHub Action Integration","text":"<p>Run policy checks in CI/CD workflows:</p> <pre><code>name: Policy Check\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\njobs:\n  policy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Check policy\n        uses: santosr2/uptool@v0\n        with:\n          command: check-policy\n          token: ${{ secrets.GITHUB_TOKEN }}\n        env:\n          GITHUB_REPOSITORY: ${{ github.repository }}\n          GITHUB_PR_NUMBER: ${{ github.event.pull_request.number }}\n</code></pre>"},{"location":"policy/#output-format","title":"Output Format","text":"<p>The <code>check-policy</code> command outputs a detailed report:</p> <pre><code>\u2713 Signoff requirement: PASSED\n  Required: @security-team, @alice\n  Found: @alice, @bob\n\n\u2713 Artifact signing: PASSED\n  Verified signature with cosign.pub\n\n\u2713 Auto-merge guards: PASSED\n  \u2713 ci-green: All CI checks passing\n  \u2713 codeowners-approve: Approved by @alice (CODEOWNER)\n  \u2713 security-scan: No security issues found\n\nAll policy checks passed.\n</code></pre>"},{"location":"policy/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - All policy checks passed</li> <li><code>1</code> - One or more policy checks failed</li> </ul>"},{"location":"policy/#best-practices","title":"Best Practices","text":""},{"location":"policy/#1-start-simple","title":"1. Start Simple","text":"<p>Begin with basic guards and add complexity as needed:</p> <pre><code># Start with just CI checks\norg_policy:\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"\n</code></pre>"},{"location":"policy/#2-layer-security","title":"2. Layer Security","text":"<p>Combine multiple guards for defense-in-depth:</p> <pre><code>org_policy:\n  auto_merge:\n    guards:\n      - \"ci-green\"           # Tests pass\n      - \"security-scan\"      # No vulnerabilities\n      - \"codeowners-approve\" # Human review\n</code></pre>"},{"location":"policy/#3-test-guards-locally","title":"3. Test Guards Locally","text":"<p>Before deploying to CI/CD, test guards locally:</p> <pre><code>export GITHUB_TOKEN=\"ghp_your_token\"\nexport GITHUB_REPOSITORY=\"santosr2/uptool\"\nexport GITHUB_PR_NUMBER=\"42\"\n\nuptool check-policy --verbose\n</code></pre>"},{"location":"policy/#4-document-custom-guards","title":"4. Document Custom Guards","text":"<p>If you create custom guards, document their behavior:</p> <pre><code># uptool.yaml\norg_policy:\n  auto_merge:\n    guards:\n      - \"ci-green\"\n      - \"slack-approval\"  # Custom guard (see examples/guards/)\n</code></pre>"},{"location":"policy/#5-monitor-guard-performance","title":"5. Monitor Guard Performance","text":"<p>Track how often guards fail to identify bottlenecks:</p> <pre><code># Check policy with verbose output\nuptool check-policy --verbose\n\n# Review which guards most frequently block merges\n</code></pre>"},{"location":"policy/#troubleshooting","title":"Troubleshooting","text":""},{"location":"policy/#guard-not-found","title":"Guard Not Found","text":"<p>Error: <code>unknown guard: my-custom-guard</code></p> <p>Solution: Ensure your guard package is imported and registered via <code>init()</code>. See Guard Plugins for details.</p>"},{"location":"policy/#guard-always-fails","title":"Guard Always Fails","text":"<p>Symptom: A guard consistently returns <code>false</code></p> <p>Debug steps:</p> <ol> <li>Run with <code>--verbose</code> flag to see detailed error messages</li> <li>Check environment variables are set correctly</li> <li>Verify API tokens have required permissions</li> <li>Review guard implementation for logic errors</li> </ol>"},{"location":"policy/#github-api-rate-limiting","title":"GitHub API Rate Limiting","text":"<p>Error: <code>rate limit exceeded</code> when checking guards</p> <p>Solutions:</p> <ul> <li>Use a GitHub token with higher rate limits</li> <li>Cache guard results to reduce API calls</li> <li>Increase delays between checks</li> </ul>"},{"location":"policy/#permission-denied","title":"Permission Denied","text":"<p>Error: <code>403 Forbidden</code> when accessing GitHub API</p> <p>Solutions:</p> <ul> <li>Verify <code>GITHUB_TOKEN</code> has correct scopes</li> <li>For organization repositories, token needs <code>repo</code> scope</li> <li>For public repositories, <code>public_repo</code> scope is sufficient</li> </ul>"},{"location":"policy/#examples","title":"Examples","text":"<p>See examples/uptool.yaml for complete configuration examples.</p> <p>See examples/guards/ for custom guard implementations.</p>"},{"location":"policy/#related-documentation","title":"Related Documentation","text":"<ul> <li>Guard Plugins - Creating custom guard plugins</li> <li>Configuration - Full configuration reference</li> <li>GitHub Action Usage - Using uptool in CI/CD</li> <li>Architecture - System architecture overview</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get up and running with uptool in 5 minutes!</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have uptool installed. If not, see the Installation Guide.</p> <pre><code>uptool version\n</code></pre>"},{"location":"quickstart/#step-1-initialize-your-project","title":"Step 1: Initialize Your Project","text":"<p>Navigate to your project directory:</p> <pre><code>cd your-project\n</code></pre>"},{"location":"quickstart/#step-2-scan-for-dependencies","title":"Step 2: Scan for Dependencies","text":"<p>Scan your project to detect supported manifest files and check for outdated dependencies:</p> <pre><code>uptool scan\n</code></pre> <p>Example output:</p> <pre><code>Found 5 manifest files:\n  \u2705 package.json (npm)\n  \u2705 Chart.yaml (helm)\n  \u2705 main.tf (terraform)\n  \u2705 .pre-commit-config.yaml (precommit)\n  \u2705 mise.toml (mise)\n\nScanning for updates...\n</code></pre>"},{"location":"quickstart/#step-3-plan-updates","title":"Step 3: Plan Updates","text":"<p>Preview what would be updated without making changes:</p> <pre><code>uptool plan\n</code></pre> <p>Example output:</p> <pre><code>Updates available:\n\nnpm (package.json):\n  - react: 18.2.0 \u2192 18.3.1\n  - typescript: 5.0.0 \u2192 5.4.5\n\nterraform (main.tf):\n  - aws: 5.0.0 \u2192 5.70.0\n\nprecommit (.pre-commit-config.yaml):\n  - golangci-lint: v1.63.4 \u2192 v2.6.2\n</code></pre> <p>Dry Run</p> <p>The <code>plan</code> command never modifies files. It only shows what would change.</p>"},{"location":"quickstart/#step-4-apply-updates","title":"Step 4: Apply Updates","text":"<p>Apply the updates with a diff preview:</p> <pre><code>uptool update --diff\n</code></pre> <p>This will:</p> <ol> <li>Update manifest files</li> <li>Show a diff of changes</li> <li>Preserve formatting and comments</li> <li>Validate the changes</li> </ol> <p>Example diff output:</p> <pre><code>--- package.json\n+++ package.json\n@@ -5,7 +5,7 @@\n   \"dependencies\": {\n-    \"react\": \"^18.2.0\",\n+    \"react\": \"^18.3.1\",\n-    \"typescript\": \"^5.0.0\"\n+    \"typescript\": \"^5.4.5\"\n   }\n }\n</code></pre>"},{"location":"quickstart/#step-5-review-and-commit","title":"Step 5: Review and Commit","text":"<p>After uptool applies the updates, review the changes:</p> <pre><code>git diff\n</code></pre> <p>Commit the changes:</p> <pre><code>git add .\ngit commit --signoff -m \"chore(deps): update dependencies via uptool\"\ngit push\n</code></pre>"},{"location":"quickstart/#advanced-usage","title":"Advanced Usage","text":""},{"location":"quickstart/#filter-by-integration","title":"Filter by Integration","text":"<p>Update only specific integrations:</p> <pre><code># Update only npm packages\nuptool update --only npm\n\n# Update everything except terraform\nuptool update --exclude terraform\n</code></pre>"},{"location":"quickstart/#dry-run-mode","title":"Dry Run Mode","text":"<p>Preview changes without applying:</p> <pre><code>uptool update --dry-run\n</code></pre>"},{"location":"quickstart/#quiet-mode","title":"Quiet Mode","text":"<p>Suppress informational output (errors only):</p> <pre><code>uptool update --quiet\n</code></pre>"},{"location":"quickstart/#verbose-mode","title":"Verbose Mode","text":"<p>Get detailed debug output:</p> <pre><code>uptool scan --verbose\n</code></pre>"},{"location":"quickstart/#configuration-file","title":"Configuration File","text":"<p>Create a <code>uptool.yaml</code> configuration file to customize behavior:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor           # none, patch, minor, major\n      allow_prerelease: false\n\n  - id: terraform\n    enabled: true\n    policy:\n      update: major\n      allow_prerelease: false\n\n  - id: helm\n    enabled: false  # Skip Helm charts\n</code></pre> <p>See the Configuration Guide for more details.</p>"},{"location":"quickstart/#using-as-a-github-action","title":"Using as a GitHub Action","text":"<p>Add uptool to your CI/CD pipeline:</p> <pre><code>name: Dependency Updates\n\non:\n  schedule:\n    - cron: '0 0 * * 1'  # Weekly on Monday\n  workflow_dispatch:\n\njobs:\n  update-dependencies:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run uptool\n        uses: santosr2/uptool@main\n        with:\n          command: update\n          create-pr: true\n</code></pre> <p>See the GitHub Action Usage Guide for more examples.</p>"},{"location":"quickstart/#example-configurations","title":"Example Configurations","text":"<p>See the examples/ directory for sample configurations: uptool.yaml, uptool-minimal.yaml, uptool-monorepo.yaml</p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Customize uptool behavior</li> <li>Integrations - Learn about supported ecosystems</li> <li>GitHub Action Usage - Automate dependency updates</li> <li>Plugin Development - Add custom integrations</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions for uptool.</p>"},{"location":"troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":"<pre><code># Run with verbose logging\nuptool scan --verbose\n\n# Check version\nuptool --version\n\n# Verify manifest files exist\nls package.json Chart.yaml mise.toml .tool-versions\n</code></pre>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#no-manifests-detected","title":"No manifests detected","text":"<p>Check: Run from correct directory, verify manifest files exist, check <code>.gitignore</code></p> <pre><code>pwd &amp;&amp; ls -la package.json Chart.yaml\nuptool scan --verbose\n</code></pre>"},{"location":"troubleshooting/#registry-query-failed","title":"Registry query failed","text":"<p>Causes: Network issues, rate limiting, authentication</p> <p>Solutions:</p> <ul> <li>Test connectivity: <code>curl -I https://registry.npmjs.org</code></li> <li>For private packages: Configure <code>.npmrc</code> (npm) or <code>helm repo add</code> (helm)</li> <li>Check rate limits: Use <code>GITHUB_TOKEN</code> env var</li> </ul>"},{"location":"troubleshooting/#manifest-parsing-failed","title":"Manifest parsing failed","text":"<p>Check: Validate syntax with <code>yamllint</code>, <code>jq</code>, or online validators</p> <pre><code>yamllint Chart.yaml\njq . package.json\n</code></pre>"},{"location":"troubleshooting/#permission-denied","title":"Permission denied","text":"<p>Solutions:</p> <pre><code># Fix binary permissions\nchmod +x /usr/local/bin/uptool\n\n# Or install to user directory\ngo install github.com/santosr2/uptool/cmd/uptool@latest\n</code></pre>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"troubleshooting/#command-not-found","title":"Command not found","text":"<p>Check PATH:</p> <pre><code>echo $PATH\nwhich uptool\n\n# Add to PATH\nexport PATH=\"$PATH:/usr/local/bin\"\n</code></pre>"},{"location":"troubleshooting/#installation-script-fails","title":"Installation script fails","text":"<p>Alternatives:</p> <pre><code># Download binary directly\ncurl -LO https://github.com/santosr2/uptool/releases/latest/download/uptool-$(uname -s)-$(uname -m)\n\n# Or build from source\ngit clone https://github.com/santosr2/uptool\ncd uptool &amp;&amp; mise run build\n</code></pre>"},{"location":"troubleshooting/#integration-specific","title":"Integration-Specific","text":""},{"location":"troubleshooting/#npm","title":"npm","text":"<p>Lockfile out of sync: Run <code>npm install</code> after uptool updates Peer dependency conflict: Check <code>npm install</code> output for warnings</p>"},{"location":"troubleshooting/#helm","title":"Helm","text":"<p>Repository not found: Add repository: <code>helm repo add &lt;name&gt; &lt;url&gt;</code> API version mismatch: Update Helm client to compatible version</p>"},{"location":"troubleshooting/#terraform","title":"Terraform","text":"<p>Provider constraint invalid: Check <code>.tf</code> syntax with <code>terraform validate</code> Provider not available: Run <code>terraform init</code> after updates</p>"},{"location":"troubleshooting/#miseasdf","title":"mise/asdf","text":"<p>Tool not installed: Run <code>mise install</code> or <code>asdf install</code> after updates</p>"},{"location":"troubleshooting/#performance","title":"Performance","text":""},{"location":"troubleshooting/#slow-scans","title":"Slow scans","text":"<ul> <li>Use <code>--only</code> flag to limit integrations</li> <li>Check network latency to registries</li> <li>Increase timeout: <code>--timeout=60s</code></li> </ul>"},{"location":"troubleshooting/#high-memory-usage","title":"High memory usage","text":"<ul> <li>Scan one integration at a time: <code>--only=npm</code></li> <li>Reduce concurrency in large monorepos</li> </ul>"},{"location":"troubleshooting/#debug-mode","title":"Debug Mode","text":""},{"location":"troubleshooting/#environment-variables","title":"Environment Variables","text":"<pre><code># Enable debug logging\nexport UPTOOL_LOG_LEVEL=debug\n\n# Increase timeout\nexport UPTOOL_TIMEOUT=60\n\n# Use GitHub token (higher rate limits)\nexport GITHUB_TOKEN=ghp_xxxx\n</code></pre>"},{"location":"troubleshooting/#verbose-output","title":"Verbose Output","text":"<pre><code># All commands support -v flag\nuptool scan -v\nuptool plan --verbose\nuptool update -v --dry-run\n</code></pre>"},{"location":"troubleshooting/#configuration-issues","title":"Configuration Issues","text":""},{"location":"troubleshooting/#config-not-loaded","title":"Config not loaded","text":"<p>Check: File must be named <code>uptool.yaml</code> (not <code>.yml</code>) in repository root</p>"},{"location":"troubleshooting/#integration-not-running","title":"Integration not running","text":"<p>Verify:</p> <ul> <li><code>enabled: true</code> in config</li> <li>No CLI overrides (<code>--exclude</code>)</li> <li>File patterns match: <code>uptool scan -v</code></li> </ul>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<ol> <li>Check logs: Run with <code>--verbose</code></li> <li>Search issues: GitHub Issues</li> <li>Ask questions: GitHub Discussions</li> <li>Report bugs: Include <code>uptool --version</code>, logs, and manifest example</li> </ol>"},{"location":"troubleshooting/#useful-information-for-bug-reports","title":"Useful Information for Bug Reports","text":"<pre><code># System info\nuptool --version\ngo version\nuname -a\n\n# Verbose output\nuptool scan --verbose &gt; debug.log 2&gt;&amp;1\n\n# Configuration\ncat uptool.yaml\n</code></pre>"},{"location":"troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Config file options</li> <li>Integration Guides - Integration-specific docs</li> <li>CLI Reference - Command usage</li> </ul>"},{"location":"versioning/","title":"Version Management","text":"<p>Automated semantic versioning via conventional commits and GitHub Actions.</p>"},{"location":"versioning/#overview","title":"Overview","text":"<ol> <li>Conventional commits determine version bumps</li> <li>GitHub Actions calculate and apply versions</li> <li><code>bump-my-version</code> updates all files</li> <li><code>internal/version/VERSION</code> is the single source of truth</li> </ol>"},{"location":"versioning/#conventional-commits","title":"Conventional Commits","text":"Type Bump Example <code>feat:</code> Minor (0.1.0 \u2192 0.2.0) <code>feat: add Python integration</code> <code>fix:</code> Patch (0.1.0 \u2192 0.1.1) <code>fix: handle empty manifests</code> <code>feat!:</code> or <code>BREAKING CHANGE:</code> Major (0.1.0 \u2192 1.0.0) <code>feat!: redesign API</code> <code>docs:</code>, <code>chore:</code>, <code>test:</code> None <code>docs: update README</code> <p>Format: <code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></p> <p>Breaking changes: Use <code>feat!:</code> or add <code>BREAKING CHANGE:</code> footer</p>"},{"location":"versioning/#local-development","title":"Local Development","text":"<pre><code># Show current version\nmise run version-show\n\n# Bump for testing only (don't commit to PRs)\nmise run version-bump-patch   # 0.1.0 \u2192 0.1.1\nmise run version-bump-minor   # 0.1.0 \u2192 0.2.0\nmise run version-bump-major   # 0.1.0 \u2192 1.0.0\n</code></pre> <p>Production releases are automated via GitHub Actions.</p>"},{"location":"versioning/#release-process","title":"Release Process","text":""},{"location":"versioning/#pre-release","title":"Pre-Release","text":"<ol> <li>Maintainer triggers pre-release workflow</li> <li>System calculates version from commits</li> <li>Approval gate (designated reviewers)</li> <li>Creates pre-release (e.g., <code>v0.2.0-rc1</code>, <code>v0.2.0-beta3</code>, <code>v0.2.0-alpha20250708</code>)</li> <li>Builds artifacts</li> </ol>"},{"location":"versioning/#stable-release","title":"Stable Release","text":"<ol> <li>Maintainer triggers promote workflow</li> <li>Extracts stable version (<code>v0.2.0-rc1</code> \u2192 <code>v0.2.0</code>)</li> <li>Approval gate (multiple reviewers)</li> <li>Promotes artifacts</li> <li>Updates CHANGELOG</li> </ol> <p>See environments.md for approval gate setup.</p>"},{"location":"versioning/#version-tags","title":"Version Tags","text":"<p>Immutable (never change):</p> <ul> <li>Stable: <code>v0.1.0</code>, <code>v0.2.0</code>, <code>v1.13.0</code></li> <li>Pre-release: <code>v0.2.0-rc1</code>, <code>v1.0.0-beta3</code>, <code>v1.13.0-alpha20250708</code></li> </ul> <p>Mutable (auto-updated for GitHub Actions):</p> <ul> <li><code>v0</code> \u2192 latest <code>v0.x.x</code> stable</li> <li><code>v0.1</code> \u2192 latest <code>v0.1.x</code> patch</li> <li><code>v0-rc</code>, <code>v0-beta</code>, <code>v0-alpha</code> \u2192 latest <code>v0.x.x</code> pre-release of each type</li> </ul> <p>Usage:</p> <pre><code># Recommended\n- uses: santosr2/uptool@v0\n\n# Pin to minor\n- uses: santosr2/uptool@v0.2\n\n# Pin to exact version\n- uses: santosr2/uptool@main\n</code></pre>"},{"location":"versioning/#files-updated-automatically","title":"Files Updated Automatically","text":"<p>When versions change, <code>bump-my-version</code> updates:</p> <ul> <li><code>internal/version/VERSION</code> - Source of truth</li> <li><code>README.md</code> - Action version examples</li> <li><code>SECURITY.md</code> - Supported versions</li> <li><code>docs/action-usage.md</code> - Usage examples</li> </ul>"},{"location":"versioning/#configuration","title":"Configuration","text":"<p>Location: <code>.bumpversion.toml</code></p> <p>Defines version format, files to update, and search/replace patterns.</p>"},{"location":"versioning/#workflows","title":"Workflows","text":"<ul> <li><code>.github/workflows/pre-release.yml</code> - Create RC/beta/alpha releases</li> <li><code>.github/workflows/promote-release.yml</code> - Promote to stable</li> <li><code>.github/workflows/patch-release.yml</code> - Security/bugfix patches</li> <li><code>.github/workflows/create-release-branch.yml</code> - Branch for patches</li> </ul>"},{"location":"versioning/#best-practices","title":"Best Practices","text":"<ol> <li>Contributors: Write conventional commits, don't bump versions manually</li> <li>Maintainers: Use workflows, never push version tags directly</li> <li>Testing: Use local bump commands, don't commit version changes</li> <li>Pre-releases: Test thoroughly before promoting to stable</li> </ol>"},{"location":"versioning/#see-also","title":"See Also","text":"<ul> <li>CONTRIBUTING.md - Conventional commit guidelines</li> <li>environments.md - Approval gate configuration</li> <li>Conventional Commits</li> <li>Semantic Versioning</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#uptool","title":"uptool","text":"<pre><code>import \"github.com/santosr2/uptool/cmd/uptool\"\n</code></pre> <p>uptool is a manifest-first dependency updater for multiple ecosystems. It scans repositories for dependency manifest files \\(package.json, Chart.yaml, .pre\\-commit\\-config.yaml, etc.\\), checks for available updates, and rewrites manifests with new versions while preserving formatting.</p>"},{"location":"api/#index","title":"Index","text":""},{"location":"api/#datasource","title":"datasource","text":"<pre><code>import \"github.com/santosr2/uptool/internal/datasource\"\n</code></pre> <p>Package datasource provides a unified interface for querying package registries. This abstraction allows multiple integrations to share the same registry client.</p>"},{"location":"api/#index_1","title":"Index","text":"<ul> <li>func List() []string</li> <li>func Register\\(ds Datasource\\)</li> <li>type Datasource</li> <li>func Get\\(name string\\) \\(Datasource, error\\)</li> <li>type DockerHubDatasource</li> <li>func NewDockerHubDatasource() *DockerHubDatasource</li> <li>func \\(d \\*DockerHubDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*DockerHubDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*DockerHubDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*DockerHubDatasource\\) Name() string</li> <li>type GitHubDatasource</li> <li>func NewGitHubDatasource() *GitHubDatasource</li> <li>func \\(d \\*GitHubDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*GitHubDatasource\\) Name() string</li> <li>type GoDatasource</li> <li>func NewGoDatasource() *GoDatasource</li> <li>func \\(d \\*GoDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*GoDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*GoDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*GoDatasource\\) Name() string</li> <li>type HelmDatasource</li> <li>func NewHelmDatasource() *HelmDatasource</li> <li>func \\(d \\*HelmDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*HelmDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*HelmDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*HelmDatasource\\) Name() string</li> <li>type NPMDatasource</li> <li>func NewNPMDatasource() *NPMDatasource</li> <li>func \\(d \\*NPMDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*NPMDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*NPMDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*NPMDatasource\\) Name() string</li> <li>type PackageInfo</li> <li>type TerraformDatasource</li> <li>func NewTerraformDatasource() *TerraformDatasource</li> <li>func \\(d \\*TerraformDatasource\\) GetLatestVersion\\(ctx context.Context, pkg string\\) \\(string, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) GetPackageInfo\\(ctx context.Context, pkg string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) GetVersions\\(ctx context.Context, pkg string\\) \\(\\[\\]string, error\\)</li> <li>func \\(d \\*TerraformDatasource\\) Name() string</li> <li>type VersionInfo</li> </ul>"},{"location":"api/#func-list","title":"func List","text":"<pre><code>func List() []string\n</code></pre> <p>List returns all registered datasource names.</p> <p></p>"},{"location":"api/#func-register","title":"func Register","text":"<pre><code>func Register(ds Datasource)\n</code></pre> <p>Register adds a datasource to the global registry.</p> <p></p>"},{"location":"api/#type-datasource","title":"type Datasource","text":"<p>Datasource represents a package registry or version source.</p> <pre><code>type Datasource interface {\n    // Name returns the datasource identifier (e.g., \"npm\", \"pypi\", \"github-releases\")\n    Name() string\n\n    // GetLatestVersion returns the latest stable version for a package.\n    GetLatestVersion(ctx context.Context, pkg string) (string, error)\n\n    // GetVersions returns all available versions for a package.\n    GetVersions(ctx context.Context, pkg string) ([]string, error)\n\n    // GetPackageInfo returns detailed information about a package.\n    GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n}\n</code></pre> <p></p>"},{"location":"api/#func-get","title":"func Get","text":"<pre><code>func Get(name string) (Datasource, error)\n</code></pre> <p>Get returns a datasource by name.</p> <p></p>"},{"location":"api/#type-dockerhubdatasource","title":"type DockerHubDatasource","text":"<p>DockerHubDatasource implements the Datasource interface for Docker Hub.</p> <pre><code>type DockerHubDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newdockerhubdatasource","title":"func NewDockerHubDatasource","text":"<pre><code>func NewDockerHubDatasource() *DockerHubDatasource\n</code></pre> <p>NewDockerHubDatasource creates a new Docker Hub datasource.</p> <p></p>"},{"location":"api/#func-dockerhubdatasource-getlatestversion","title":"func \\(\\*DockerHubDatasource\\) GetLatestVersion","text":"<pre><code>func (d *DockerHubDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Docker image.</p> <p></p>"},{"location":"api/#func-dockerhubdatasource-getpackageinfo","title":"func \\(\\*DockerHubDatasource\\) GetPackageInfo","text":"<pre><code>func (d *DockerHubDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Docker image.</p> <p></p>"},{"location":"api/#func-dockerhubdatasource-getversions","title":"func \\(\\*DockerHubDatasource\\) GetVersions","text":"<pre><code>func (d *DockerHubDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available tags for a Docker image.</p> <p></p>"},{"location":"api/#func-dockerhubdatasource-name","title":"func \\(\\*DockerHubDatasource\\) Name","text":"<pre><code>func (d *DockerHubDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-githubdatasource","title":"type GitHubDatasource","text":"<p>GitHubDatasource implements the Datasource interface for GitHub Releases.</p> <pre><code>type GitHubDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgithubdatasource","title":"func NewGitHubDatasource","text":"<pre><code>func NewGitHubDatasource() *GitHubDatasource\n</code></pre> <p>NewGitHubDatasource creates a new GitHub datasource.</p> <p></p>"},{"location":"api/#func-githubdatasource-getlatestversion","title":"func \\(\\*GitHubDatasource\\) GetLatestVersion","text":"<pre><code>func (d *GitHubDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable release for a GitHub repository.</p> <p></p>"},{"location":"api/#func-githubdatasource-getpackageinfo","title":"func \\(\\*GitHubDatasource\\) GetPackageInfo","text":"<pre><code>func (d *GitHubDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a GitHub repository's releases.</p> <p></p>"},{"location":"api/#func-githubdatasource-getversions","title":"func \\(\\*GitHubDatasource\\) GetVersions","text":"<pre><code>func (d *GitHubDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available releases for a GitHub repository.</p> <p></p>"},{"location":"api/#func-githubdatasource-name","title":"func \\(\\*GitHubDatasource\\) Name","text":"<pre><code>func (d *GitHubDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-godatasource","title":"type GoDatasource","text":"<p>GoDatasource implements the Datasource interface for the Go module proxy.</p> <pre><code>type GoDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgodatasource","title":"func NewGoDatasource","text":"<pre><code>func NewGoDatasource() *GoDatasource\n</code></pre> <p>NewGoDatasource creates a new Go module datasource.</p> <p></p>"},{"location":"api/#func-godatasource-getlatestversion","title":"func \\(\\*GoDatasource\\) GetLatestVersion","text":"<pre><code>func (d *GoDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Go module.</p> <p></p>"},{"location":"api/#func-godatasource-getpackageinfo","title":"func \\(\\*GoDatasource\\) GetPackageInfo","text":"<pre><code>func (d *GoDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Go module.</p> <p></p>"},{"location":"api/#func-godatasource-getversions","title":"func \\(\\*GoDatasource\\) GetVersions","text":"<pre><code>func (d *GoDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Go module.</p> <p></p>"},{"location":"api/#func-godatasource-name","title":"func \\(\\*GoDatasource\\) Name","text":"<pre><code>func (d *GoDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-helmdatasource","title":"type HelmDatasource","text":"<p>HelmDatasource implements the Datasource interface for Helm chart repositories.</p> <pre><code>type HelmDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newhelmdatasource","title":"func NewHelmDatasource","text":"<pre><code>func NewHelmDatasource() *HelmDatasource\n</code></pre> <p>NewHelmDatasource creates a new Helm datasource.</p> <p></p>"},{"location":"api/#func-helmdatasource-getlatestversion","title":"func \\(\\*HelmDatasource\\) GetLatestVersion","text":"<pre><code>func (d *HelmDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-getpackageinfo","title":"func \\(\\*HelmDatasource\\) GetPackageInfo","text":"<pre><code>func (d *HelmDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-getversions","title":"func \\(\\*HelmDatasource\\) GetVersions","text":"<pre><code>func (d *HelmDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Helm chart.</p> <p></p>"},{"location":"api/#func-helmdatasource-name","title":"func \\(\\*HelmDatasource\\) Name","text":"<pre><code>func (d *HelmDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-npmdatasource","title":"type NPMDatasource","text":"<p>NPMDatasource implements the Datasource interface for the npm registry.</p> <pre><code>type NPMDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newnpmdatasource","title":"func NewNPMDatasource","text":"<pre><code>func NewNPMDatasource() *NPMDatasource\n</code></pre> <p>NewNPMDatasource creates a new npm datasource.</p> <p></p>"},{"location":"api/#func-npmdatasource-getlatestversion","title":"func \\(\\*NPMDatasource\\) GetLatestVersion","text":"<pre><code>func (d *NPMDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-getpackageinfo","title":"func \\(\\*NPMDatasource\\) GetPackageInfo","text":"<pre><code>func (d *NPMDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-getversions","title":"func \\(\\*NPMDatasource\\) GetVersions","text":"<pre><code>func (d *NPMDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for an npm package.</p> <p></p>"},{"location":"api/#func-npmdatasource-name","title":"func \\(\\*NPMDatasource\\) Name","text":"<pre><code>func (d *NPMDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-packageinfo","title":"type PackageInfo","text":"<p>PackageInfo contains metadata about a package.</p> <pre><code>type PackageInfo struct {\n    Name        string\n    Description string\n    Homepage    string\n    Repository  string\n    Versions    []VersionInfo\n}\n</code></pre> <p></p>"},{"location":"api/#type-terraformdatasource","title":"type TerraformDatasource","text":"<p>TerraformDatasource implements the Datasource interface for the Terraform Registry.</p> <pre><code>type TerraformDatasource struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newterraformdatasource","title":"func NewTerraformDatasource","text":"<pre><code>func NewTerraformDatasource() *TerraformDatasource\n</code></pre> <p>NewTerraformDatasource creates a new Terraform datasource.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getlatestversion","title":"func \\(\\*TerraformDatasource\\) GetLatestVersion","text":"<pre><code>func (d *TerraformDatasource) GetLatestVersion(ctx context.Context, pkg string) (string, error)\n</code></pre> <p>GetLatestVersion returns the latest stable version for a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getpackageinfo","title":"func \\(\\*TerraformDatasource\\) GetPackageInfo","text":"<pre><code>func (d *TerraformDatasource) GetPackageInfo(ctx context.Context, pkg string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo returns detailed information about a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-getversions","title":"func \\(\\*TerraformDatasource\\) GetVersions","text":"<pre><code>func (d *TerraformDatasource) GetVersions(ctx context.Context, pkg string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Terraform module or provider.</p> <p></p>"},{"location":"api/#func-terraformdatasource-name","title":"func \\(\\*TerraformDatasource\\) Name","text":"<pre><code>func (d *TerraformDatasource) Name() string\n</code></pre> <p>Name returns the datasource identifier.</p> <p></p>"},{"location":"api/#type-versioninfo","title":"type VersionInfo","text":"<p>VersionInfo contains metadata about a specific version.</p> <pre><code>type VersionInfo struct {\n    Version      string\n    PublishedAt  string\n    IsPrerelease bool\n    Deprecated   bool\n}\n</code></pre>"},{"location":"api/#dependabot","title":"dependabot","text":"<pre><code>import \"github.com/santosr2/uptool/internal/dependabot\"\n</code></pre> <p>Package dependabot provides Dependabot configuration parsing and migration support. It enables users to migrate from Dependabot to uptool by reading existing dependabot.yml files and converting them to uptool.yaml format.</p>"},{"location":"api/#supported-features","title":"Supported Features","text":"<p>This package supports parsing all major Dependabot configuration options:</p> <ul> <li>package-ecosystem: Maps to uptool integrations</li> <li>directory/directories: Maps to match.files patterns</li> <li>schedule: Maps to cadence with extended cron support</li> <li>groups: Dependency grouping for combined PRs</li> <li>allow/ignore: Dependency filtering patterns</li> <li>versioning-strategy: Maps to update policy</li> <li>commit-message: Commit message customization</li> <li>labels, assignees, reviewers: PR metadata</li> <li>open-pull-requests-limit: Concurrent PR limits</li> <li>cooldown: Delayed update support</li> </ul>"},{"location":"api/#migration-example","title":"Migration Example","text":"<pre><code>// Load existing dependabot.yml\ndepConfig, err := dependabot.LoadConfig(\".github/dependabot.yml\")\nif err != nil {\n    log.Fatal(err)\n}\n\n// Convert to uptool.yaml format\nuptoolConfig := depConfig.ToUptoolConfig()\n\n// Save as uptool.yaml\ndata, _ := yaml.Marshal(uptoolConfig)\nos.WriteFile(\"uptool.yaml\", data, 0644)\n</code></pre>"},{"location":"api/#index_2","title":"Index","text":"<ul> <li>Variables</li> <li>func GetIntegrationID\\(ecosystem string\\) string</li> <li>type AllowRule</li> <li>type BranchName</li> <li>type CommitMessage</li> <li>type Config</li> <li>func LoadConfig\\(path string\\) \\(\\*Config, error\\)</li> <li>func \\(c \\*Config\\) MigrateToUptool() *policy.Config</li> <li>func \\(c \\*Config\\) MigrateWithReport\\(sourceFile string\\) \\(\\*policy.Config, \\*MigrationReport\\)</li> <li>func \\(c \\*Config\\) Validate() error</li> <li>type Cooldown</li> <li>type Group</li> <li>type IgnoreRule</li> <li>type MigrationReport</li> <li>type MultiEcosystemGroup</li> <li>type Registry</li> <li>type Schedule</li> <li>type UpdateConfig</li> <li>func \\(u \\*UpdateConfig\\) GetDirectories() []string</li> <li>func \\(u \\*UpdateConfig\\) GetFilePatterns() []string</li> </ul>"},{"location":"api/#variables","title":"Variables","text":"<p>EcosystemToIntegration maps Dependabot ecosystem names to uptool integration IDs.</p> <pre><code>var EcosystemToIntegration = map[string]string{\n\n    \"gomod\":          \"gomod\",\n    \"npm\":            \"npm\",\n    \"docker\":         \"docker\",\n    \"docker-compose\": \"docker\",\n    \"helm\":           \"helm\",\n    \"terraform\":      \"terraform\",\n    \"pip\":            \"pip\",\n    \"bundler\":        \"bundler\",\n    \"cargo\":          \"cargo\",\n    \"composer\":       \"composer\",\n    \"maven\":          \"maven\",\n    \"gradle\":         \"gradle\",\n    \"nuget\":          \"nuget\",\n    \"mix\":            \"hex\",\n    \"pub\":            \"pub\",\n    \"swift\":          \"swift\",\n    \"devcontainers\":  \"devcontainers\",\n    \"elm\":            \"elm\",\n    \"bun\":            \"bun\",\n    \"vcpkg\":          \"vcpkg\",\n    \"uv\":             \"uv\",\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-getintegrationid","title":"func GetIntegrationID","text":"<pre><code>func GetIntegrationID(ecosystem string) string\n</code></pre> <p>GetIntegrationID converts a Dependabot package-ecosystem to an uptool integration ID.</p> <p></p>"},{"location":"api/#type-allowrule","title":"type AllowRule","text":"<p>AllowRule specifies which dependencies to include.</p> <pre><code>type AllowRule struct {\n    // DependencyName matches dependencies by name (supports * wildcard)\n    DependencyName string `yaml:\"dependency-name,omitempty\"`\n\n    // DependencyType filters by dependency type\n    // Valid values: direct, indirect, all, production, development\n    DependencyType string `yaml:\"dependency-type,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-branchname","title":"type BranchName","text":"<p>BranchName customizes PR branch naming.</p> <pre><code>type BranchName struct {\n    // Separator replaces \"/\" in branch names\n    // Valid values: \"-\", \"_\", \"/\"\n    Separator string `yaml:\"separator,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-commitmessage","title":"type CommitMessage","text":"<p>CommitMessage customizes the commit message format.</p> <pre><code>type CommitMessage struct {\n    // Prefix is prepended to commit messages (max 50 chars)\n    Prefix string `yaml:\"prefix,omitempty\"`\n\n    // PrefixDevelopment is used for dev dependency updates\n    PrefixDevelopment string `yaml:\"prefix-development,omitempty\"`\n\n    // Include adds scope to commit messages\n    // Valid values: scope (adds deps or deps-dev)\n    Include string `yaml:\"include,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-config","title":"type Config","text":"<p>Config represents a complete dependabot.yml configuration file. Reference: https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file</p> <pre><code>type Config struct {\n    Registries           map[string]Registry            `yaml:\"registries,omitempty\"`\n    MultiEcosystemGroups map[string]MultiEcosystemGroup `yaml:\"multi-ecosystem-groups,omitempty\"`\n    Updates              []UpdateConfig                 `yaml:\"updates\"`\n    Version              int                            `yaml:\"version\"`\n    EnableBetaEcosystems bool                           `yaml:\"enable-beta-ecosystems,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-loadconfig","title":"func LoadConfig","text":"<pre><code>func LoadConfig(path string) (*Config, error)\n</code></pre> <p>LoadConfig reads and parses a dependabot.yml file.</p> <p></p>"},{"location":"api/#func-config-migratetouptool","title":"func \\(\\*Config\\) MigrateToUptool","text":"<pre><code>func (c *Config) MigrateToUptool() *policy.Config\n</code></pre> <p>MigrateToUptool converts a Dependabot configuration to an uptool configuration. This enables seamless migration from Dependabot to uptool.</p> <p></p>"},{"location":"api/#func-config-migratewithreport","title":"func \\(\\*Config\\) MigrateWithReport","text":"<pre><code>func (c *Config) MigrateWithReport(sourceFile string) (*policy.Config, *MigrationReport)\n</code></pre> <p>MigrateWithReport converts a Dependabot config and returns a detailed report.</p> <p></p>"},{"location":"api/#func-config-validate","title":"func \\(\\*Config\\) Validate","text":"<pre><code>func (c *Config) Validate() error\n</code></pre> <p>Validate checks that the configuration is valid.</p> <p></p>"},{"location":"api/#type-cooldown","title":"type Cooldown","text":"<p>Cooldown defines delayed update settings.</p> <pre><code>type Cooldown struct {\n    Include         []string `yaml:\"include,omitempty\"`\n    Exclude         []string `yaml:\"exclude,omitempty\"`\n    DefaultDays     int      `yaml:\"default-days,omitempty\"`\n    SemverMajorDays int      `yaml:\"semver-major-days,omitempty\"`\n    SemverMinorDays int      `yaml:\"semver-minor-days,omitempty\"`\n    SemverPatchDays int      `yaml:\"semver-patch-days,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-group","title":"type Group","text":"<p>Group defines a dependency grouping rule.</p> <pre><code>type Group struct {\n    // AppliesTo specifies when this group applies\n    // Valid values: version-updates, security-updates\n    AppliesTo string `yaml:\"applies-to,omitempty\"`\n\n    // DependencyType filters dependencies\n    // Valid values: production, development\n    DependencyType string `yaml:\"dependency-type,omitempty\"`\n\n    // Patterns includes dependencies matching these patterns (supports * wildcard)\n    Patterns []string `yaml:\"patterns,omitempty\"`\n\n    // ExcludePatterns excludes dependencies matching these patterns\n    ExcludePatterns []string `yaml:\"exclude-patterns,omitempty\"`\n\n    // UpdateTypes limits to specific update types\n    // Valid values: major, minor, patch\n    UpdateTypes []string `yaml:\"update-types,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-ignorerule","title":"type IgnoreRule","text":"<p>IgnoreRule specifies which dependencies or versions to exclude.</p> <pre><code>type IgnoreRule struct {\n    // DependencyName matches dependencies by name (supports * wildcard)\n    DependencyName string `yaml:\"dependency-name,omitempty\"`\n\n    // Versions specifies version ranges to ignore (package manager syntax)\n    Versions []string `yaml:\"versions,omitempty\"`\n\n    // UpdateTypes specifies update types to ignore\n    // Valid values: version-update:semver-major, version-update:semver-minor, version-update:semver-patch\n    UpdateTypes []string `yaml:\"update-types,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-migrationreport","title":"type MigrationReport","text":"<p>MigrationReport provides information about the migration process.</p> <pre><code>type MigrationReport struct {\n    // SourceFile is the path to the source dependabot.yml\n    SourceFile string\n\n    // EcosystemsMigrated lists the ecosystems that were converted\n    EcosystemsMigrated []string\n\n    // UnsupportedFeatures lists features that couldn't be fully migrated\n    UnsupportedFeatures []string\n\n    // Warnings contains any warnings encountered during migration\n    Warnings []string\n\n    // IntegrationsCreated is the number of integration configs created\n    IntegrationsCreated int\n}\n</code></pre> <p></p>"},{"location":"api/#type-multiecosystemgroup","title":"type MultiEcosystemGroup","text":"<p>MultiEcosystemGroup defines a group spanning multiple ecosystems.</p> <pre><code>type MultiEcosystemGroup struct {\n    // Schedule for this multi-ecosystem group\n    Schedule Schedule `yaml:\"schedule,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-registry","title":"type Registry","text":"<p>Registry defines a private package registry configuration.</p> <pre><code>type Registry struct {\n    // Type is the registry type\n    // Valid values: docker-registry, npm-registry, maven-repository, nuget-feed,\n    // python-index, rubygems-server, hex-repository, git-repository\n    Type string `yaml:\"type\"`\n\n    // URL is the registry endpoint\n    URL string `yaml:\"url,omitempty\"`\n\n    // Username for authentication\n    Username string `yaml:\"username,omitempty\"`\n\n    // Password for authentication\n    Password string `yaml:\"password,omitempty\"`\n\n    // Token for authentication (alternative to username/password)\n    Token string `yaml:\"token,omitempty\"`\n\n    // Key for some registry types\n    Key string `yaml:\"key,omitempty\"`\n\n    // ReplacesBase indicates if this replaces the default registry\n    ReplacesBase bool `yaml:\"replaces-base,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-schedule","title":"type Schedule","text":"<p>Schedule defines when Dependabot checks for updates.</p> <pre><code>type Schedule struct {\n    // Interval is the update frequency (required)\n    // Valid values: daily, weekly, monthly, quarterly, semiannually, yearly, cron\n    Interval string `yaml:\"interval\"`\n\n    // Day specifies the day for weekly updates\n    // Valid values: monday, tuesday, wednesday, thursday, friday, saturday, sunday\n    Day string `yaml:\"day,omitempty\"`\n\n    // Time specifies the time for updates in HH:MM format (UTC default)\n    Time string `yaml:\"time,omitempty\"`\n\n    // Timezone is the IANA timezone for schedule (default: UTC)\n    Timezone string `yaml:\"timezone,omitempty\"`\n\n    // Cronjob is a cron expression for \"cron\" interval type\n    Cronjob string `yaml:\"cronjob,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updateconfig","title":"type UpdateConfig","text":"<p>UpdateConfig defines configuration for a specific package ecosystem.</p> <pre><code>type UpdateConfig struct {\n    Registries                    interface{}      `yaml:\"registries,omitempty\"`\n    CommitMessage                 *CommitMessage   `yaml:\"commit-message,omitempty\"`\n    Cooldown                      *Cooldown        `yaml:\"cooldown,omitempty\"`\n    Groups                        map[string]Group `yaml:\"groups,omitempty\"`\n    PullRequestBranchName         *BranchName      `yaml:\"pull-request-branch-name,omitempty\"`\n    Schedule                      Schedule         `yaml:\"schedule\"`\n    MultiEcosystemGroup           string           `yaml:\"multi-ecosystem-group,omitempty\"`\n    PackageEcosystem              string           `yaml:\"package-ecosystem\"`\n    VersioningStrategy            string           `yaml:\"versioning-strategy,omitempty\"`\n    InsecureExternalCodeExecution string           `yaml:\"insecure-external-code-execution,omitempty\"`\n    TargetBranch                  string           `yaml:\"target-branch,omitempty\"`\n    Directory                     string           `yaml:\"directory,omitempty\"`\n    RebaseStrategy                string           `yaml:\"rebase-strategy,omitempty\"`\n    Ignore                        []IgnoreRule     `yaml:\"ignore,omitempty\"`\n    Reviewers                     []string         `yaml:\"reviewers,omitempty\"`\n    Assignees                     []string         `yaml:\"assignees,omitempty\"`\n    Labels                        []string         `yaml:\"labels,omitempty\"`\n    Allow                         []AllowRule      `yaml:\"allow,omitempty\"`\n    Directories                   []string         `yaml:\"directories,omitempty\"`\n    ExcludePaths                  []string         `yaml:\"exclude-paths,omitempty\"`\n    Milestone                     int              `yaml:\"milestone,omitempty\"`\n    OpenPullRequestsLimit         int              `yaml:\"open-pull-requests-limit,omitempty\"`\n    Vendor                        bool             `yaml:\"vendor,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-updateconfig-getdirectories","title":"func \\(\\*UpdateConfig\\) GetDirectories","text":"<pre><code>func (u *UpdateConfig) GetDirectories() []string\n</code></pre> <p>GetDirectories returns all directories for this update config.</p> <p></p>"},{"location":"api/#func-updateconfig-getfilepatterns","title":"func \\(\\*UpdateConfig\\) GetFilePatterns","text":"<pre><code>func (u *UpdateConfig) GetFilePatterns() []string\n</code></pre> <p>GetFilePatterns converts directory paths to glob patterns for uptool.</p>"},{"location":"api/#engine","title":"engine","text":"<pre><code>import \"github.com/santosr2/uptool/internal/engine\"\n</code></pre> <p>Package engine provides the core orchestration layer for uptool. It manages integration registration, manifest scanning, update planning, and update application. The Engine coordinates concurrent operations across multiple integrations while handling errors and logging.</p> <p>Package engine provides the core orchestration layer for uptool's dependency scanning and updating. It defines the fundamental types and interfaces used across all integrations, including Manifest, Dependency, UpdatePlan, and the Integration interface.</p>"},{"location":"api/#index_3","title":"Index","text":"<ul> <li>type ApplyResult</li> <li>type CLIFlags</li> <li>type CommitInfo</li> <li>type CommitMessageConfig</li> <li>type CooldownConfig</li> <li>type Dependency</li> <li>type DependencyGroup</li> <li>type DependencyRule</li> <li>type Engine</li> <li>func NewEngine\\(logger \\*slog.Logger\\) *Engine</li> <li>func \\(e \\*Engine\\) GetIntegration\\(name string\\) \\(Integration, bool\\)</li> <li>func \\(e \\*Engine\\) GetScheduleChecker\\(integrationName string\\) \\(\\*ScheduleChecker, error\\)</li> <li>func \\(e \\*Engine\\) GetUpdateFilter\\(integrationName string\\) *UpdateFilter</li> <li>func \\(e \\*Engine\\) ListIntegrations() []string</li> <li>func \\(e \\*Engine\\) Plan\\(ctx context.Context, manifests \\[\\]\\*Manifest\\) \\(\\*PlanResult, error\\)</li> <li>func \\(e \\*Engine\\) PlanWithOptions\\(ctx context.Context, manifests \\[\\]\\*Manifest, opts \\*PlanOptions\\) \\(\\*PlanResult, error\\)</li> <li>func \\(e \\*Engine\\) Register\\(integration Integration\\)</li> <li>func \\(e \\*Engine\\) Scan\\(ctx context.Context, repoRoot string, only, exclude \\[\\]string\\) \\(\\*ScanResult, error\\)</li> <li>func \\(e \\*Engine\\) SetCLIFlags\\(flags \\*CLIFlags\\)</li> <li>func \\(e \\*Engine\\) SetMatchConfigs\\(configs map\\[string\\]\\*MatchConfig\\)</li> <li>func \\(e \\*Engine\\) SetPolicies\\(policies map\\[string\\]IntegrationPolicy\\)</li> <li>func \\(e \\*Engine\\) Update\\(ctx context.Context, plans \\[\\]\\*UpdatePlan, dryRun bool\\) \\(\\*UpdateResult, error\\)</li> <li>type IgnoreRule</li> <li>type Impact</li> <li>type Integration</li> <li>type IntegrationPolicy</li> <li>type Manifest</li> <li>type MatchConfig</li> <li>type PlanContext</li> <li>func NewPlanContext() *PlanContext</li> <li>func \\(pc \\*PlanContext\\) EffectiveAllowPrerelease() bool</li> <li>func \\(pc \\*PlanContext\\) EffectiveUpdateLevel() string</li> <li>func \\(pc \\*PlanContext\\) GetPolicySource() PolicySource</li> <li>func \\(pc \\*PlanContext\\) ShouldRespectConstraints() bool</li> <li>func \\(pc \\*PlanContext\\) WithCLIFlags\\(flags \\*CLIFlags\\) *PlanContext</li> <li>func \\(pc \\*PlanContext\\) WithPolicy\\(p \\*IntegrationPolicy\\) *PlanContext</li> <li>type PlanOptions</li> <li>type PlanResult</li> <li>type PolicySource</li> <li>type ScanResult</li> <li>type Schedule</li> <li>type ScheduleChecker</li> <li>func NewScheduleChecker\\(schedule \\*Schedule\\) \\(\\*ScheduleChecker, error\\)</li> <li>func \\(sc \\*ScheduleChecker\\) GetNextRunTime\\(from time.Time\\) time.Time</li> <li>func \\(sc \\*ScheduleChecker\\) GetScheduleDescription() string</li> <li>func \\(sc \\*ScheduleChecker\\) ShouldRun\\(now time.Time\\) bool</li> <li>type Update</li> <li>type UpdateFilter</li> <li>func NewUpdateFilter\\(policy \\*IntegrationPolicy\\) *UpdateFilter</li> <li>func \\(f \\*UpdateFilter\\) ApplyVersioningStrategy\\(update \\*Update, currentConstraint string\\) \\(string, bool\\)</li> <li>func \\(f \\*UpdateFilter\\) FilterUpdates\\(updates \\[\\]Update, releaseTimestamps map\\[string\\]time.Time\\) \\(\\[\\]Update, map\\[string\\]string\\)</li> <li>func \\(f \\*UpdateFilter\\) FormatCommitMessage\\(updates \\[\\]Update, manifestPath string\\) string</li> <li>func \\(f \\*UpdateFilter\\) GetAssignees() []string</li> <li>func \\(f \\*UpdateFilter\\) GetCooldownDays\\(impact string\\) int</li> <li>func \\(f \\*UpdateFilter\\) GetLabels() []string</li> <li>func \\(f \\*UpdateFilter\\) GetOpenPullRequestsLimit() int</li> <li>func \\(f \\*UpdateFilter\\) GetReviewers() []string</li> <li>func \\(f \\*UpdateFilter\\) GroupUpdates\\(updates \\[\\]Update\\) \\(map\\[string\\]\\[\\]Update, \\[\\]Update\\)</li> <li>func \\(f \\*UpdateFilter\\) ShouldUpdateManifest() bool</li> <li>type UpdateInfo</li> <li>type UpdatePlan</li> <li>type UpdateResult</li> </ul>"},{"location":"api/#type-applyresult","title":"type ApplyResult","text":"<p>ApplyResult contains the outcome of applying updates.</p> <pre><code>type ApplyResult struct {\n    Manifest     *Manifest `json:\"manifest\"`\n    ManifestDiff string    `json:\"manifest_diff,omitempty\"`\n    LockfileDiff string    `json:\"lockfile_diff,omitempty\"`\n    Errors       []string  `json:\"errors,omitempty\"`\n    Applied      int       `json:\"applied\"`\n    Failed       int       `json:\"failed\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-cliflags","title":"type CLIFlags","text":"<p>CLIFlags represents command-line flag overrides for update behavior.</p> <pre><code>type CLIFlags struct {\n    AllowPrerelease *bool\n    UpdateLevel     string\n}\n</code></pre> <p></p>"},{"location":"api/#type-commitinfo","title":"type CommitInfo","text":"<p>CommitInfo represents a single commit between versions.</p> <pre><code>type CommitInfo struct {\n    SHA     string `json:\"sha\"`\n    Message string `json:\"message\"`\n    Author  string `json:\"author,omitempty\"`\n    URL     string `json:\"url,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-commitmessageconfig","title":"type CommitMessageConfig","text":"<p>CommitMessageConfig customizes the commit message format.</p> <pre><code>type CommitMessageConfig struct {\n    // Prefix is prepended to commit messages (max 50 chars).\n    // Example: \"deps\", \"chore(deps)\"\n    Prefix string `yaml:\"prefix,omitempty\" json:\"prefix,omitempty\"`\n\n    // PrefixDevelopment is used for dev dependency updates.\n    // Example: \"deps(dev)\", \"chore(deps-dev)\"\n    PrefixDevelopment string `yaml:\"prefix_development,omitempty\" json:\"prefix_development,omitempty\"`\n\n    // IncludeScope adds dependency scope to commit messages.\n    // When true, adds \"deps\" or \"deps-dev\" scope.\n    IncludeScope bool `yaml:\"include_scope,omitempty\" json:\"include_scope,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-cooldownconfig","title":"type CooldownConfig","text":"<p>CooldownConfig defines delayed update settings. New versions are held for a configurable period before being proposed.</p> <pre><code>type CooldownConfig struct {\n    Include         []string `yaml:\"include,omitempty\" json:\"include,omitempty\"`\n    Exclude         []string `yaml:\"exclude,omitempty\" json:\"exclude,omitempty\"`\n    DefaultDays     int      `yaml:\"default_days,omitempty\" json:\"default_days,omitempty\"`\n    SemverMajorDays int      `yaml:\"semver_major_days,omitempty\" json:\"semver_major_days,omitempty\"`\n    SemverMinorDays int      `yaml:\"semver_minor_days,omitempty\" json:\"semver_minor_days,omitempty\"`\n    SemverPatchDays int      `yaml:\"semver_patch_days,omitempty\" json:\"semver_patch_days,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependency","title":"type Dependency","text":"<p>Dependency represents a single dependency in a manifest.</p> <pre><code>type Dependency struct {\n    Name           string `json:\"name\"`\n    CurrentVersion string `json:\"current_version\"`\n    Constraint     string `json:\"constraint,omitempty\"`\n    Type           string `json:\"type\"` // direct, dev, peer, optional\n    Registry       string `json:\"registry,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependencygroup","title":"type DependencyGroup","text":"<p>DependencyGroup defines a dependency grouping rule for combined PRs.</p> <pre><code>type DependencyGroup struct {\n    // AppliesTo specifies when this group applies.\n    // Valid values: version-updates, security-updates\n    // Default: applies to both\n    AppliesTo string `yaml:\"applies_to,omitempty\" json:\"applies_to,omitempty\"`\n\n    // DependencyType filters dependencies by type.\n    // Valid values: production, development\n    DependencyType string `yaml:\"dependency_type,omitempty\" json:\"dependency_type,omitempty\"`\n\n    // Patterns includes dependencies matching these glob patterns.\n    // Supports * wildcard. Example: [\"express*\", \"@types/*\"]\n    Patterns []string `yaml:\"patterns,omitempty\" json:\"patterns,omitempty\"`\n\n    // ExcludePatterns excludes dependencies matching these glob patterns.\n    ExcludePatterns []string `yaml:\"exclude_patterns,omitempty\" json:\"exclude_patterns,omitempty\"`\n\n    // UpdateTypes limits to specific update types.\n    // Valid values: major, minor, patch\n    UpdateTypes []string `yaml:\"update_types,omitempty\" json:\"update_types,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependencyrule","title":"type DependencyRule","text":"<p>DependencyRule specifies a dependency filter rule for allow lists.</p> <pre><code>type DependencyRule struct {\n    // DependencyName matches dependencies by name.\n    // Supports * wildcard for prefix/suffix matching.\n    DependencyName string `yaml:\"dependency_name,omitempty\" json:\"dependency_name,omitempty\"`\n\n    // DependencyType filters by dependency type.\n    // Valid values: direct, indirect, all, production, development\n    DependencyType string `yaml:\"dependency_type,omitempty\" json:\"dependency_type,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-engine","title":"type Engine","text":"<p>Engine orchestrates the scan, plan, and update operations.</p> <pre><code>type Engine struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newengine","title":"func NewEngine","text":"<pre><code>func NewEngine(logger *slog.Logger) *Engine\n</code></pre> <p>NewEngine creates a new engine with the given integrations.</p> <p></p>"},{"location":"api/#func-engine-getintegration","title":"func \\(\\*Engine\\) GetIntegration","text":"<pre><code>func (e *Engine) GetIntegration(name string) (Integration, bool)\n</code></pre> <p>GetIntegration retrieves a registered integration by name.</p> <p></p>"},{"location":"api/#func-engine-getschedulechecker","title":"func \\(\\*Engine\\) GetScheduleChecker","text":"<pre><code>func (e *Engine) GetScheduleChecker(integrationName string) (*ScheduleChecker, error)\n</code></pre> <p>GetScheduleChecker returns a ScheduleChecker for the given integration. Returns nil if no schedule is configured.</p> <p></p>"},{"location":"api/#func-engine-getupdatefilter","title":"func \\(\\*Engine\\) GetUpdateFilter","text":"<pre><code>func (e *Engine) GetUpdateFilter(integrationName string) *UpdateFilter\n</code></pre> <p>GetUpdateFilter returns an UpdateFilter for the given integration. This is useful for CLI commands that need to access filter configuration.</p> <p></p>"},{"location":"api/#func-engine-listintegrations","title":"func \\(\\*Engine\\) ListIntegrations","text":"<pre><code>func (e *Engine) ListIntegrations() []string\n</code></pre> <p>ListIntegrations returns all registered integration names.</p> <p></p>"},{"location":"api/#func-engine-plan","title":"func \\(\\*Engine\\) Plan","text":"<pre><code>func (e *Engine) Plan(ctx context.Context, manifests []*Manifest) (*PlanResult, error)\n</code></pre> <p>Plan generates update plans for all manifests. It applies policy precedence: CLI flags &gt; uptool.yaml &gt; manifest constraints. It also applies allow/ignore rules, cooldown, and grouping based on policy configuration.</p> <p></p>"},{"location":"api/#func-engine-planwithoptions","title":"func \\(\\*Engine\\) PlanWithOptions","text":"<pre><code>func (e *Engine) PlanWithOptions(ctx context.Context, manifests []*Manifest, opts *PlanOptions) (*PlanResult, error)\n</code></pre> <p>PlanWithOptions generates update plans with additional options. This allows enabling cooldown checking with release timestamps and schedule enforcement.</p> <p></p>"},{"location":"api/#func-engine-register","title":"func \\(\\*Engine\\) Register","text":"<pre><code>func (e *Engine) Register(integration Integration)\n</code></pre> <p>Register adds an integration to the engine.</p> <p></p>"},{"location":"api/#func-engine-scan","title":"func \\(\\*Engine\\) Scan","text":"<pre><code>func (e *Engine) Scan(ctx context.Context, repoRoot string, only, exclude []string) (*ScanResult, error)\n</code></pre> <p>Scan discovers all manifests across registered integrations.</p> <p></p>"},{"location":"api/#func-engine-setcliflags","title":"func \\(\\*Engine\\) SetCLIFlags","text":"<pre><code>func (e *Engine) SetCLIFlags(flags *CLIFlags)\n</code></pre> <p>SetCLIFlags configures CLI flag overrides for update behavior. These override manifest constraints but not uptool.yaml policies.</p> <p></p>"},{"location":"api/#func-engine-setmatchconfigs","title":"func \\(\\*Engine\\) SetMatchConfigs","text":"<pre><code>func (e *Engine) SetMatchConfigs(configs map[string]*MatchConfig)\n</code></pre> <p>SetMatchConfigs configures file pattern matching for integrations. Manifests will be filtered to only include those matching the configured patterns and exclude those matching exclude patterns.</p> <p></p>"},{"location":"api/#func-engine-setpolicies","title":"func \\(\\*Engine\\) SetPolicies","text":"<pre><code>func (e *Engine) SetPolicies(policies map[string]IntegrationPolicy)\n</code></pre> <p>SetPolicies configures integration policies from uptool.yaml. These policies have the highest precedence in determining allowed updates.</p> <p></p>"},{"location":"api/#func-engine-update","title":"func \\(\\*Engine\\) Update","text":"<pre><code>func (e *Engine) Update(ctx context.Context, plans []*UpdatePlan, dryRun bool) (*UpdateResult, error)\n</code></pre> <p>Update applies update plans.</p> <p></p>"},{"location":"api/#type-ignorerule_1","title":"type IgnoreRule","text":"<p>IgnoreRule specifies a dependency or version to exclude from updates.</p> <pre><code>type IgnoreRule struct {\n    // DependencyName matches dependencies by name.\n    // Supports * wildcard for prefix/suffix matching.\n    DependencyName string `yaml:\"dependency_name,omitempty\" json:\"dependency_name,omitempty\"`\n\n    // Versions specifies version ranges to ignore.\n    // Uses package manager version syntax (e.g., \"4.x\", \"&gt;= 2.0.0\")\n    Versions []string `yaml:\"versions,omitempty\" json:\"versions,omitempty\"`\n\n    // UpdateTypes specifies update types to ignore.\n    // Valid values: major, minor, patch\n    // (Also supports Dependabot format: version-update:semver-major, etc.)\n    UpdateTypes []string `yaml:\"update_types,omitempty\" json:\"update_types,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-impact","title":"type Impact","text":"<p>Impact describes the severity of an update.</p> <pre><code>type Impact string\n</code></pre> <p>Impact levels for update severity</p> <pre><code>const (\n    ImpactNone  Impact = \"none\"\n    ImpactPatch Impact = \"patch\"\n    ImpactMinor Impact = \"minor\"\n    ImpactMajor Impact = \"major\"\n)\n</code></pre> <p></p>"},{"location":"api/#type-integration","title":"type Integration","text":"<p>Integration defines the interface for ecosystem integrations.</p> <pre><code>type Integration interface {\n    // Name returns the integration identifier\n    Name() string\n\n    // Detect finds manifest files for this integration\n    Detect(ctx context.Context, repoRoot string) ([]*Manifest, error)\n\n    // Plan determines available updates for a manifest.\n    // The planCtx parameter provides policy configuration following the precedence order:\n    // uptool.yaml policy &gt; CLI flags &gt; manifest constraints.\n    // If planCtx is nil, the integration should use default behavior (respect constraints only).\n    Plan(ctx context.Context, manifest *Manifest, planCtx *PlanContext) (*UpdatePlan, error)\n\n    // Apply executes the update plan\n    Apply(ctx context.Context, plan *UpdatePlan) (*ApplyResult, error)\n\n    // Validate checks if changes are valid (optional)\n    Validate(ctx context.Context, manifest *Manifest) error\n}\n</code></pre> <p></p>"},{"location":"api/#type-integrationpolicy","title":"type IntegrationPolicy","text":"<p>IntegrationPolicy contains policy settings that apply to a specific integration.</p> <p>Policy settings control update behavior at the integration level \\(per manifest type\\). These settings are configured in uptool.yaml under integrations[*].policy and can be overridden by CLI flags.</p>"},{"location":"api/#policy-precedence","title":"Policy Precedence","text":"<p>The effective policy follows this precedence order \\(highest to lowest\\):</p> <ol> <li>CLI flags \\(\\-\\-update\\-level, \\-\\-allow\\-prerelease, etc.\\)</li> <li>uptool.yaml integration policy \\(this struct\\)</li> <li>Manifest constraints \\(^, \\~, \\&gt;=, etc. from package.json, Chart.yaml, etc.\\)</li> <li>Default behavior \\(allow all updates, respect constraints\\)</li> </ol>"},{"location":"api/#example-configuration","title":"Example Configuration","text":"<pre><code>integrations:\n  - id: npm\n    policy:\n      enabled: true\n      update: minor              # Allow patch + minor updates only\n      allow_prerelease: false    # Exclude beta/alpha versions\n      pin: false                 # Keep version ranges (^1.2.3)\n      cadence: weekly            # Check for updates weekly\n</code></pre> <p>See docs/configuration.md for comprehensive policy documentation.</p> <pre><code>type IntegrationPolicy struct {\n    Schedule              *Schedule                   `yaml:\"schedule,omitempty\" json:\"schedule,omitempty\"`\n    Groups                map[string]*DependencyGroup `yaml:\"groups,omitempty\" json:\"groups,omitempty\"`\n    Custom                map[string]interface{}      `yaml:\",inline\" json:\"custom,omitempty\"`\n    Cooldown              *CooldownConfig             `yaml:\"cooldown,omitempty\" json:\"cooldown,omitempty\"`\n    CommitMessage         *CommitMessageConfig        `yaml:\"commit_message,omitempty\" json:\"commit_message,omitempty\"`\n    VersioningStrategy    string                      `yaml:\"versioning_strategy,omitempty\" json:\"versioning_strategy,omitempty\"`\n    Cadence               string                      `yaml:\"cadence,omitempty\" json:\"cadence,omitempty\"`\n    Update                string                      `yaml:\"update\" json:\"update\"`\n    Ignore                []IgnoreRule                `yaml:\"ignore,omitempty\" json:\"ignore,omitempty\"`\n    Reviewers             []string                    `yaml:\"reviewers,omitempty\" json:\"reviewers,omitempty\"`\n    Assignees             []string                    `yaml:\"assignees,omitempty\" json:\"assignees,omitempty\"`\n    Labels                []string                    `yaml:\"labels,omitempty\" json:\"labels,omitempty\"`\n    Allow                 []DependencyRule            `yaml:\"allow,omitempty\" json:\"allow,omitempty\"`\n    OpenPullRequestsLimit int                         `yaml:\"open_pull_requests_limit,omitempty\" json:\"open_pull_requests_limit,omitempty\"`\n    Enabled               bool                        `yaml:\"enabled\" json:\"enabled\"`\n    AllowPrerelease       bool                        `yaml:\"allow_prerelease\" json:\"allow_prerelease\"`\n    Pin                   bool                        `yaml:\"pin\" json:\"pin\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-manifest","title":"type Manifest","text":"<p>Manifest represents a dependency manifest file.</p> <pre><code>type Manifest struct {\n    Metadata     map[string]interface{} `json:\"metadata,omitempty\"`\n    Path         string                 `json:\"path\"`\n    Type         string                 `json:\"type\"`\n    Dependencies []Dependency           `json:\"dependencies\"`\n    Content      []byte                 `json:\"-\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-matchconfig","title":"type MatchConfig","text":"<p>MatchConfig specifies file patterns for integration detection. It supports both include patterns \\(files to match\\) and exclude patterns \\(files to ignore\\).</p> <pre><code>type MatchConfig struct {\n    // Files is a list of glob patterns matching manifest files.\n    // If empty, all files detected by the integration are included.\n    Files []string\n\n    // Exclude is a list of glob patterns to exclude from matches.\n    // Files matching any exclude pattern are filtered out even if they match a files pattern.\n    // Exclude patterns are applied AFTER files patterns.\n    Exclude []string\n}\n</code></pre> <p></p>"},{"location":"api/#type-plancontext","title":"type PlanContext","text":"<p>PlanContext provides policy and configuration context for planning operations. It implements a precedence order: CLI flags &gt; uptool.yaml policy &gt; manifest constraints. This allows fine-grained control over which updates are allowed.</p> <pre><code>type PlanContext struct {\n    // Policy contains the integration-specific policy from uptool.yaml.\n    // This has medium precedence (after CLI flags) when determining allowed updates.\n    Policy *IntegrationPolicy\n\n    // CLIFlags contains any command-line overrides.\n    // These have the highest precedence and override all other policy sources.\n    CLIFlags *CLIFlags\n\n    // RespectConstraints indicates whether manifest constraints (e.g., ~&gt; 5.0)\n    // should be respected when no policy or flag overrides them.\n    // Defaults to true.\n    RespectConstraints bool\n}\n</code></pre> <p></p>"},{"location":"api/#func-newplancontext","title":"func NewPlanContext","text":"<pre><code>func NewPlanContext() *PlanContext\n</code></pre> <p>NewPlanContext creates a new PlanContext with default settings. By default, constraints are respected when no policy overrides them.</p> <p></p>"},{"location":"api/#func-plancontext-effectiveallowprerelease","title":"func \\(\\*PlanContext\\) EffectiveAllowPrerelease","text":"<pre><code>func (pc *PlanContext) EffectiveAllowPrerelease() bool\n</code></pre> <p>EffectiveAllowPrerelease returns whether prereleases are allowed, following precedence: 1. CLI flags \\(highest\\) 2. uptool.yaml policy 3. Default \\(false\\)</p> <p></p>"},{"location":"api/#func-plancontext-effectiveupdatelevel","title":"func \\(\\*PlanContext\\) EffectiveUpdateLevel","text":"<pre><code>func (pc *PlanContext) EffectiveUpdateLevel() string\n</code></pre> <p>EffectiveUpdateLevel returns the update level to use, following precedence: 1. CLI flags \\(highest\\) 2. uptool.yaml policy 3. Default \\(\"major\" \\- allow all updates, let constraints filter\\)</p> <p></p>"},{"location":"api/#func-plancontext-getpolicysource","title":"func \\(\\*PlanContext\\) GetPolicySource","text":"<pre><code>func (pc *PlanContext) GetPolicySource() PolicySource\n</code></pre> <p>GetPolicySource determines the source of the effective policy based on precedence. Returns the policy source following the precedence order: 1. CLI flags \\(highest\\) - overrides all other sources 2. uptool.yaml policy - overrides constraints 3. Manifest constraints \\(when no higher precedence policy exists\\) 4. Default</p> <p></p>"},{"location":"api/#func-plancontext-shouldrespectconstraints","title":"func \\(\\*PlanContext\\) ShouldRespectConstraints","text":"<pre><code>func (pc *PlanContext) ShouldRespectConstraints() bool\n</code></pre> <p>ShouldRespectConstraints returns whether manifest constraints should be respected. Constraints are always respected unless explicitly disabled.</p> <p></p>"},{"location":"api/#func-plancontext-withcliflags","title":"func \\(\\*PlanContext\\) WithCLIFlags","text":"<pre><code>func (pc *PlanContext) WithCLIFlags(flags *CLIFlags) *PlanContext\n</code></pre> <p>WithCLIFlags returns a copy of the context with the given CLI flags.</p> <p></p>"},{"location":"api/#func-plancontext-withpolicy","title":"func \\(\\*PlanContext\\) WithPolicy","text":"<pre><code>func (pc *PlanContext) WithPolicy(p *IntegrationPolicy) *PlanContext\n</code></pre> <p>WithPolicy returns a copy of the context with the given policy.</p> <p></p>"},{"location":"api/#type-planoptions","title":"type PlanOptions","text":"<p>PlanOptions contains options for the Plan operation.</p> <pre><code>type PlanOptions struct {\n    Now               time.Time\n    ReleaseTimestamps map[string]time.Time\n    CheckSchedule     bool\n}\n</code></pre> <p></p>"},{"location":"api/#type-planresult","title":"type PlanResult","text":"<p>PlanResult aggregates all update plans.</p> <pre><code>type PlanResult struct {\n    Plans     []*UpdatePlan `json:\"plans\"`\n    Timestamp time.Time     `json:\"timestamp\"`\n    Errors    []string      `json:\"errors,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-policysource","title":"type PolicySource","text":"<p>PolicySource indicates where the update policy originated from.</p> <pre><code>type PolicySource string\n</code></pre> <p>PolicySource values for policy precedence tracking</p> <pre><code>const (\n    // PolicySourceUptoolYAML indicates the policy came from uptool.yaml (highest precedence)\n    PolicySourceUptoolYAML PolicySource = \"uptool.yaml\"\n\n    // PolicySourceCLIFlag indicates the policy came from a CLI flag\n    PolicySourceCLIFlag PolicySource = \"cli-flag\"\n\n    // PolicySourceConstraint indicates the policy came from manifest constraints (e.g., ~&gt; 5.0)\n    PolicySourceConstraint PolicySource = \"constraint\"\n\n    // PolicySourceDefault indicates the default policy was used\n    PolicySourceDefault PolicySource = \"default\"\n)\n</code></pre> <p></p>"},{"location":"api/#type-scanresult","title":"type ScanResult","text":"<p>ScanResult aggregates all discovered manifests.</p> <pre><code>type ScanResult struct {\n    Manifests []*Manifest `json:\"manifests\"`\n    Timestamp time.Time   `json:\"timestamp\"`\n    RepoRoot  string      `json:\"repo_root\"`\n    Errors    []string    `json:\"errors,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-schedule_1","title":"type Schedule","text":"<p>Schedule defines when updates should be checked. This is compatible with Dependabot's schedule configuration.</p> <pre><code>type Schedule struct {\n    // Interval is the update frequency.\n    // Valid values: daily, weekly, monthly, quarterly, semiannually, yearly, cron\n    Interval string `yaml:\"interval\" json:\"interval\"`\n\n    // Day specifies the day for weekly updates.\n    // Valid values: monday, tuesday, wednesday, thursday, friday, saturday, sunday\n    Day string `yaml:\"day,omitempty\" json:\"day,omitempty\"`\n\n    // Time specifies the time for updates in HH:MM format (24-hour).\n    // Default timezone is UTC unless Timezone is specified.\n    Time string `yaml:\"time,omitempty\" json:\"time,omitempty\"`\n\n    // Timezone is the IANA timezone identifier for the schedule.\n    // Example: \"America/New_York\", \"Europe/London\"\n    Timezone string `yaml:\"timezone,omitempty\" json:\"timezone,omitempty\"`\n\n    // Cron is a cron expression for custom schedules.\n    // Only used when Interval is \"cron\".\n    // Example: \"0 9 * * 1\" (every Monday at 9am)\n    Cron string `yaml:\"cron,omitempty\" json:\"cron,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-schedulechecker","title":"type ScheduleChecker","text":"<p>ScheduleChecker handles schedule validation and enforcement.</p> <pre><code>type ScheduleChecker struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newschedulechecker","title":"func NewScheduleChecker","text":"<pre><code>func NewScheduleChecker(schedule *Schedule) (*ScheduleChecker, error)\n</code></pre> <p>NewScheduleChecker creates a new schedule checker.</p> <p></p>"},{"location":"api/#func-schedulechecker-getnextruntime","title":"func \\(\\*ScheduleChecker\\) GetNextRunTime","text":"<pre><code>func (sc *ScheduleChecker) GetNextRunTime(from time.Time) time.Time\n</code></pre> <p>GetNextRunTime calculates the next scheduled run time.</p> <p></p>"},{"location":"api/#func-schedulechecker-getscheduledescription","title":"func \\(\\*ScheduleChecker\\) GetScheduleDescription","text":"<pre><code>func (sc *ScheduleChecker) GetScheduleDescription() string\n</code></pre> <p>GetScheduleDescription returns a human-readable schedule description.</p> <p></p>"},{"location":"api/#func-schedulechecker-shouldrun","title":"func \\(\\*ScheduleChecker\\) ShouldRun","text":"<pre><code>func (sc *ScheduleChecker) ShouldRun(now time.Time) bool\n</code></pre> <p>ShouldRun checks if an update should run based on the schedule. Returns true if no schedule is configured or if the current time matches the schedule.</p> <p></p>"},{"location":"api/#type-update","title":"type Update","text":"<p>Update represents a planned update for a dependency.</p> <pre><code>type Update struct {\n    Info          *UpdateInfo  `json:\"info,omitempty\"`\n    Dependency    Dependency   `json:\"dependency\"`\n    TargetVersion string       `json:\"target_version\"`\n    Impact        string       `json:\"impact\"`\n    ChangelogURL  string       `json:\"changelog_url,omitempty\"`\n    PolicySource  PolicySource `json:\"policy_source,omitempty\"`\n    Group         string       `json:\"group,omitempty\"`\n    Breaking      bool         `json:\"breaking\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updatefilter","title":"type UpdateFilter","text":"<p>UpdateFilter applies policy-based filtering to updates. It enforces allow/ignore rules, cooldown periods, and versioning strategies.</p> <pre><code>type UpdateFilter struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newupdatefilter","title":"func NewUpdateFilter","text":"<pre><code>func NewUpdateFilter(policy *IntegrationPolicy) *UpdateFilter\n</code></pre> <p>NewUpdateFilter creates a new filter with the given policy.</p> <p></p>"},{"location":"api/#func-updatefilter-applyversioningstrategy","title":"func \\(\\*UpdateFilter\\) ApplyVersioningStrategy","text":"<pre><code>func (f *UpdateFilter) ApplyVersioningStrategy(update *Update, currentConstraint string) (string, bool)\n</code></pre> <p>ApplyVersioningStrategy adjusts the target version based on the versioning strategy. Returns the adjusted version and whether the update should be applied.</p> <p></p>"},{"location":"api/#func-updatefilter-filterupdates","title":"func \\(\\*UpdateFilter\\) FilterUpdates","text":"<pre><code>func (f *UpdateFilter) FilterUpdates(updates []Update, releaseTimestamps map[string]time.Time) ([]Update, map[string]string)\n</code></pre> <p>FilterUpdates applies all policy filters to a list of updates. It returns the filtered updates and the reason each update was filtered \\(if any\\).</p> <p></p>"},{"location":"api/#func-updatefilter-formatcommitmessage","title":"func \\(\\*UpdateFilter\\) FormatCommitMessage","text":"<pre><code>func (f *UpdateFilter) FormatCommitMessage(updates []Update, manifestPath string) string\n</code></pre> <p>FormatCommitMessage creates a commit message based on configuration.</p> <p></p>"},{"location":"api/#func-updatefilter-getassignees","title":"func \\(\\*UpdateFilter\\) GetAssignees","text":"<pre><code>func (f *UpdateFilter) GetAssignees() []string\n</code></pre> <p>GetAssignees returns the configured PR assignees.</p> <p></p>"},{"location":"api/#func-updatefilter-getcooldowndays","title":"func \\(\\*UpdateFilter\\) GetCooldownDays","text":"<pre><code>func (f *UpdateFilter) GetCooldownDays(impact string) int\n</code></pre> <p>GetCooldownDays returns the cooldown days for a specific update type.</p> <p></p>"},{"location":"api/#func-updatefilter-getlabels","title":"func \\(\\*UpdateFilter\\) GetLabels","text":"<pre><code>func (f *UpdateFilter) GetLabels() []string\n</code></pre> <p>GetLabels returns the configured PR labels.</p> <p></p>"},{"location":"api/#func-updatefilter-getopenpullrequestslimit","title":"func \\(\\*UpdateFilter\\) GetOpenPullRequestsLimit","text":"<pre><code>func (f *UpdateFilter) GetOpenPullRequestsLimit() int\n</code></pre> <p>GetOpenPullRequestsLimit returns the max open PRs limit.</p> <p></p>"},{"location":"api/#func-updatefilter-getreviewers","title":"func \\(\\*UpdateFilter\\) GetReviewers","text":"<pre><code>func (f *UpdateFilter) GetReviewers() []string\n</code></pre> <p>GetReviewers returns the configured PR reviewers.</p> <p></p>"},{"location":"api/#func-updatefilter-groupupdates","title":"func \\(\\*UpdateFilter\\) GroupUpdates","text":"<pre><code>func (f *UpdateFilter) GroupUpdates(updates []Update) (map[string][]Update, []Update)\n</code></pre> <p>GroupUpdates groups updates based on dependency group rules. Returns a map of group name to updates, and a slice of ungrouped updates.</p> <p></p>"},{"location":"api/#func-updatefilter-shouldupdatemanifest","title":"func \\(\\*UpdateFilter\\) ShouldUpdateManifest","text":"<pre><code>func (f *UpdateFilter) ShouldUpdateManifest() bool\n</code></pre> <p>ShouldUpdateManifest returns whether the manifest should be updated based on versioning strategy.</p> <p></p>"},{"location":"api/#type-updateinfo","title":"type UpdateInfo","text":"<p>UpdateInfo contains detailed information about an update for PR descriptions. This mirrors information that Dependabot includes in PR bodies.</p> <pre><code>type UpdateInfo struct {\n    ReleaseNotes       string       `json:\"release_notes,omitempty\"`\n    Changelog          string       `json:\"changelog,omitempty\"`\n    SourceURL          string       `json:\"source_url,omitempty\"`\n    ReleaseURL         string       `json:\"release_url,omitempty\"`\n    Commits            []CommitInfo `json:\"commits,omitempty\"`\n    CompatibilityScore int          `json:\"compatibility_score\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updateplan","title":"type UpdatePlan","text":"<p>UpdatePlan describes planned updates for a manifest.</p> <pre><code>type UpdatePlan struct {\n    Manifest *Manifest `json:\"manifest\"`\n    Strategy string    `json:\"strategy\"`\n    Updates  []Update  `json:\"updates\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-updateresult","title":"type UpdateResult","text":"<p>UpdateResult aggregates all apply results.</p> <pre><code>type UpdateResult struct {\n    Results   []*ApplyResult `json:\"results\"`\n    Timestamp time.Time      `json:\"timestamp\"`\n    Errors    []string       `json:\"errors,omitempty\"`\n}\n</code></pre>"},{"location":"api/#integrations","title":"integrations","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations\"\n</code></pre> <p>Package integrations provides metadata about available integrations.</p> <p>Package integrations provides a central registry for all integration implementations. Integrations can be built-in \\(compiled into the binary\\) or external \\(loaded as plugins\\).</p> <p>Package integrations provides shared utilities for integration implementations.</p>"},{"location":"api/#index_4","title":"Index","text":"<ul> <li>func ClearCache()</li> <li>func Count() int</li> <li>func Get\\(name string\\) \\(engine.Integration, error\\)</li> <li>func GetAll() map[string]engine.Integration</li> <li>func GetLazy() map[string]func() engine.Integration</li> <li>func IsDisabled\\(name string\\) bool</li> <li>func IsExperimental\\(name string\\) bool</li> <li>func List() []string</li> <li>func ListByCategory\\(category string\\) \\(map\\[string\\]Metadata, error\\)</li> <li>func ListIntegrations() \\(map\\[string\\]Metadata, error\\)</li> <li>func Register\\(name string, constructor func\\(\\) engine.Integration)</li> <li>func ReloadPlugins() error</li> <li>func ValidateFilePath\\(path string\\) error</li> <li>type CategoryMetadata</li> <li>type DatasourceMetadata</li> <li>type Metadata</li> <li>func GetMetadata\\(name string\\) \\(\\*Metadata, error\\)</li> <li>type RegistryMetadata</li> <li>func LoadMetadata() \\(\\*RegistryMetadata, error\\)</li> </ul>"},{"location":"api/#func-clearcache","title":"func ClearCache","text":"<pre><code>func ClearCache()\n</code></pre> <p>ClearCache clears all cached instances, forcing reinitialization on next access. Useful for testing or when integrations need to be refreshed.</p> <p></p>"},{"location":"api/#func-count","title":"func Count","text":"<pre><code>func Count() int\n</code></pre> <p>Count returns the number of registered integrations.</p> <p></p>"},{"location":"api/#func-get_1","title":"func Get","text":"<pre><code>func Get(name string) (engine.Integration, error)\n</code></pre> <p>Get returns a single integration by name, creating it lazily if needed. This is more efficient than GetAll() when you only need specific integrations.</p> <p></p>"},{"location":"api/#func-getall","title":"func GetAll","text":"<pre><code>func GetAll() map[string]engine.Integration\n</code></pre> <p>GetAll returns a map of all registered integrations. Uses lazy loading - only creates instances for integrations that haven't been created yet.</p> <p></p>"},{"location":"api/#func-getlazy","title":"func GetLazy","text":"<pre><code>func GetLazy() map[string]func() engine.Integration\n</code></pre> <p>GetLazy returns a map of constructors \\(not instances\\). Use this when you want to defer instantiation until actual use.</p> <p></p>"},{"location":"api/#func-isdisabled","title":"func IsDisabled","text":"<pre><code>func IsDisabled(name string) bool\n</code></pre> <p>IsDisabled checks if an integration is disabled in the registry.</p> <p></p>"},{"location":"api/#func-isexperimental","title":"func IsExperimental","text":"<pre><code>func IsExperimental(name string) bool\n</code></pre> <p>IsExperimental checks if an integration is marked as experimental.</p> <p></p>"},{"location":"api/#func-list_1","title":"func List","text":"<pre><code>func List() []string\n</code></pre> <p>List returns a sorted list of all registered integration names.</p> <p></p>"},{"location":"api/#func-listbycategory","title":"func ListByCategory","text":"<pre><code>func ListByCategory(category string) (map[string]Metadata, error)\n</code></pre> <p>ListByCategory returns integrations grouped by category.</p> <p></p>"},{"location":"api/#func-listintegrations","title":"func ListIntegrations","text":"<pre><code>func ListIntegrations() (map[string]Metadata, error)\n</code></pre> <p>ListIntegrations returns a list of all integration names with their metadata.</p> <p></p>"},{"location":"api/#func-register_1","title":"func Register","text":"<pre><code>func Register(name string, constructor func() engine.Integration)\n</code></pre> <p>Register adds an integration constructor to the global registry. This is typically called from init() functions in integration packages.</p> <p>Example:</p> <pre><code>func init() {\n    integrations.Register(\"npm\", New)\n}\n</code></pre> <p></p>"},{"location":"api/#func-reloadplugins","title":"func ReloadPlugins","text":"<pre><code>func ReloadPlugins() error\n</code></pre> <p>ReloadPlugins clears the plugin loaded flag and reloads all plugins. This allows hot-reloading of plugins without restarting the application.</p> <p></p>"},{"location":"api/#func-validatefilepath","title":"func ValidateFilePath","text":"<pre><code>func ValidateFilePath(path string) error\n</code></pre> <p>ValidateFilePath validates that a file path is safe to read/write. It checks for directory traversal attempts to prevent security vulnerabilities.</p> <p></p>"},{"location":"api/#type-categorymetadata","title":"type CategoryMetadata","text":"<p>CategoryMetadata contains information about an integration category.</p> <pre><code>type CategoryMetadata struct {\n    Name        string `yaml:\"name\"`\n    Description string `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-datasourcemetadata","title":"type DatasourceMetadata","text":"<p>DatasourceMetadata contains information about a datasource.</p> <pre><code>type DatasourceMetadata struct {\n    Name        string `yaml:\"name\"`\n    URL         string `yaml:\"url\"`\n    Type        string `yaml:\"type\"`\n    Description string `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-metadata","title":"type Metadata","text":"<p>Metadata contains information about an integration.</p> <pre><code>type Metadata struct {\n    DisplayName  string   `yaml:\"displayName\"`\n    Description  string   `yaml:\"description\"`\n    URL          string   `yaml:\"url\"`\n    Category     string   `yaml:\"category\"`\n    FilePatterns []string `yaml:\"filePatterns\"`\n    Datasources  []string `yaml:\"datasources\"`\n    Experimental bool     `yaml:\"experimental\"`\n    Disabled     bool     `yaml:\"disabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-getmetadata","title":"func GetMetadata","text":"<pre><code>func GetMetadata(name string) (*Metadata, error)\n</code></pre> <p>GetMetadata returns metadata for a specific integration.</p> <p></p>"},{"location":"api/#type-registrymetadata","title":"type RegistryMetadata","text":"<p>RegistryMetadata represents the full integrations.yaml structure.</p> <pre><code>type RegistryMetadata struct {\n    Integrations map[string]Metadata           `yaml:\"integrations\"`\n    Datasources  map[string]DatasourceMetadata `yaml:\"datasources\"`\n    Categories   map[string]CategoryMetadata   `yaml:\"categories\"`\n    Version      string                        `yaml:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-loadmetadata","title":"func LoadMetadata","text":"<pre><code>func LoadMetadata() (*RegistryMetadata, error)\n</code></pre> <p>LoadMetadata loads integration metadata from the integrations.yaml file.</p>"},{"location":"api/#policy","title":"policy","text":"<pre><code>import \"github.com/santosr2/uptool/internal/policy\"\n</code></pre> <p>Package policy handles cadence-based update filtering.</p> <p>Package policy handles configuration file parsing and policy management.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>This package defines the structure for uptool.yaml configuration files, which control:</p> <ul> <li>Integration-specific policies \\(update strategies, version pinning, cadence\\)</li> <li>Organization-level governance \\(signoffs, signing, auto\\-merge guards\\)</li> <li>File matching patterns for integration detection</li> </ul>"},{"location":"api/#configuration-structure","title":"Configuration Structure","text":"<p>uptool.yaml has two main sections:</p> <ol> <li>integrations[] - Per-integration update policies</li> <li>org_policy - Organization-level governance policies</li> </ol>"},{"location":"api/#policy-precedence_1","title":"Policy Precedence","text":"<p>Update policies follow this precedence order \\(highest to lowest\\):</p> <ol> <li>CLI flags \\(\\-\\-update\\-level, \\-\\-allow\\-prerelease\\)</li> <li>uptool.yaml integration policy \\(integrations\\[\\*\\].policy\\)</li> <li>Manifest constraints \\(^, \\~, \\&gt;=, etc.\\)</li> <li>Default behavior</li> </ol>"},{"location":"api/#example-configuration_1","title":"Example Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor          # Allow patch + minor updates\n      allow_prerelease: false\n      pin: false             # Preserve version ranges\n      cadence: weekly\n\norg_policy:\n  require_signoff_from:\n    - \"@security-team\"\n  auto_merge:\n    enabled: true\n    guards:\n      - \"ci-green\"\n      - \"codeowners-approve\"\n</code></pre> <p>See docs/configuration.md and docs/policy.md for comprehensive documentation.</p> <p>Package policy implements organization policy enforcement for uptool. This includes signoff requirements, cosign verification, and auto-merge logic.</p>"},{"location":"api/#index_5","title":"Index","text":"<ul> <li>func GetDefaultStateFile() string</li> <li>func SaveCadenceState\\(stateFile string, state \\*CadenceState\\) error</li> <li>func ValidateIntegrationPolicy\\(p \\*engine.IntegrationPolicy\\) error</li> <li>type AutoMergeConfig</li> <li>type CadenceState</li> <li>func LoadCadenceState\\(stateFile string\\) \\(\\*CadenceState, error\\)</li> <li>func \\(cs \\*CadenceState\\) MarkChecked\\(manifestPath string\\)</li> <li>func \\(cs \\*CadenceState\\) ShouldCheckForUpdates\\(manifestPath, cadence string\\) bool</li> <li>type Config</li> <li>func DefaultConfig() *Config</li> <li>func LoadConfig\\(path string\\) \\(\\*Config, error\\)</li> <li>func \\(c \\*Config\\) EnabledIntegrations() []string</li> <li>func \\(c \\*Config\\) GetAutoMergeGuards() []string</li> <li>func \\(c \\*Config\\) GetOrgPolicy() *OrgPolicy</li> <li>func \\(c \\*Config\\) IsAutoMergeEnabled() bool</li> <li>func \\(c \\*Config\\) RequiresCosignVerification() bool</li> <li>func \\(c \\*Config\\) RequiresSignoff() bool</li> <li>func \\(c \\*Config\\) ToMatchConfigMap() map[string]*engine.MatchConfig</li> <li>func \\(c \\*Config\\) ToPolicyMap() map[string]engine.IntegrationPolicy</li> <li>func \\(c \\*Config\\) Validate() error</li> <li>type EnforcementResult</li> <li>type Enforcer</li> <li>func NewEnforcer\\(config \\*Config\\) *Enforcer</li> <li>func \\(e \\*Enforcer\\) Enforce\\(ctx context.Context\\) \\(\\*EnforcementResult, error\\)</li> <li>type IntegrationConfig</li> <li>type MatchConfig</li> <li>type OrgPolicy</li> <li>type SigningConfig</li> </ul>"},{"location":"api/#func-getdefaultstatefile","title":"func GetDefaultStateFile","text":"<pre><code>func GetDefaultStateFile() string\n</code></pre> <p>GetDefaultStateFile returns the default location for the cadence state file.</p> <p></p>"},{"location":"api/#func-savecadencestate","title":"func SaveCadenceState","text":"<pre><code>func SaveCadenceState(stateFile string, state *CadenceState) error\n</code></pre> <p>SaveCadenceState writes the cadence state to disk.</p> <p></p>"},{"location":"api/#func-validateintegrationpolicy","title":"func ValidateIntegrationPolicy","text":"<pre><code>func ValidateIntegrationPolicy(p *engine.IntegrationPolicy) error\n</code></pre> <p>ValidateIntegrationPolicy checks that an integration policy is valid.</p> <p></p>"},{"location":"api/#type-automergeconfig","title":"type AutoMergeConfig","text":"<p>AutoMergeConfig controls automatic PR merging.</p> <pre><code>type AutoMergeConfig struct {\n    Guards  []string `yaml:\"guards\"`\n    Enabled bool     `yaml:\"enabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-cadencestate","title":"type CadenceState","text":"<p>CadenceState tracks when manifests were last checked for updates.</p> <pre><code>type CadenceState struct {\n    LastChecked map[string]time.Time `json:\"last_checked\"` // manifestPath -&gt; timestamp\n}\n</code></pre> <p></p>"},{"location":"api/#func-loadcadencestate","title":"func LoadCadenceState","text":"<pre><code>func LoadCadenceState(stateFile string) (*CadenceState, error)\n</code></pre> <p>LoadCadenceState loads the cadence state from disk.</p> <p></p>"},{"location":"api/#func-cadencestate-markchecked","title":"func \\(\\*CadenceState\\) MarkChecked","text":"<pre><code>func (cs *CadenceState) MarkChecked(manifestPath string)\n</code></pre> <p>MarkChecked records that a manifest was checked at the current time.</p> <p></p>"},{"location":"api/#func-cadencestate-shouldcheckforupdates","title":"func \\(\\*CadenceState\\) ShouldCheckForUpdates","text":"<pre><code>func (cs *CadenceState) ShouldCheckForUpdates(manifestPath, cadence string) bool\n</code></pre> <p>ShouldCheckForUpdates determines if a manifest should be checked based on cadence policy.</p> <p></p>"},{"location":"api/#type-config_1","title":"type Config","text":"<p>Config represents the complete uptool.yaml configuration file.</p> <p>The configuration file controls both integration-specific update policies and organization-level governance settings.</p> <p>Example:</p> <pre><code>version: 1\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\norg_policy:\n  auto_merge:\n    enabled: true\n    guards: [\"ci-green\"]\n</code></pre> <pre><code>type Config struct {\n    // OrgPolicy contains organization-level governance policies (signoffs, signing, auto-merge).\n    // This field is optional - if omitted, no org-level policies are enforced.\n    OrgPolicy *OrgPolicy `yaml:\"org_policy,omitempty\"`\n\n    // Integrations contains per-integration configuration (update policies, file patterns).\n    // Each integration can be individually enabled/disabled and configured with its own policy.\n    Integrations []IntegrationConfig `yaml:\"integrations\"`\n\n    // Version specifies the configuration format version.\n    // Currently only version 1 is supported. This field is required.\n    Version int `yaml:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#func-defaultconfig","title":"func DefaultConfig","text":"<pre><code>func DefaultConfig() *Config\n</code></pre> <p>DefaultConfig returns a default configuration with sensible defaults.</p> <p></p>"},{"location":"api/#func-loadconfig_1","title":"func LoadConfig","text":"<pre><code>func LoadConfig(path string) (*Config, error)\n</code></pre> <p>LoadConfig reads and parses the configuration file.</p> <p></p>"},{"location":"api/#func-config-enabledintegrations","title":"func \\(\\*Config\\) EnabledIntegrations","text":"<pre><code>func (c *Config) EnabledIntegrations() []string\n</code></pre> <p>EnabledIntegrations returns the IDs of all enabled integrations.</p> <p></p>"},{"location":"api/#func-config-getautomergeguards","title":"func \\(\\*Config\\) GetAutoMergeGuards","text":"<pre><code>func (c *Config) GetAutoMergeGuards() []string\n</code></pre> <p>GetAutoMergeGuards returns the list of required guards for auto-merge.</p> <p></p>"},{"location":"api/#func-config-getorgpolicy","title":"func \\(\\*Config\\) GetOrgPolicy","text":"<pre><code>func (c *Config) GetOrgPolicy() *OrgPolicy\n</code></pre> <p>GetOrgPolicy returns the organization-level policy settings if configured.</p> <p></p>"},{"location":"api/#func-config-isautomergeenabled","title":"func \\(\\*Config\\) IsAutoMergeEnabled","text":"<pre><code>func (c *Config) IsAutoMergeEnabled() bool\n</code></pre> <p>IsAutoMergeEnabled returns whether auto-merge is enabled.</p> <p></p>"},{"location":"api/#func-config-requirescosignverification","title":"func \\(\\*Config\\) RequiresCosignVerification","text":"<pre><code>func (c *Config) RequiresCosignVerification() bool\n</code></pre> <p>RequiresCosignVerification returns whether cosign verification is required.</p> <p></p>"},{"location":"api/#func-config-requiressignoff","title":"func \\(\\*Config\\) RequiresSignoff","text":"<pre><code>func (c *Config) RequiresSignoff() bool\n</code></pre> <p>RequiresSignoff returns whether the organization policy requires signoff for changes.</p> <p></p>"},{"location":"api/#func-config-tomatchconfigmap","title":"func \\(\\*Config\\) ToMatchConfigMap","text":"<pre><code>func (c *Config) ToMatchConfigMap() map[string]*engine.MatchConfig\n</code></pre> <p>ToMatchConfigMap converts the configuration into a map of match configs per integration. Returns only integrations that have match configuration specified.</p> <p></p>"},{"location":"api/#func-config-topolicymap","title":"func \\(\\*Config\\) ToPolicyMap","text":"<pre><code>func (c *Config) ToPolicyMap() map[string]engine.IntegrationPolicy\n</code></pre> <p>ToPolicyMap converts the configuration into a map of integration policies.</p> <p></p>"},{"location":"api/#func-config-validate_1","title":"func \\(\\*Config\\) Validate","text":"<pre><code>func (c *Config) Validate() error\n</code></pre> <p>Validate checks that the configuration is valid.</p> <p></p>"},{"location":"api/#type-enforcementresult","title":"type EnforcementResult","text":"<p>EnforcementResult contains the results of policy enforcement.</p> <pre><code>type EnforcementResult struct {\n    GuardsStatus     map[string]bool\n    SignoffErrors    []string\n    CosignErrors     []string\n    AutoMergeErrors  []string\n    SignoffValid     bool\n    CosignValid      bool\n    AutoMergeAllowed bool\n}\n</code></pre> <p></p>"},{"location":"api/#type-enforcer","title":"type Enforcer","text":"<p>Enforcer handles organization policy enforcement.</p> <pre><code>type Enforcer struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newenforcer","title":"func NewEnforcer","text":"<pre><code>func NewEnforcer(config *Config) *Enforcer\n</code></pre> <p>NewEnforcer creates a new policy enforcer.</p> <p></p>"},{"location":"api/#func-enforcer-enforce","title":"func \\(\\*Enforcer\\) Enforce","text":"<pre><code>func (e *Enforcer) Enforce(ctx context.Context) (*EnforcementResult, error)\n</code></pre> <p>Enforce checks all configured organization policies.</p> <p></p>"},{"location":"api/#type-integrationconfig","title":"type IntegrationConfig","text":"<p>IntegrationConfig defines configuration for a specific integration \\(npm, helm, terraform, etc.\\).</p> <p>Each integration can be independently configured with custom update policies, file matching patterns, and enable/disable state.</p> <p>Example:</p> <ul> <li>id: npm enabled: true match: files: [\"package.json\", \"apps/*/package.json\"] policy: update: minor allow_prerelease: false pin: false cadence: weekly</li> </ul> <pre><code>type IntegrationConfig struct {\n    // Match specifies custom file patterns for this integration.\n    // If omitted, the integration uses its default file patterns.\n    Match *MatchConfig `yaml:\"match,omitempty\"`\n\n    // ID is the integration identifier (e.g., \"npm\", \"helm\", \"terraform\").\n    // Must match one of the registered integration names. Required.\n    ID  string `yaml:\"id\"`\n\n    // Policy contains update policy settings for this integration.\n    // Controls which updates are allowed (patch/minor/major), version pinning, etc.\n    Policy engine.IntegrationPolicy `yaml:\"policy\"`\n\n    // Enabled controls whether this integration runs during scan/plan/update.\n    // Default: true. Can be overridden by CLI flags (--only, --exclude).\n    Enabled bool `yaml:\"enabled\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-matchconfig_1","title":"type MatchConfig","text":"<p>MatchConfig specifies file glob patterns for integration detection.</p> <p>Use this to customize which files an integration should process, particularly useful for monorepos or non-standard project structures.</p> <p>Example:</p> <pre><code>match:\n  files:\n    - \"package.json\"           # Root package\n    - \"apps/*/package.json\"    # App packages\n    - \"packages/*/package.json\" # Library packages\n  exclude:\n    - \"node_modules/**/package.json\"  # Ignore dependencies\n    - \"dist/**/package.json\"          # Ignore build artifacts\n</code></pre> <pre><code>type MatchConfig struct {\n    // Files is a list of glob patterns matching manifest files.\n    // Patterns support standard glob syntax: *, **, ?, [abc], {a,b,c}.\n    Files []string `yaml:\"files\"`\n\n    // Exclude is a list of glob patterns to exclude from matches.\n    // Files matching any exclude pattern are filtered out even if they match a files pattern.\n    // Patterns support standard glob syntax: *, **, ?, [abc], {a,b,c}.\n    //\n    // Exclude patterns are applied AFTER files patterns, providing fine-grained control.\n    //\n    // Common use cases:\n    //   - Exclude vendor directories: \"vendor/**\"\n    //   - Exclude build artifacts: \"dist/**\", \"build/**\"\n    //   - Exclude test fixtures: \"testdata/**\", \"fixtures/**\"\n    //   - Exclude specific paths: \"legacy/old-app/**\"\n    Exclude []string `yaml:\"exclude,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-orgpolicy","title":"type OrgPolicy","text":"<p>OrgPolicy contains organization-level policies and governance settings.</p> <pre><code>type OrgPolicy struct {\n    Signing            *SigningConfig   `yaml:\"signing,omitempty\"`\n    AutoMerge          *AutoMergeConfig `yaml:\"auto_merge,omitempty\"`\n    RequireSignoffFrom []string         `yaml:\"require_signoff_from,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-signingconfig","title":"type SigningConfig","text":"<p>SigningConfig controls artifact signing verification.</p> <pre><code>type SigningConfig struct {\n    CosignVerify bool `yaml:\"cosign_verify\"`\n}\n</code></pre>"},{"location":"api/#registry","title":"registry","text":"<pre><code>import \"github.com/santosr2/uptool/internal/registry\"\n</code></pre> <p>Package registry provides HTTP clients for querying package registries and release APIs. It includes clients for npm Registry, Terraform Registry, GitHub Releases, and Helm repositories, enabling version lookups and constraint-based version resolution.</p>"},{"location":"api/#index_6","title":"Index","text":"<ul> <li>func IsOCIRepository\\(repository string\\) bool</li> <li>func ParseGitHubURL\\(url string\\) \\(owner, repo string, err error\\)</li> <li>type ChartIndex</li> <li>type ChartIndexEntry</li> <li>type GitHubClient</li> <li>func NewGitHubClient\\(token string\\) *GitHubClient</li> <li>func \\(c \\*GitHubClient\\) FindBestRelease\\(ctx context.Context, owner, repo, constraint string, allowPrerelease bool\\) \\(string, error\\)</li> <li>func \\(c \\*GitHubClient\\) GetAllReleases\\(ctx context.Context, owner, repo string\\) \\(\\[\\]Release, error\\)</li> <li>func \\(c \\*GitHubClient\\) GetLatestRelease\\(ctx context.Context, owner, repo string\\) \\(string, error\\)</li> <li>type GoClient</li> <li>func NewGoClient() *GoClient</li> <li>func \\(c \\*GoClient\\) FindBestVersion\\(ctx context.Context, modulePath string, allowPrerelease bool\\) \\(string, error\\)</li> <li>func \\(c \\*GoClient\\) GetLatestVersion\\(ctx context.Context, modulePath string\\) \\(string, error\\)</li> <li>func \\(c \\*GoClient\\) GetModuleInfo\\(ctx context.Context, modulePath, version string\\) \\(\\*GoModuleInfo, error\\)</li> <li>func \\(c \\*GoClient\\) GetVersions\\(ctx context.Context, modulePath string\\) \\(\\[\\]string, error\\)</li> <li>type GoModuleInfo</li> <li>type HelmClient</li> <li>func NewHelmClient() *HelmClient</li> <li>func \\(c \\*HelmClient\\) FindBestChartVersion\\(ctx context.Context, repository, chartName, constraint string\\) \\(string, error\\)</li> <li>func \\(c \\*HelmClient\\) GetChartVersionDetails\\(ctx context.Context, repository, chartName string\\) \\(\\[\\]ChartIndexEntry, error\\)</li> <li>func \\(c \\*HelmClient\\) GetChartVersions\\(ctx context.Context, repository, chartName string\\) \\(\\[\\]string, error\\)</li> <li>func \\(c \\*HelmClient\\) GetLatestChartVersion\\(ctx context.Context, repository, chartName string\\) \\(string, error\\)</li> <li>type Module</li> <li>type ModuleVersion</li> <li>type ModuleVersions</li> <li>type NPMClient</li> <li>func NewNPMClient() *NPMClient</li> <li>func \\(c \\*NPMClient\\) FindBestVersion\\(ctx context.Context, packageName, constraint string, allowPrerelease bool\\) \\(string, error\\)</li> <li>func \\(c \\*NPMClient\\) GetLatestVersion\\(ctx context.Context, packageName string\\) \\(string, error\\)</li> <li>func \\(c \\*NPMClient\\) GetPackageInfo\\(ctx context.Context, packageName string\\) \\(\\*PackageInfo, error\\)</li> <li>func \\(c \\*NPMClient\\) GetVersions\\(ctx context.Context, packageName string\\) \\(\\[\\]string, error\\)</li> <li>type PackageInfo</li> <li>type ProviderVersion</li> <li>type ProviderVersions</li> <li>type Release</li> <li>type TerraformClient</li> <li>func NewTerraformClient() *TerraformClient</li> <li>func \\(c \\*TerraformClient\\) FindBestProviderVersion\\(ctx context.Context, source, constraint string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetLatestModuleVersion\\(ctx context.Context, source string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetLatestProviderVersion\\(ctx context.Context, source string\\) \\(string, error\\)</li> <li>func \\(c \\*TerraformClient\\) GetModuleVersions\\(ctx context.Context, source string\\) \\(\\[\\]ModuleVersion, error\\)</li> </ul>"},{"location":"api/#func-isocirepository","title":"func IsOCIRepository","text":"<pre><code>func IsOCIRepository(repository string) bool\n</code></pre> <p>IsOCIRepository checks if a repository URL is an OCI registry.</p> <p></p>"},{"location":"api/#func-parsegithuburl","title":"func ParseGitHubURL","text":"<pre><code>func ParseGitHubURL(url string) (owner, repo string, err error)\n</code></pre> <p>ParseGitHubURL extracts owner and repo from a GitHub URL. Supports: - https://github.com/owner/repo - github.com/owner/repo - owner/repo</p> <p></p>"},{"location":"api/#type-chartindex","title":"type ChartIndex","text":"<p>ChartIndex represents the index.yaml structure from a Helm repository.</p> <pre><code>type ChartIndex struct {\n    Entries    map[string][]ChartIndexEntry `yaml:\"entries\"`\n    APIVersion string                       `yaml:\"apiVersion\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-chartindexentry","title":"type ChartIndexEntry","text":"<p>ChartIndexEntry represents a single chart version entry.</p> <pre><code>type ChartIndexEntry struct {\n    Created     time.Time `yaml:\"created\"`\n    Name        string    `yaml:\"name\"`\n    Version     string    `yaml:\"version\"`\n    AppVersion  string    `yaml:\"appVersion\"`\n    Description string    `yaml:\"description\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-githubclient","title":"type GitHubClient","text":"<p>GitHubClient queries GitHub API for release information.</p> <pre><code>type GitHubClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgithubclient","title":"func NewGitHubClient","text":"<pre><code>func NewGitHubClient(token string) *GitHubClient\n</code></pre> <p>NewGitHubClient creates a new GitHub API client. Token is optional but recommended to avoid rate limiting.</p> <p></p>"},{"location":"api/#func-githubclient-findbestrelease","title":"func \\(\\*GitHubClient\\) FindBestRelease","text":"<pre><code>func (c *GitHubClient) FindBestRelease(ctx context.Context, owner, repo, constraint string, allowPrerelease bool) (string, error)\n</code></pre> <p>FindBestRelease finds the best release matching a constraint.</p> <p></p>"},{"location":"api/#func-githubclient-getallreleases","title":"func \\(\\*GitHubClient\\) GetAllReleases","text":"<pre><code>func (c *GitHubClient) GetAllReleases(ctx context.Context, owner, repo string) ([]Release, error)\n</code></pre> <p>GetAllReleases fetches all releases for a repository.</p> <p></p>"},{"location":"api/#func-githubclient-getlatestrelease","title":"func \\(\\*GitHubClient\\) GetLatestRelease","text":"<pre><code>func (c *GitHubClient) GetLatestRelease(ctx context.Context, owner, repo string) (string, error)\n</code></pre> <p>GetLatestRelease fetches the latest non-prerelease release for a repository.</p> <p></p>"},{"location":"api/#type-goclient","title":"type GoClient","text":"<p>GoClient queries the Go module proxy for version information.</p> <pre><code>type GoClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newgoclient","title":"func NewGoClient","text":"<pre><code>func NewGoClient() *GoClient\n</code></pre> <p>NewGoClient creates a new Go module proxy client.</p> <p></p>"},{"location":"api/#func-goclient-findbestversion","title":"func \\(\\*GoClient\\) FindBestVersion","text":"<pre><code>func (c *GoClient) FindBestVersion(ctx context.Context, modulePath string, allowPrerelease bool) (string, error)\n</code></pre> <p>FindBestVersion finds the best version matching criteria.</p> <p></p>"},{"location":"api/#func-goclient-getlatestversion","title":"func \\(\\*GoClient\\) GetLatestVersion","text":"<pre><code>func (c *GoClient) GetLatestVersion(ctx context.Context, modulePath string) (string, error)\n</code></pre> <p>GetLatestVersion fetches the latest version for a Go module. It queries the @latest endpoint which returns the highest semver version.</p> <p></p>"},{"location":"api/#func-goclient-getmoduleinfo","title":"func \\(\\*GoClient\\) GetModuleInfo","text":"<pre><code>func (c *GoClient) GetModuleInfo(ctx context.Context, modulePath, version string) (*GoModuleInfo, error)\n</code></pre> <p>GetModuleInfo fetches detailed information about a specific version of a module.</p> <p></p>"},{"location":"api/#func-goclient-getversions","title":"func \\(\\*GoClient\\) GetVersions","text":"<pre><code>func (c *GoClient) GetVersions(ctx context.Context, modulePath string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a Go module. It queries the @v/list endpoint which returns newline-separated versions.</p> <p></p>"},{"location":"api/#type-gomoduleinfo","title":"type GoModuleInfo","text":"<p>GoModuleInfo represents the JSON response from the Go module proxy @latest endpoint.</p> <pre><code>type GoModuleInfo struct {\n    Time    time.Time `json:\"Time\"`\n    Version string    `json:\"Version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-helmclient","title":"type HelmClient","text":"<p>HelmClient queries Helm chart repositories.</p> <pre><code>type HelmClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newhelmclient","title":"func NewHelmClient","text":"<pre><code>func NewHelmClient() *HelmClient\n</code></pre> <p>NewHelmClient creates a new Helm chart repository client.</p> <p></p>"},{"location":"api/#func-helmclient-findbestchartversion","title":"func \\(\\*HelmClient\\) FindBestChartVersion","text":"<pre><code>func (c *HelmClient) FindBestChartVersion(ctx context.Context, repository, chartName, constraint string) (string, error)\n</code></pre> <p>FindBestChartVersion finds the best chart version matching a constraint.</p> <p></p>"},{"location":"api/#func-helmclient-getchartversiondetails","title":"func \\(\\*HelmClient\\) GetChartVersionDetails","text":"<pre><code>func (c *HelmClient) GetChartVersionDetails(ctx context.Context, repository, chartName string) ([]ChartIndexEntry, error)\n</code></pre> <p>GetChartVersionDetails returns all available versions with metadata for a chart from a repository.</p> <p></p>"},{"location":"api/#func-helmclient-getchartversions","title":"func \\(\\*HelmClient\\) GetChartVersions","text":"<pre><code>func (c *HelmClient) GetChartVersions(ctx context.Context, repository, chartName string) ([]string, error)\n</code></pre> <p>GetChartVersions returns all available versions for a chart.</p> <p></p>"},{"location":"api/#func-helmclient-getlatestchartversion","title":"func \\(\\*HelmClient\\) GetLatestChartVersion","text":"<pre><code>func (c *HelmClient) GetLatestChartVersion(ctx context.Context, repository, chartName string) (string, error)\n</code></pre> <p>GetLatestChartVersion fetches the latest version for a chart from a repository. repository: the base URL of the chart repository \\(e.g., \"https://charts.bitnami.com/bitnami\"\\) chartName: the name of the chart \\(e.g., \"postgresql\"\\)</p> <p></p>"},{"location":"api/#type-module","title":"type Module","text":"<p>Module represents a module with its versions.</p> <pre><code>type Module struct {\n    Source   string          `json:\"source\"`\n    Versions []ModuleVersion `json:\"versions\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-moduleversion","title":"type ModuleVersion","text":"<p>ModuleVersion represents a single module version.</p> <pre><code>type ModuleVersion struct {\n    Version string `json:\"version\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-moduleversions","title":"type ModuleVersions","text":"<p>ModuleVersions represents the response from /v1/modules/{namespace}/{name}/{provider}/versions.</p> <pre><code>type ModuleVersions struct {\n    Modules []Module `json:\"modules\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-npmclient","title":"type NPMClient","text":"<p>NPMClient queries the npm registry for package information.</p> <pre><code>type NPMClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newnpmclient","title":"func NewNPMClient","text":"<pre><code>func NewNPMClient() *NPMClient\n</code></pre> <p>NewNPMClient creates a new npm registry client.</p> <p></p>"},{"location":"api/#func-npmclient-findbestversion","title":"func \\(\\*NPMClient\\) FindBestVersion","text":"<pre><code>func (c *NPMClient) FindBestVersion(ctx context.Context, packageName, constraint string, allowPrerelease bool) (string, error)\n</code></pre> <p>FindBestVersion finds the best version matching a constraint.</p> <p></p>"},{"location":"api/#func-npmclient-getlatestversion","title":"func \\(\\*NPMClient\\) GetLatestVersion","text":"<pre><code>func (c *NPMClient) GetLatestVersion(ctx context.Context, packageName string) (string, error)\n</code></pre> <p>GetLatestVersion fetches the latest version for a package.</p> <p></p>"},{"location":"api/#func-npmclient-getpackageinfo","title":"func \\(\\*NPMClient\\) GetPackageInfo","text":"<pre><code>func (c *NPMClient) GetPackageInfo(ctx context.Context, packageName string) (*PackageInfo, error)\n</code></pre> <p>GetPackageInfo fetches full package information from npm registry.</p> <p></p>"},{"location":"api/#func-npmclient-getversions","title":"func \\(\\*NPMClient\\) GetVersions","text":"<pre><code>func (c *NPMClient) GetVersions(ctx context.Context, packageName string) ([]string, error)\n</code></pre> <p>GetVersions returns all available versions for a package.</p> <p></p>"},{"location":"api/#type-packageinfo_1","title":"type PackageInfo","text":"<p>PackageInfo contains npm package metadata.</p> <pre><code>type PackageInfo struct {\n    Versions map[string]map[string]interface{} `json:\"versions\"`\n    DistTags map[string]string                 `json:\"dist-tags\"`\n    Time     map[string]string                 `json:\"time\"`\n    Name     string                            `json:\"name\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerversion","title":"type ProviderVersion","text":"<p>ProviderVersion represents a single provider version.</p> <pre><code>type ProviderVersion struct {\n    Version   string   `json:\"version\"`\n    Platforms []string `json:\"platforms\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerversions","title":"type ProviderVersions","text":"<p>ProviderVersions represents the response from /v1/providers/{namespace}/{type}/versions.</p> <pre><code>type ProviderVersions struct {\n    Versions []ProviderVersion `json:\"versions\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-release","title":"type Release","text":"<p>Release represents a GitHub release.</p> <pre><code>type Release struct {\n    TagName     string `json:\"tag_name\"`\n    Name        string `json:\"name\"`\n    CreatedAt   string `json:\"created_at\"`\n    PublishedAt string `json:\"published_at\"`\n    Draft       bool   `json:\"draft\"`\n    Prerelease  bool   `json:\"prerelease\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-terraformclient","title":"type TerraformClient","text":"<p>TerraformClient queries the Terraform Registry API.</p> <pre><code>type TerraformClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newterraformclient","title":"func NewTerraformClient","text":"<pre><code>func NewTerraformClient() *TerraformClient\n</code></pre> <p>NewTerraformClient creates a new Terraform Registry client.</p> <p></p>"},{"location":"api/#func-terraformclient-findbestproviderversion","title":"func \\(\\*TerraformClient\\) FindBestProviderVersion","text":"<pre><code>func (c *TerraformClient) FindBestProviderVersion(ctx context.Context, source, constraint string) (string, error)\n</code></pre> <p>FindBestProviderVersion finds the best provider version matching a constraint.</p> <p></p>"},{"location":"api/#func-terraformclient-getlatestmoduleversion","title":"func \\(\\*TerraformClient\\) GetLatestModuleVersion","text":"<pre><code>func (c *TerraformClient) GetLatestModuleVersion(ctx context.Context, source string) (string, error)\n</code></pre> <p>GetLatestModuleVersion fetches the latest version for a module. source format: \"namespace/name/provider\" \\(e.g., \"terraform\\-aws\\-modules/vpc/aws\"\\)</p> <p></p>"},{"location":"api/#func-terraformclient-getlatestproviderversion","title":"func \\(\\*TerraformClient\\) GetLatestProviderVersion","text":"<pre><code>func (c *TerraformClient) GetLatestProviderVersion(ctx context.Context, source string) (string, error)\n</code></pre> <p>GetLatestProviderVersion fetches the latest version for a provider. source format: \"namespace/name\" \\(e.g., \"hashicorp/aws\"\\)</p> <p></p>"},{"location":"api/#func-terraformclient-getmoduleversions","title":"func \\(\\*TerraformClient\\) GetModuleVersions","text":"<pre><code>func (c *TerraformClient) GetModuleVersions(ctx context.Context, source string) ([]ModuleVersion, error)\n</code></pre> <p>GetModuleVersions returns all available versions for a module. source format: \"namespace/name/provider\" \\(e.g., \"terraform\\-aws\\-modules/vpc/aws\"\\)</p>"},{"location":"api/#resolve","title":"resolve","text":"<pre><code>import \"github.com/santosr2/uptool/internal/resolve\"\n</code></pre> <p>Package resolve provides semantic version resolution and selection logic. It implements version constraint checking, policy-based version selection, and semantic version impact calculation \\(patch/minor/major\\).</p> <p>The package supports the following constraint syntaxes:</p> <ul> <li>Terraform-style: ~&gt; 5.0, &gt;= 1.0, = 1.2.3</li> <li>npm/Helm-style: ^1.2.3, ~1.2.3, &gt;=1.0.0</li> <li>Exact versions: 1.2.3</li> </ul> <p>Policy precedence is applied in this order:</p> <ol> <li>uptool.yaml policy \\(highest\\)</li> <li>CLI flags</li> <li>Manifest constraints \\(lowest\\)</li> </ol>"},{"location":"api/#index_7","title":"Index","text":"<ul> <li>func CompareVersions\\(v1, v2 string\\) \\(int, error\\)</li> <li>func IsValidSemver\\(version string\\) bool</li> <li>func SelectVersion\\(currentVersion string, availableVersions \\[\\]string, policy \\*engine.IntegrationPolicy\\) \\(string, engine.Impact, error\\)</li> <li>func SelectVersionWithContext\\(currentVersion string, constraint string, availableVersions \\[\\]string, planCtx \\*engine.PlanContext\\) \\(string, engine.Impact, error\\)</li> <li>type ConstraintType</li> <li>type ParsedConstraint</li> <li>func ParseConstraint\\(constraint string\\) *ParsedConstraint</li> <li>func \\(pc \\*ParsedConstraint\\) Allows\\(targetVersion string\\) bool</li> <li>func \\(pc \\*ParsedConstraint\\) AllowsImpact\\(impact engine.Impact\\) bool</li> </ul>"},{"location":"api/#func-compareversions","title":"func CompareVersions","text":"<pre><code>func CompareVersions(v1, v2 string) (int, error)\n</code></pre> <p>CompareVersions returns -1 if v1 \\&lt; v2, 0 if v1 == v2, 1 if v1 &gt; v2.</p> <p></p>"},{"location":"api/#func-isvalidsemver","title":"func IsValidSemver","text":"<pre><code>func IsValidSemver(version string) bool\n</code></pre> <p>IsValidSemver checks if a string is a valid semver version.</p> <p></p>"},{"location":"api/#func-selectversion","title":"func SelectVersion","text":"<pre><code>func SelectVersion(currentVersion string, availableVersions []string, policy *engine.IntegrationPolicy) (string, engine.Impact, error)\n</code></pre> <p>SelectVersion chooses the best version from a list based on policy. It filters versions by update strategy and prerelease policy, then returns the latest.</p> <p>Deprecated: Use SelectVersionWithContext for proper policy precedence support.</p> <p></p>"},{"location":"api/#func-selectversionwithcontext","title":"func SelectVersionWithContext","text":"<pre><code>func SelectVersionWithContext(currentVersion string, constraint string, availableVersions []string, planCtx *engine.PlanContext) (string, engine.Impact, error)\n</code></pre> <p>SelectVersionWithContext chooses the best version applying the full precedence chain: 1. CLI flags \\(highest precedence \\- if planCtx.CLIFlags.UpdateLevel is set, it overrides everything\\) 2. uptool.yaml policy \\(if policy.Update is set\\) 3. Manifest constraints \\(respects \\~\\&gt;, ^, \\&gt;= etc.\\)</p> <p>The constraint parameter should be the original constraint string from the manifest \\(e.g., \"\\~\\&gt; 5.0\", \"^1.2.3\", \"\\&gt;= 1.0\"\\). If empty, only policy filtering is applied.</p> <p></p>"},{"location":"api/#type-constrainttype","title":"type ConstraintType","text":"<p>ConstraintType represents the type of version constraint.</p> <pre><code>type ConstraintType string\n</code></pre> <p></p> <pre><code>const (\n    // ConstraintExact matches only the exact version (e.g., \"1.2.3\" or \"= 1.2.3\").\n    ConstraintExact ConstraintType = \"exact\"\n\n    // ConstraintPessimistic allows patch updates within a minor version (e.g., \"~&gt; 5.0\" allows 5.0.x to 5.x.x).\n    // In Terraform: ~&gt; 5.0 allows &gt;= 5.0, &lt; 6.0\n    // In npm/Helm: ~5.0 allows &gt;= 5.0.0, &lt; 5.1.0\n    ConstraintPessimistic ConstraintType = \"pessimistic\"\n\n    // ConstraintCaret allows minor and patch updates (e.g., \"^1.2.3\" allows 1.x.x).\n    // Commonly used in npm: ^1.2.3 allows &gt;= 1.2.3, &lt; 2.0.0\n    ConstraintCaret ConstraintType = \"caret\"\n\n    // ConstraintMinimum allows any version &gt;= the specified version (e.g., \"&gt;= 1.0\").\n    ConstraintMinimum ConstraintType = \"minimum\"\n\n    // ConstraintRange allows versions within a range (e.g., \"&gt;= 1.0, &lt; 2.0\").\n    ConstraintRange ConstraintType = \"range\"\n)\n</code></pre> <p></p>"},{"location":"api/#type-parsedconstraint","title":"type ParsedConstraint","text":"<p>ParsedConstraint represents a parsed version constraint.</p> <pre><code>type ParsedConstraint struct {\n    // Original is the original constraint string as found in the manifest.\n    Original string\n\n    // Type indicates the constraint type (exact, pessimistic, caret, minimum, range).\n    Type ConstraintType\n\n    // BaseVersion is the version number extracted from the constraint (without prefix).\n    BaseVersion string\n\n    // Constraint is the parsed semver constraint for validation.\n    // May be nil if the constraint couldn't be parsed as semver.\n    Constraint *semver.Constraints\n\n    // MaxAllowedImpact indicates the maximum update impact this constraint allows.\n    // For example, ~&gt; 5.0 allows \"minor\" (5.x), ^1.2.3 allows \"minor\" (1.x).\n    MaxAllowedImpact engine.Impact\n}\n</code></pre> <p></p>"},{"location":"api/#func-parseconstraint","title":"func ParseConstraint","text":"<pre><code>func ParseConstraint(constraint string) *ParsedConstraint\n</code></pre> <p>ParseConstraint parses a version constraint string and returns a structured representation. It supports various constraint syntaxes from different ecosystems \\(Terraform, npm, Helm\\).</p> <p></p>"},{"location":"api/#func-parsedconstraint-allows","title":"func \\(\\*ParsedConstraint\\) Allows","text":"<pre><code>func (pc *ParsedConstraint) Allows(targetVersion string) bool\n</code></pre> <p>Allows checks if the constraint allows updating to the given version.</p> <p></p>"},{"location":"api/#func-parsedconstraint-allowsimpact","title":"func \\(\\*ParsedConstraint\\) AllowsImpact","text":"<pre><code>func (pc *ParsedConstraint) AllowsImpact(impact engine.Impact) bool\n</code></pre> <p>AllowsImpact checks if the constraint allows updates of the given impact level.</p>"},{"location":"api/#rewrite","title":"rewrite","text":"<pre><code>import \"github.com/santosr2/uptool/internal/rewrite\"\n</code></pre> <p>Package rewrite provides utilities for rewriting structured files while preserving formatting. It includes functions for YAML manipulation, unified diff generation, and patch creation, enabling integrations to update configuration files without destroying formatting or comments.</p>"},{"location":"api/#index_8","title":"Index","text":"<ul> <li>func CountChanges\\(diff string\\) \\(additions, deletions int\\)</li> <li>func GeneratePatch\\(filename, oldContent, newContent string\\) \\(string, error\\)</li> <li>func GenerateUnifiedDiff\\(filename, oldContent, newContent string\\) \\(string, error\\)</li> <li>func ReplaceYAMLValue\\(content string, path \\[\\]string, oldValue, newValue string, matcher func\\(\\*yaml.Node\\) bool) \\(string, error\\)</li> <li>func UpdateYAMLField\\(content string, path \\[\\]string, newValue string\\) \\(string, error\\)</li> </ul>"},{"location":"api/#func-countchanges","title":"func CountChanges","text":"<pre><code>func CountChanges(diff string) (additions, deletions int)\n</code></pre> <p>CountChanges returns the number of additions and deletions in a diff.</p> <p></p>"},{"location":"api/#func-generatepatch","title":"func GeneratePatch","text":"<pre><code>func GeneratePatch(filename, oldContent, newContent string) (string, error)\n</code></pre> <p>GeneratePatch creates a git-style patch with timestamps.</p> <p></p>"},{"location":"api/#func-generateunifieddiff","title":"func GenerateUnifiedDiff","text":"<pre><code>func GenerateUnifiedDiff(filename, oldContent, newContent string) (string, error)\n</code></pre> <p>GenerateUnifiedDiff creates a unified diff between old and new content.</p> <p></p>"},{"location":"api/#func-replaceyamlvalue","title":"func ReplaceYAMLValue","text":"<pre><code>func ReplaceYAMLValue(content string, path []string, oldValue, newValue string, matcher func(*yaml.Node) bool) (string, error)\n</code></pre> <p>ReplaceYAMLValue replaces a specific value in a YAML document while preserving formatting. path specifies the location \\(e.g., \\[\"repos\", \"\\*\", \"rev\"\\]\\) where * matches any element. matcher is an optional function to further filter which nodes to update.</p> <p></p>"},{"location":"api/#func-updateyamlfield","title":"func UpdateYAMLField","text":"<pre><code>func UpdateYAMLField(content string, path []string, newValue string) (string, error)\n</code></pre> <p>UpdateYAMLField updates a specific field in a YAML document.</p>"},{"location":"api/#secureio","title":"secureio","text":"<pre><code>import \"github.com/santosr2/uptool/internal/secureio\"\n</code></pre> <p>Package secureio provides secure file I/O operations with path validation.</p>"},{"location":"api/#index_9","title":"Index","text":"<ul> <li>func Create\\(path string\\) \\(\\*os.File, error\\)</li> <li>func ReadFile\\(path string\\) \\(\\[\\]byte, error\\)</li> <li>func ValidateFilePath\\(path string\\) error</li> <li>func WriteFile\\(path string, data \\[\\]byte, perm os.FileMode\\) error</li> </ul>"},{"location":"api/#func-create","title":"func Create","text":"<pre><code>func Create(path string) (*os.File, error)\n</code></pre> <p>Create safely creates a file after validating the path</p> <p></p>"},{"location":"api/#func-readfile","title":"func ReadFile","text":"<pre><code>func ReadFile(path string) ([]byte, error)\n</code></pre> <p>ReadFile safely reads a file after validating the path</p> <p></p>"},{"location":"api/#func-validatefilepath_1","title":"func ValidateFilePath","text":"<pre><code>func ValidateFilePath(path string) error\n</code></pre> <p>ValidateFilePath validates that a file path is safe to read/write</p> <p></p>"},{"location":"api/#func-writefile","title":"func WriteFile","text":"<pre><code>func WriteFile(path string, data []byte, perm os.FileMode) error\n</code></pre> <p>WriteFile safely writes a file after validating the path</p>"},{"location":"api/#version","title":"version","text":"<pre><code>import \"github.com/santosr2/uptool/internal/version\"\n</code></pre> <p>Package version provides version information for uptool. The version is embedded from the VERSION file at the repository root.</p>"},{"location":"api/#index_10","title":"Index","text":"<ul> <li>func Get() string</li> </ul>"},{"location":"api/#func-get_2","title":"func Get","text":"<pre><code>func Get() string\n</code></pre> <p>Get returns the current uptool version.</p>"},{"location":"api/#cmd","title":"cmd","text":"<pre><code>import \"github.com/santosr2/uptool/cmd/uptool/cmd\"\n</code></pre> <p>Package cmd implements the command-line interface for uptool. It provides commands for scanning, planning, and updating dependency manifests across multiple ecosystems \\(npm, Helm, Terraform, pre\\-commit, asdf, mise, tflint\\).</p> <p>The CLI is built using Cobra and provides the following commands:</p> <ul> <li>scan: Discover all manifests in a repository</li> <li>plan: Generate an update plan showing available dependency updates</li> <li>update: Apply updates to manifest files</li> <li>list: List all supported integrations and their status</li> <li>completion: Generate shell completion scripts</li> </ul> <p>Global flags available across all commands:</p> <ul> <li>-v, --verbose: Enable verbose debug output</li> <li>-q, --quiet: Suppress informational output \\(errors only\\)</li> </ul> <p>Example usage:</p> <pre><code># Scan repository for manifests\nuptool scan\n\n# Generate update plan\nuptool plan\n\n# Apply updates (dry-run first)\nuptool update --dry-run --diff\nuptool update\n\n# Update only specific integrations\nuptool update --only=npm,helm\n</code></pre> <p>See individual command documentation for detailed usage and options.</p>"},{"location":"api/#index_11","title":"Index","text":"<ul> <li>func Execute() error</li> <li>func GetConfigPath() string</li> <li>func GetLogLevel() slog.Level</li> </ul>"},{"location":"api/#func-execute","title":"func Execute","text":"<pre><code>func Execute() error\n</code></pre> <p>Execute runs the root command</p> <p></p>"},{"location":"api/#func-getconfigpath","title":"func GetConfigPath","text":"<pre><code>func GetConfigPath() string\n</code></pre> <p>GetConfigPath returns the config file path from the --config flag. Returns empty string if not specified \\(indicating default behavior\\).</p> <p></p>"},{"location":"api/#func-getloglevel","title":"func GetLogLevel","text":"<pre><code>func GetLogLevel() slog.Level\n</code></pre> <p>GetLogLevel returns the current log level based on flags</p>"},{"location":"api/#actions","title":"actions","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/actions\"\n</code></pre> <p>Package actions implements the GitHub Actions integration for updating workflow files. It detects .github/workflows/*.yml files, parses action references \\(uses: owner/repo@ref\\), queries GitHub Releases for version updates, and rewrites workflow files while preserving YAML structure and comments.</p>"},{"location":"api/#index_12","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Job</li> <li>type Step</li> <li>type Workflow</li> </ul>"},{"location":"api/#type-integration_1","title":"type Integration","text":"<p>Integration implements GitHub Actions workflow updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new GitHub Actions integration.</p> <p></p>"},{"location":"api/#func-integration-apply","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting workflow files.</p> <p></p>"},{"location":"api/#func-integration-detect","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds GitHub Actions workflow files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for GitHub Actions.</p> <p></p>"},{"location":"api/#func-integration-validate","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the workflow file is valid YAML.</p> <p></p>"},{"location":"api/#type-job","title":"type Job","text":"<p>Job represents a job in a workflow.</p> <pre><code>type Job struct {\n    Name        string                 `yaml:\"name,omitempty\"`\n    RunsOn      interface{}            `yaml:\"runs-on,omitempty\"`\n    Steps       []Step                 `yaml:\"steps,omitempty\"`\n    Strategy    interface{}            `yaml:\"strategy,omitempty\"`\n    Permissions interface{}            `yaml:\"permissions,omitempty\"`\n    Env         map[string]string      `yaml:\"env,omitempty\"`\n    Needs       interface{}            `yaml:\"needs,omitempty\"`\n    If          string                 `yaml:\"if,omitempty\"`\n    Raw         map[string]interface{} `yaml:\",inline\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-step","title":"type Step","text":"<p>Step represents a step in a job.</p> <pre><code>type Step struct {\n    Name            string                 `yaml:\"name,omitempty\"`\n    Uses            string                 `yaml:\"uses,omitempty\"`\n    Run             string                 `yaml:\"run,omitempty\"`\n    With            map[string]interface{} `yaml:\"with,omitempty\"`\n    Env             map[string]string      `yaml:\"env,omitempty\"`\n    If              string                 `yaml:\"if,omitempty\"`\n    ID              string                 `yaml:\"id,omitempty\"`\n    ContinueOnError interface{}            `yaml:\"continue-on-error,omitempty\"`\n    Raw             map[string]interface{} `yaml:\",inline\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-workflow","title":"type Workflow","text":"<p>Workflow represents the structure of a GitHub Actions workflow file.</p> <pre><code>type Workflow struct {\n    Name string                 `yaml:\"name,omitempty\"`\n    On   interface{}            `yaml:\"on,omitempty\"`\n    Jobs map[string]Job         `yaml:\"jobs,omitempty\"`\n    Raw  map[string]interface{} `yaml:\",inline\"`\n}\n</code></pre>"},{"location":"api/#all","title":"all","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/all\"\n</code></pre> <p>Package all imports all integration packages to trigger their self-registration. Import this package with a blank identifier to enable all integrations:</p> <pre><code>import _ \"github.com/santosr2/uptool/internal/integrations/all\"\n</code></pre>"},{"location":"api/#index_13","title":"Index","text":""},{"location":"api/#asdf","title":"asdf","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/asdf\"\n</code></pre> <p>Package asdf provides integration for asdf tool version manager. It detects and updates .tool-versions files.</p> <p>Status: EXPERIMENTAL - Version resolution not yet implemented</p>"},{"location":"api/#index_14","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-integration_2","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for asdf.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_1","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new asdf integration.</p> <p></p>"},{"location":"api/#func-integration-apply_1","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply applies updates to asdf manifest files.</p> <p>Note: Apply is not implemented for asdf. Use native asdf commands instead:</p> <ul> <li>asdf plugin update --all # Update all plugins</li> <li>asdf install \\&lt;tool&gt; latest # Install latest version of a tool</li> </ul> <p>To manually update versions in .tool-versions:</p> <ol> <li>Check available versions: asdf list all \\&lt;tool&gt;</li> <li>Edit .tool-versions with desired versions</li> <li>Install: asdf install</li> </ol> <p></p>"},{"location":"api/#func-integration-detect_1","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect scans for .tool-versions files.</p> <p></p>"},{"location":"api/#func-integration-name_1","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_1","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for asdf tools.</p> <p>Note: asdf integration is experimental. Version resolution is not implemented because each tool \\(.tool\\-versions can contain nodejs, python, ruby, terraform, etc.\\) has its own registry and update mechanism. This would require datasources for every possible runtime.</p> <p>Recommended approach: Use native asdf commands:</p> <ul> <li>asdf plugin update --all # Update plugin versions</li> <li>asdf latest --all # Show latest versions</li> <li>asdf install \\&lt;tool&gt; latest # Install latest version</li> </ul> <p>Future enhancement: Could implement version checking via tool-specific datasources \\(npm registry, python.org, ruby gems, etc.\\) or by calling asdf native commands.</p> <p>The planCtx parameter is accepted for interface compatibility but not currently used.</p> <p></p>"},{"location":"api/#func-integration-validate_1","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate validates an asdf manifest.</p>"},{"location":"api/#docker","title":"docker","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/docker\"\n</code></pre> <p>Package docker implements the Docker integration for updating Dockerfile and docker-compose files. It detects Dockerfile and docker-compose.yml files, parses image references \\(FROM image:tag\\), queries Docker Hub for version updates, and rewrites files while preserving structure.</p>"},{"location":"api/#index_15","title":"Index","text":"<ul> <li>type ComposeFile</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Service</li> </ul>"},{"location":"api/#type-composefile","title":"type ComposeFile","text":"<p>ComposeFile represents the structure of a docker-compose.yml file.</p> <pre><code>type ComposeFile struct {\n    Version  string                 `yaml:\"version,omitempty\"`\n    Services map[string]Service     `yaml:\"services,omitempty\"`\n    Raw      map[string]interface{} `yaml:\",inline\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_3","title":"type Integration","text":"<p>Integration implements Docker file updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_2","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new Docker integration.</p> <p></p>"},{"location":"api/#func-integration-apply_2","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting Docker files.</p> <p></p>"},{"location":"api/#func-integration-detect_2","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds Dockerfile and docker-compose files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_2","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_2","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for Docker images.</p> <p></p>"},{"location":"api/#func-integration-validate_2","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the Docker file is valid.</p> <p></p>"},{"location":"api/#type-service","title":"type Service","text":"<p>Service represents a service in docker-compose.</p> <pre><code>type Service struct {\n    Image       string                 `yaml:\"image,omitempty\"`\n    Build       interface{}            `yaml:\"build,omitempty\"`\n    Environment interface{}            `yaml:\"environment,omitempty\"`\n    Ports       []string               `yaml:\"ports,omitempty\"`\n    Volumes     []string               `yaml:\"volumes,omitempty\"`\n    DependsOn   interface{}            `yaml:\"depends_on,omitempty\"`\n    Raw         map[string]interface{} `yaml:\",inline\"`\n}\n</code></pre>"},{"location":"api/#gomod","title":"gomod","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/gomod\"\n</code></pre> <p>Package gomod implements the Go modules integration for updating go.mod dependencies. It detects go.mod files, queries the Go module proxy for version updates, and rewrites dependency versions while preserving the go.mod format.</p>"},{"location":"api/#index_16","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-integration_4","title":"type Integration","text":"<p>Integration implements Go modules go.mod updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_3","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new gomod integration.</p> <p></p>"},{"location":"api/#func-integration-apply_3","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update plan by rewriting go.mod.</p> <p></p>"},{"location":"api/#func-integration-detect_3","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds go.mod files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_3","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_3","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for Go module dependencies. It applies policy precedence: CLI flags &gt; uptool.yaml &gt; manifest constraints.</p> <p></p>"},{"location":"api/#func-integration-validate_3","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if go.mod is valid.</p>"},{"location":"api/#helm","title":"helm","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/helm\"\n</code></pre> <p>Package helm implements the Helm chart integration for updating Chart.yaml dependencies. It detects Chart.yaml files, queries Helm chart repositories for version updates, and rewrites chart dependency versions while preserving YAML structure.</p>"},{"location":"api/#index_17","title":"Index","text":"<ul> <li>type Chart</li> <li>type Dependency</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-chart","title":"type Chart","text":"<p>Chart represents the structure of Chart.yaml.</p> <pre><code>type Chart struct {\n    Raw          map[string]any `yaml:\",inline\"`\n    APIVersion   string         `yaml:\"apiVersion\"`\n    Name         string         `yaml:\"name\"`\n    Description  string         `yaml:\"description\"`\n    Type         string         `yaml:\"type\"`\n    Version      string         `yaml:\"version\"`\n    AppVersion   string         `yaml:\"appVersion\"`\n    Dependencies []Dependency   `yaml:\"dependencies,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-dependency_1","title":"type Dependency","text":"<p>Dependency represents a chart dependency.</p> <pre><code>type Dependency struct {\n    Name       string `yaml:\"name\"`\n    Version    string `yaml:\"version\"`\n    Repository string `yaml:\"repository\"`\n    Condition  string `yaml:\"condition,omitempty\"`\n    Tags       string `yaml:\"tags,omitempty\"`\n    Alias      string `yaml:\"alias,omitempty\"`\n    Enabled    bool   `yaml:\"enabled,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_5","title":"type Integration","text":"<p>Integration implements helm chart updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_4","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new helm integration.</p> <p></p>"},{"location":"api/#func-integration-apply_4","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting Chart.yaml.</p> <p></p>"},{"location":"api/#func-integration-detect_4","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds Chart.yaml files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_4","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_4","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for helm chart dependencies. It applies policy precedence: CLI flags &gt; uptool.yaml &gt; manifest constraints.</p> <p>The planCtx parameter provides the policy context. If nil, default behavior is used \\(respect constraints only\\).</p> <p></p>"},{"location":"api/#func-integration-validate_4","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the Chart.yaml is valid.</p>"},{"location":"api/#mise","title":"mise","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/mise\"\n</code></pre> <p>Package mise provides integration for mise tool version manager. It detects and updates mise.toml, .mise.toml, and optionally .tool-versions files. mise is backward-compatible with asdf's .tool-versions format.</p> <p>Status: EXPERIMENTAL - Version resolution not yet implemented</p>"},{"location":"api/#index_18","title":"Index","text":"<ul> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> </ul>"},{"location":"api/#type-config_2","title":"type Config","text":"<p>Config represents the structure of a mise.toml file.</p> <pre><code>type Config struct {\n    Tools map[string]interface{} `toml:\"tools\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_6","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for mise.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_5","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new mise integration.</p> <p></p>"},{"location":"api/#func-integration-apply_5","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply applies updates to mise manifest files.</p> <p>Note: Apply is not implemented for mise. Use native mise commands instead:</p> <ul> <li>mise upgrade # Upgrade all tools to latest</li> <li>mise use \\&lt;tool&gt;@latest # Pin specific tool to latest</li> </ul> <p>To manually update versions in mise.toml or .mise.toml:</p> <ol> <li>Check available versions: mise ls-remote \\&lt;tool&gt;</li> <li>Edit mise.toml with desired versions</li> <li>Install: mise install</li> </ol> <p></p>"},{"location":"api/#func-integration-detect_5","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect scans for mise.toml and .mise.toml files.</p> <p></p>"},{"location":"api/#func-integration-name_5","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_5","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for mise tools.</p> <p>Note: mise integration is experimental. Version resolution is not implemented because each tool \\(mise.toml can contain nodejs, python, ruby, terraform, etc.\\) has its own registry and update mechanism. This would require datasources for every possible runtime.</p> <p>Recommended approach: Use native mise commands:</p> <ul> <li>mise upgrade # Upgrade all tools to latest versions</li> <li>mise outdated # Show outdated tools</li> <li>mise use \\&lt;tool&gt;@latest # Pin to latest version</li> </ul> <p>Future enhancement: Could implement version checking via tool-specific datasources \\(npm registry, python.org, ruby gems, etc.\\) or by calling mise native commands.</p> <p>The planCtx parameter is accepted for interface compatibility but not currently used.</p> <p></p>"},{"location":"api/#func-integration-validate_5","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate validates a mise manifest.</p>"},{"location":"api/#npm","title":"npm","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/npm\"\n</code></pre> <p>Package npm implements the npm integration for updating package.json dependencies. It detects package.json files, queries the npm registry for version updates, and rewrites dependency versions while preserving constraint prefixes \\(^, \\~, \\&gt;=\\).</p>"},{"location":"api/#index_19","title":"Index","text":"<ul> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type PackageJSON</li> </ul>"},{"location":"api/#type-integration_7","title":"type Integration","text":"<p>Integration implements npm package.json updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_6","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new npm integration.</p> <p></p>"},{"location":"api/#func-integration-apply_6","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update plan by rewriting package.json.</p> <p></p>"},{"location":"api/#func-integration-detect_6","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds package.json files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_6","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_6","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for npm dependencies. It applies policy precedence: CLI flags &gt; uptool.yaml &gt; manifest constraints.</p> <p>The planCtx parameter provides the policy context. If nil, default behavior is used \\(respect constraints only\\).</p> <p></p>"},{"location":"api/#func-integration-validate_6","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate runs npm validation \\(optional\\).</p> <p></p>"},{"location":"api/#type-packagejson","title":"type PackageJSON","text":"<p>PackageJSON represents the structure of package.json.</p> <pre><code>type PackageJSON struct {\n    Dependencies         map[string]string `json:\"dependencies,omitempty\"`\n    DevDependencies      map[string]string `json:\"devDependencies,omitempty\"`\n    PeerDependencies     map[string]string `json:\"peerDependencies,omitempty\"`\n    OptionalDependencies map[string]string `json:\"optionalDependencies,omitempty\"`\n    Name                 string            `json:\"name,omitempty\"`\n    Version              string            `json:\"version,omitempty\"`\n}\n</code></pre>"},{"location":"api/#precommit","title":"precommit","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/precommit\"\n</code></pre> <p>Package precommit implements the pre-commit integration using the native autoupdate command. It detects .pre-commit-config.yaml files, runs 'pre-commit autoupdate' to update hook versions, and parses the output to report changes. This follows the manifest-first philosophy by using the native tool that directly updates the configuration file.</p>"},{"location":"api/#index_20","title":"Index","text":"<ul> <li>type Config</li> <li>type Hook</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Repo</li> </ul>"},{"location":"api/#type-config_3","title":"type Config","text":"<p>Config represents the structure of .pre-commit-config.yaml.</p> <pre><code>type Config struct {\n    Repos []Repo `yaml:\"repos\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-hook","title":"type Hook","text":"<p>Hook represents a pre-commit hook.</p> <pre><code>type Hook struct {\n    ID string `yaml:\"id\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_8","title":"type Integration","text":"<p>Integration implements pre-commit hook updates using native autoupdate command.</p> <pre><code>type Integration struct{}\n</code></pre> <p></p>"},{"location":"api/#func-new_7","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new pre-commit integration.</p> <p></p>"},{"location":"api/#func-integration-apply_7","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update using native pre-commit autoupdate command.</p> <p></p>"},{"location":"api/#func-integration-detect_7","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .pre-commit-config.yaml files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_7","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_7","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for pre-commit hooks. For pre-commit, we use the native autoupdate command in dry-run mode.</p> <p>Note: The pre-commit native command doesn't support policy-based filtering. The planCtx parameter is accepted for interface compatibility but not currently used. Future versions may implement policy filtering by parsing the autoupdate output.</p> <p></p>"},{"location":"api/#func-integration-validate_7","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate runs pre-commit validate-config.</p> <p></p>"},{"location":"api/#type-repo","title":"type Repo","text":"<p>Repo represents a pre-commit repository.</p> <pre><code>type Repo struct {\n    Repo  string `yaml:\"repo\"`\n    Rev   string `yaml:\"rev\"`\n    Hooks []Hook `yaml:\"hooks,omitempty\"`\n}\n</code></pre>"},{"location":"api/#terraform","title":"terraform","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/terraform\"\n</code></pre> <p>Package terraform implements the Terraform integration for updating module versions in .tf files. It detects Terraform configuration files, parses HCL to extract module and provider versions, queries the Terraform Registry for updates, and rewrites versions while preserving HCL formatting.</p>"},{"location":"api/#index_21","title":"Index","text":"<ul> <li>type Block</li> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type ModuleBlock</li> <li>type ProviderBlock</li> <li>type RequiredProvidersBlock</li> </ul>"},{"location":"api/#type-block","title":"type Block","text":"<p>Block represents a terraform configuration block.</p> <pre><code>type Block struct {\n    Remain            hcl.Body                `hcl:\",remain\"`\n    RequiredProviders *RequiredProvidersBlock `hcl:\"required_providers,block\"`\n    RequiredVersion   string                  `hcl:\"required_version,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-config_4","title":"type Config","text":"<p>Config represents terraform configuration structure.</p> <pre><code>type Config struct {\n    Remain    hcl.Body        `hcl:\",remain\"`\n    Terraform []Block         `hcl:\"terraform,block\"`\n    Modules   []ModuleBlock   `hcl:\"module,block\"`\n    Providers []ProviderBlock `hcl:\"provider,block\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_9","title":"type Integration","text":"<p>Integration implements terraform configuration updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_8","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new terraform integration.</p> <p></p>"},{"location":"api/#func-integration-apply_8","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting terraform files.</p> <p></p>"},{"location":"api/#func-integration-detect_8","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .tf files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_8","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_8","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for terraform providers and modules. It applies policy precedence: CLI flags &gt; uptool.yaml &gt; manifest constraints.</p> <p>The planCtx parameter provides the policy context. If nil, default behavior is used \\(respect constraints only\\).</p> <p></p>"},{"location":"api/#func-integration-validate_8","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the terraform configuration is valid.</p> <p></p>"},{"location":"api/#type-moduleblock","title":"type ModuleBlock","text":"<p>ModuleBlock represents a module block.</p> <pre><code>type ModuleBlock struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Source  string   `hcl:\"source,optional\"`\n    Version string   `hcl:\"version,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-providerblock","title":"type ProviderBlock","text":"<p>ProviderBlock represents a provider block.</p> <pre><code>type ProviderBlock struct {\n    Remain hcl.Body `hcl:\",remain\"`\n    Name   string   `hcl:\"name,label\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-requiredprovidersblock","title":"type RequiredProvidersBlock","text":"<p>RequiredProvidersBlock represents the required_providers block.</p> <pre><code>type RequiredProvidersBlock struct {\n    Body hcl.Body `hcl:\",remain\"`\n}\n</code></pre>"},{"location":"api/#tflint","title":"tflint","text":"<pre><code>import \"github.com/santosr2/uptool/internal/integrations/tflint\"\n</code></pre> <p>Package tflint implements the tflint integration for updating plugin versions in .tflint.hcl files. It detects tflint configuration files, parses HCL to extract plugin versions, queries GitHub Releases for plugin updates, and rewrites versions while preserving HCL formatting.</p>"},{"location":"api/#index_22","title":"Index","text":"<ul> <li>type Config</li> <li>type Integration</li> <li>func New() *Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type Plugin</li> <li>type Rule</li> </ul>"},{"location":"api/#type-config_5","title":"type Config","text":"<p>Config represents .tflint.hcl structure.</p> <pre><code>type Config struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Plugins []Plugin `hcl:\"plugin,block\"`\n    Rules   []Rule   `hcl:\"rule,block\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-integration_10","title":"type Integration","text":"<p>Integration implements tflint configuration updates.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-new_9","title":"func New","text":"<pre><code>func New() *Integration\n</code></pre> <p>New creates a new tflint integration.</p> <p></p>"},{"location":"api/#func-integration-apply_9","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update by rewriting the HCL file.</p> <p></p>"},{"location":"api/#func-integration-detect_9","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds .tflint.hcl files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_9","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_9","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan determines available updates for tflint plugins. It applies policy precedence: CLI flags &gt; uptool.yaml &gt; manifest constraints.</p> <p>The planCtx parameter provides the policy context. If nil, default behavior is used \\(respect constraints only\\).</p> <p></p>"},{"location":"api/#func-integration-validate_9","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if the HCL file is valid.</p> <p></p>"},{"location":"api/#type-plugin","title":"type Plugin","text":"<p>Plugin represents a tflint plugin block.</p> <pre><code>type Plugin struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Version string   `hcl:\"version,optional\"`\n    Source  string   `hcl:\"source,optional\"`\n    Enabled bool     `hcl:\"enabled,optional\"`\n}\n</code></pre> <p></p>"},{"location":"api/#type-rule","title":"type Rule","text":"<p>Rule represents a tflint rule block.</p> <pre><code>type Rule struct {\n    Remain  hcl.Body `hcl:\",remain\"`\n    Name    string   `hcl:\"name,label\"`\n    Enabled bool     `hcl:\"enabled,optional\"`\n}\n</code></pre>"},{"location":"api/#guards","title":"guards","text":"<pre><code>import \"github.com/santosr2/uptool/internal/policy/guards\"\n</code></pre> <p>Package guards provides an extensible plugin system for auto-merge guards.</p>"},{"location":"api/#overview_1","title":"Overview","text":"<p>Guards are pluggable checks that determine whether a Pull Request is ready for auto-merge. uptool provides built-in guards \\(ci\\-green, codeowners\\-approve, security\\-scan\\) and supports custom user-defined guards via the Guard interface.</p>"},{"location":"api/#architecture","title":"Architecture","text":"<p>The guard system consists of three main components:</p> <ol> <li>Guard Interface - defines the contract for all guards</li> <li>Registry - manages guard registration and lookup</li> <li>Environment - provides GitHub context to guards</li> </ol>"},{"location":"api/#built-in-guards","title":"Built\\-in Guards","text":"<p>uptool includes three production-ready guards:</p> <ul> <li>ci-green: Verifies all CI checks pass \\(SUCCESS or SKIPPED\\)</li> <li>codeowners-approve: Requires approval from repository CODEOWNERS</li> <li>security-scan: Ensures security scans \\(CodeQL, Trivy, SAST\\) pass</li> </ul> <p>Built-in guards are automatically registered via init() functions in the builtin package \\(internal/policy/guards/builtin/\\).</p>"},{"location":"api/#custom-guards","title":"Custom Guards","text":"<p>To create a custom guard:</p> <ol> <li>Implement the Guard interface \\(Name, Description, Check methods\\)</li> <li>Register the guard via init() function: guards.Register\\(&amp;MyGuard\\{\\}\\)</li> <li>Import the guard package in your application</li> <li>Add the guard name to org_policy.auto_merge.guards in uptool.yaml</li> </ol> <p>Example custom guard:</p> <pre><code>type MyGuard struct{}\n\nfunc init() {\n    guards.Register(&amp;MyGuard{})\n}\n\nfunc (g *MyGuard) Name() string {\n    return \"my-custom-guard\"\n}\n\nfunc (g *MyGuard) Description() string {\n    return \"Checks my custom approval workflow\"\n}\n\nfunc (g *MyGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {\n    // Custom logic here - query APIs, check files, etc.\n    return true, nil\n}\n</code></pre>"},{"location":"api/#code-generation","title":"Code Generation","text":"<p>The guard registry file \\(internal/policy/guards/builtin/all.go\\) is automatically generated by scripts/gen_guards.go. Run `go generate` to regenerate after adding new built-in guards.</p> <p>See docs/guards.md for comprehensive documentation on creating custom guards.</p>"},{"location":"api/#index_23","title":"Index","text":"<ul> <li>func CheckGuard\\(ctx context.Context, name string, env \\*Environment\\) \\(bool, error\\)</li> <li>func List() []string</li> <li>func Register\\(guard Guard\\)</li> <li>type Environment</li> <li>type Guard</li> <li>func Get\\(name string\\) \\(Guard, bool\\)</li> <li>type Registry</li> <li>func \\(r \\*Registry\\) CheckGuard\\(ctx context.Context, name string, env \\*Environment\\) \\(bool, error\\)</li> <li>func \\(r \\*Registry\\) Get\\(name string\\) \\(Guard, bool\\)</li> <li>func \\(r \\*Registry\\) List() []string</li> <li>func \\(r \\*Registry\\) Register\\(guard Guard\\)</li> </ul>"},{"location":"api/#func-checkguard","title":"func CheckGuard","text":"<pre><code>func CheckGuard(ctx context.Context, name string, env *Environment) (bool, error)\n</code></pre> <p>CheckGuard executes a guard check by name using the global registry.</p> <p>This is a convenience function that looks up the guard and executes its Check method. Returns an error if the guard is not found.</p> <p>Returns:</p> <ul> <li>true, nil: Guard found and satisfied</li> <li>false, nil: Guard found but not satisfied</li> <li>false, error: Guard not found or check failed</li> </ul> <p></p>"},{"location":"api/#func-list_2","title":"func List","text":"<pre><code>func List() []string\n</code></pre> <p>List returns all registered guard names from the global registry.</p> <p>The returned slice is a snapshot of registered guard names at the time of the call. The order is not guaranteed.</p> <p>This is useful for displaying available guards to users or debugging.</p> <p></p>"},{"location":"api/#func-register_2","title":"func Register","text":"<pre><code>func Register(guard Guard)\n</code></pre> <p>Register adds a guard to the global registry.</p> <p>This function is typically called from init() functions to self-register guards:</p> <pre><code>func init() {\n    guards.Register(&amp;MyCustomGuard{})\n}\n</code></pre> <p>Panics if a guard with the same name is already registered, as duplicate guard names indicate a programming error.</p> <p></p>"},{"location":"api/#type-environment","title":"type Environment","text":"<p>Environment contains the GitHub context for guard checks.</p> <p>This struct is passed to all Guard.Check() calls and provides the necessary information to query GitHub APIs or other systems about the PR.</p> <p>All fields are guaranteed to be populated and validated before being passed to guards.</p> <pre><code>type Environment struct {\n    // GitHubRepo is the repository in \"owner/repo\" format (e.g., \"santosr2/uptool\").\n    GitHubRepo string\n\n    // GitHubToken is a GitHub API token with permissions to access the repository.\n    // Typically has repo scope for private repos or public_repo for public repos.\n    GitHubToken string\n\n    // GitHubPRNumber is the pull request number as a string.\n    // Guaranteed to be a valid numeric string (e.g., \"42\", \"123\").\n    GitHubPRNumber string\n}\n</code></pre> <p></p>"},{"location":"api/#type-guard","title":"type Guard","text":"<p>Guard represents a pluggable auto-merge guard check.</p> <p>Guards determine whether a Pull Request meets the criteria for auto-merge. They can be built-in \\(ci\\-green, codeowners\\-approve, security\\-scan\\) or custom user-defined plugins.</p> <p>All guards must be thread-safe as they may be executed concurrently.</p> <pre><code>type Guard interface {\n    // Name returns the unique identifier for this guard.\n    //\n    // The name is used in configuration (org_policy.auto_merge.guards) and\n    // must be globally unique across all registered guards.\n    //\n    // Examples: \"ci-green\", \"codeowners-approve\", \"slack-approval\"\n    Name() string\n\n    // Description returns a human-readable description of what this guard checks.\n    //\n    // The description is shown in help text and error messages to help users\n    // understand what the guard does and why it might be failing.\n    //\n    // Example: \"Verifies that all CI checks pass (SUCCESS or SKIPPED)\"\n    Description() string\n\n    // Check executes the guard check and returns true if the guard is satisfied.\n    //\n    // The context can be used for cancellation and timeout control. Guards should\n    // respect context cancellation to avoid blocking during shutdown.\n    //\n    // The environment provides GitHub context (repo, PR number, API token) that\n    // most guards need to query the GitHub API or related services.\n    //\n    // Returns:\n    //   - true, nil: Guard is satisfied (PR can be auto-merged)\n    //   - false, nil: Guard is not satisfied (PR should not be auto-merged)\n    //   - false, error: Guard check failed (treat as not satisfied)\n    //\n    // Guards should return descriptive errors to help with debugging.\n    Check(ctx context.Context, env *Environment) (bool, error)\n}\n</code></pre> <p></p>"},{"location":"api/#func-get_3","title":"func Get","text":"<pre><code>func Get(name string) (Guard, bool)\n</code></pre> <p>Get retrieves a guard by name from the global registry.</p> <p>Returns the guard and true if found, or nil and false if not registered.</p> <p>This function is thread-safe and can be called concurrently.</p> <p></p>"},{"location":"api/#type-registry_1","title":"type Registry","text":"<p>Registry manages registered guards \\(both built\\-in and custom\\).</p> <p>The registry provides thread-safe registration and lookup of guards. Guards are registered via init() functions and looked up by name during policy checks.</p> <pre><code>type Registry struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-registry-checkguard","title":"func \\(\\*Registry\\) CheckGuard","text":"<pre><code>func (r *Registry) CheckGuard(ctx context.Context, name string, env *Environment) (bool, error)\n</code></pre> <p>CheckGuard executes a guard check by name using this registry.</p> <p>Looks up the guard by name and executes its Check method with the provided context and environment.</p> <p></p>"},{"location":"api/#func-registry-get","title":"func \\(\\*Registry\\) Get","text":"<pre><code>func (r *Registry) Get(name string) (Guard, bool)\n</code></pre> <p>Get retrieves a guard by name from this registry.</p> <p>Returns the guard and true if found, or nil and false if not registered.</p> <p></p>"},{"location":"api/#func-registry-list","title":"func \\(\\*Registry\\) List","text":"<pre><code>func (r *Registry) List() []string\n</code></pre> <p>List returns all registered guard names from this registry.</p> <p>Returns a new slice containing all registered guard names.</p> <p></p>"},{"location":"api/#func-registry-register","title":"func \\(\\*Registry\\) Register","text":"<pre><code>func (r *Registry) Register(guard Guard)\n</code></pre> <p>Register adds a guard to this registry.</p> <p>Panics if a guard with the same name is already registered. This is the underlying implementation used by the package-level Register function.</p>"},{"location":"api/#custom","title":"custom","text":"<pre><code>import \"github.com/santosr2/uptool/examples/plugins/guards/custom\"\n</code></pre> <p>Package custom provides example custom guard implementations. This demonstrates how to create custom guards that extend uptool's auto-merge capabilities.</p>"},{"location":"api/#index_24","title":"Index","text":"<ul> <li>type SlackApprovalGuard</li> <li>func \\(g \\*SlackApprovalGuard\\) Check\\(ctx context.Context, env \\*guards.Environment\\) \\(bool, error\\)</li> <li>func \\(g \\*SlackApprovalGuard\\) Description() string</li> <li>func \\(g \\*SlackApprovalGuard\\) Name() string</li> </ul>"},{"location":"api/#type-slackapprovalguard","title":"type SlackApprovalGuard","text":"<p>SlackApprovalGuard checks if the PR has been approved via Slack reaction. This is an example custom guard that demonstrates: - Using external APIs \\(Slack\\) - Reading custom environment variables - Implementing custom approval workflows</p> <pre><code>type SlackApprovalGuard struct{}\n</code></pre> <p></p>"},{"location":"api/#func-slackapprovalguard-check","title":"func \\(\\*SlackApprovalGuard\\) Check","text":"<pre><code>func (g *SlackApprovalGuard) Check(ctx context.Context, env *guards.Environment) (bool, error)\n</code></pre> <p>Check verifies that the PR has Slack approval via thumbs-up reaction.</p> <p></p>"},{"location":"api/#func-slackapprovalguard-description","title":"func \\(\\*SlackApprovalGuard\\) Description","text":"<pre><code>func (g *SlackApprovalGuard) Description() string\n</code></pre> <p>Description returns a human-readable description of the guard.</p> <p></p>"},{"location":"api/#func-slackapprovalguard-name","title":"func \\(\\*SlackApprovalGuard\\) Name","text":"<pre><code>func (g *SlackApprovalGuard) Name() string\n</code></pre> <p>Name returns the guard's unique identifier.</p>"},{"location":"api/#python","title":"python","text":"<pre><code>import \"github.com/santosr2/uptool/examples/plugins/python\"\n</code></pre> <p>Package main implements an uptool plugin for Python requirements.txt dependencies. This plugin demonstrates the external plugin architecture for uptool.</p>"},{"location":"api/#index_25","title":"Index","text":"<ul> <li>func New() engine.Integration</li> <li>func ParseRequirements\\(content string\\) \\(\\[\\]\\*engine.Dependency, error\\)</li> <li>func RegisterWith\\(register func\\(name string, constructor func\\(\\) engine.Integration))</li> <li>type Integration</li> <li>func \\(i \\*Integration\\) Apply\\(ctx context.Context, plan \\*engine.UpdatePlan\\) \\(\\*engine.ApplyResult, error\\)</li> <li>func \\(i \\*Integration\\) Detect\\(ctx context.Context, repoRoot string\\) \\(\\[\\]\\*engine.Manifest, error\\)</li> <li>func \\(i \\*Integration\\) Name() string</li> <li>func \\(i \\*Integration\\) Plan\\(ctx context.Context, manifest \\*engine.Manifest, planCtx \\*engine.PlanContext\\) \\(\\*engine.UpdatePlan, error\\)</li> <li>func \\(i \\*Integration\\) Validate\\(ctx context.Context, manifest \\*engine.Manifest\\) error</li> <li>type PyPIClient</li> <li>func NewPyPIClient() *PyPIClient</li> <li>func \\(c \\*PyPIClient\\) GetLatestVersion\\(ctx context.Context, packageName string\\) \\(string, error\\)</li> <li>type PyPIResponse</li> </ul>"},{"location":"api/#func-new_10","title":"func New","text":"<pre><code>func New() engine.Integration\n</code></pre> <p>New creates a new Python integration instance.</p> <p></p>"},{"location":"api/#func-parserequirements","title":"func ParseRequirements","text":"<pre><code>func ParseRequirements(content string) ([]*engine.Dependency, error)\n</code></pre> <p>ParseRequirements parses a requirements.txt file and extracts dependencies. It handles: - Simple version pins \\(package==1.0.0\\) - Version constraints \\(package\\&gt;=1.0.0\\) - Comments \\(\\# comment\\) - Blank lines - Extras \\(package\\[extra\\]==1.0.0\\)</p> <p></p>"},{"location":"api/#func-registerwith","title":"func RegisterWith","text":"<pre><code>func RegisterWith(register func(name string, constructor func() engine.Integration))\n</code></pre> <p>RegisterWith is called by uptool to register this plugin's integrations. This function MUST be exported and have this exact signature for the plugin to work.</p> <p>uptool will call this function and pass its Register function, which the plugin should call to register each integration it provides.</p> <p></p>"},{"location":"api/#type-integration_11","title":"type Integration","text":"<p>Integration implements the engine.Integration interface for Python requirements.txt.</p> <pre><code>type Integration struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-integration-apply_10","title":"func \\(\\*Integration\\) Apply","text":"<pre><code>func (i *Integration) Apply(ctx context.Context, plan *engine.UpdatePlan) (*engine.ApplyResult, error)\n</code></pre> <p>Apply executes the update plan by rewriting requirements.txt.</p> <p></p>"},{"location":"api/#func-integration-detect_10","title":"func \\(\\*Integration\\) Detect","text":"<pre><code>func (i *Integration) Detect(ctx context.Context, repoRoot string) ([]*engine.Manifest, error)\n</code></pre> <p>Detect finds requirements.txt files in the repository.</p> <p></p>"},{"location":"api/#func-integration-name_10","title":"func \\(\\*Integration\\) Name","text":"<pre><code>func (i *Integration) Name() string\n</code></pre> <p>Name returns the integration identifier.</p> <p></p>"},{"location":"api/#func-integration-plan_10","title":"func \\(\\*Integration\\) Plan","text":"<pre><code>func (i *Integration) Plan(ctx context.Context, manifest *engine.Manifest, planCtx *engine.PlanContext) (*engine.UpdatePlan, error)\n</code></pre> <p>Plan generates an update plan for a requirements.txt file.</p> <p></p>"},{"location":"api/#func-integration-validate_10","title":"func \\(\\*Integration\\) Validate","text":"<pre><code>func (i *Integration) Validate(ctx context.Context, manifest *engine.Manifest) error\n</code></pre> <p>Validate checks if a requirements.txt file is valid.</p> <p></p>"},{"location":"api/#type-pypiclient","title":"type PyPIClient","text":"<p>PyPIClient queries the PyPI JSON API for package information.</p> <pre><code>type PyPIClient struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/#func-newpypiclient","title":"func NewPyPIClient","text":"<pre><code>func NewPyPIClient() *PyPIClient\n</code></pre> <p>NewPyPIClient creates a new PyPI client.</p> <p></p>"},{"location":"api/#func-pypiclient-getlatestversion","title":"func \\(\\*PyPIClient\\) GetLatestVersion","text":"<pre><code>func (c *PyPIClient) GetLatestVersion(ctx context.Context, packageName string) (string, error)\n</code></pre> <p>GetLatestVersion fetches the latest stable version for a package from PyPI.</p> <p></p>"},{"location":"api/#type-pypiresponse","title":"type PyPIResponse","text":"<p>PyPIResponse represents the PyPI JSON API response.</p> <pre><code>type PyPIResponse struct {\n    Info struct {\n        Name    string `json:\"name\"`\n        Version string `json:\"version\"`\n    }   `json:\"info\"`\n    Releases map[string][]struct {\n        Yanked bool `json:\"yanked\"`\n    }   `json:\"releases\"`\n}\n</code></pre>"},{"location":"api/#builtin","title":"builtin","text":"<pre><code>import \"github.com/santosr2/uptool/internal/policy/guards/builtin\"\n</code></pre> <p>Package builtin registers all built-in auto-merge guards. Import this package to automatically register guards like ci-green, codeowners-approve, security-scan.</p> <p>The guards are registered via init() functions in their individual files:</p> <ul> <li>ci_green.go</li> <li>codeowners.go</li> <li>security_scan.go</li> </ul>"},{"location":"api/#index_26","title":"Index","text":"<ul> <li>type CIGreenGuard</li> <li>func \\(g \\*CIGreenGuard\\) Check\\(ctx context.Context, env \\*guards.Environment\\) \\(bool, error\\)</li> <li>func \\(g \\*CIGreenGuard\\) Description() string</li> <li>func \\(g \\*CIGreenGuard\\) Name() string</li> <li>type CodeownersApproveGuard</li> <li>func \\(g \\*CodeownersApproveGuard\\) Check\\(ctx context.Context, env \\*guards.Environment\\) \\(bool, error\\)</li> <li>func \\(g \\*CodeownersApproveGuard\\) Description() string</li> <li>func \\(g \\*CodeownersApproveGuard\\) Name() string</li> <li>type SecurityScanGuard</li> <li>func \\(g \\*SecurityScanGuard\\) Check\\(ctx context.Context, env \\*guards.Environment\\) \\(bool, error\\)</li> <li>func \\(g \\*SecurityScanGuard\\) Description() string</li> <li>func \\(g \\*SecurityScanGuard\\) Name() string</li> </ul>"},{"location":"api/#type-cigreenguard","title":"type CIGreenGuard","text":"<p>CIGreenGuard checks if all CI checks are passing.</p> <pre><code>type CIGreenGuard struct{}\n</code></pre> <p></p>"},{"location":"api/#func-cigreenguard-check","title":"func \\(\\*CIGreenGuard\\) Check","text":"<pre><code>func (g *CIGreenGuard) Check(ctx context.Context, env *guards.Environment) (bool, error)\n</code></pre> <p>Check verifies that all CI checks are passing.</p> <p></p>"},{"location":"api/#func-cigreenguard-description","title":"func \\(\\*CIGreenGuard\\) Description","text":"<pre><code>func (g *CIGreenGuard) Description() string\n</code></pre> <p>Description returns a human-readable description of the guard.</p> <p></p>"},{"location":"api/#func-cigreenguard-name","title":"func \\(\\*CIGreenGuard\\) Name","text":"<pre><code>func (g *CIGreenGuard) Name() string\n</code></pre> <p>Name returns the guard's unique identifier.</p> <p></p>"},{"location":"api/#type-codeownersapproveguard","title":"type CodeownersApproveGuard","text":"<p>CodeownersApproveGuard checks if CODEOWNERS have approved the PR.</p> <pre><code>type CodeownersApproveGuard struct{}\n</code></pre> <p></p>"},{"location":"api/#func-codeownersapproveguard-check","title":"func \\(\\*CodeownersApproveGuard\\) Check","text":"<pre><code>func (g *CodeownersApproveGuard) Check(ctx context.Context, env *guards.Environment) (bool, error)\n</code></pre> <p>Check verifies that CODEOWNERS have approved the PR.</p> <p></p>"},{"location":"api/#func-codeownersapproveguard-description","title":"func \\(\\*CodeownersApproveGuard\\) Description","text":"<pre><code>func (g *CodeownersApproveGuard) Description() string\n</code></pre> <p>Description returns a human-readable description of the guard.</p> <p></p>"},{"location":"api/#func-codeownersapproveguard-name","title":"func \\(\\*CodeownersApproveGuard\\) Name","text":"<pre><code>func (g *CodeownersApproveGuard) Name() string\n</code></pre> <p>Name returns the guard's unique identifier.</p> <p></p>"},{"location":"api/#type-securityscanguard","title":"type SecurityScanGuard","text":"<p>SecurityScanGuard checks if security scans have passed.</p> <pre><code>type SecurityScanGuard struct{}\n</code></pre> <p></p>"},{"location":"api/#func-securityscanguard-check","title":"func \\(\\*SecurityScanGuard\\) Check","text":"<pre><code>func (g *SecurityScanGuard) Check(ctx context.Context, env *guards.Environment) (bool, error)\n</code></pre> <p>Check verifies that security scans have passed.</p> <p></p>"},{"location":"api/#func-securityscanguard-description","title":"func \\(\\*SecurityScanGuard\\) Description","text":"<pre><code>func (g *SecurityScanGuard) Description() string\n</code></pre> <p>Description returns a human-readable description of the guard.</p> <p></p>"},{"location":"api/#func-securityscanguard-name","title":"func \\(\\*SecurityScanGuard\\) Name","text":"<pre><code>func (g *SecurityScanGuard) Name() string\n</code></pre> <p>Name returns the guard's unique identifier.</p> <p>Generated by gomarkdoc</p>"},{"location":"cli/commands/","title":"CLI Commands","text":"<p>uptool is a manifest-first dependency updater for multiple ecosystems. It scans repositories for dependency manifest files (package.json, Chart.yaml, .pre-commit-config.yaml, etc.), checks for available updates, and rewrites manifests with new versions while preserving formatting.</p> <p>Usage:   uptool [command]</p> <p>Available Commands:   check-policy Check organization policy compliance   completion   Generate shell completion scripts   help         Help about any command   list         List available integrations   migrate      Migrate from Dependabot to uptool configuration   plan         Generate update plans   scan         Discover dependency manifests   update       Apply updates to manifests</p> <p>Flags:       --config string   path to config file (default: uptool.yaml)   -h, --help            help for uptool   -q, --quiet           suppress informational output (errors only)   -v, --verbose         enable verbose debug output       --version         version for uptool</p> <p>Use \"uptool [command] --help\" for more information about a command.</p>"},{"location":"integrations/","title":"Integration Guides","text":"<p>Detailed guides for each uptool integration.</p>"},{"location":"integrations/#available-integrations","title":"Available Integrations","text":"Integration Manifest Status Registry npm <code>package.json</code> \u2705 Stable npm Registry API helm <code>Chart.yaml</code> \u2705 Stable Helm chart repositories terraform <code>*.tf</code> \u2705 Stable Terraform Registry API tflint <code>.tflint.hcl</code> \u2705 Stable GitHub Releases precommit <code>.pre-commit-config.yaml</code> \u2705 Stable GitHub Releases actions <code>.github/workflows/*.yml</code> \u2705 Stable GitHub Releases docker <code>Dockerfile</code>, <code>docker-compose.yml</code> \u2705 Stable Docker Hub API asdf <code>.tool-versions</code> \u26a0\ufe0f Experimental GitHub Releases mise <code>mise.toml</code> \u26a0\ufe0f Experimental GitHub Releases"},{"location":"integrations/#by-category","title":"By Category","text":""},{"location":"integrations/#package-managers","title":"Package Managers","text":"<ul> <li>npm - JavaScript/Node.js dependencies</li> </ul>"},{"location":"integrations/#infrastructure-as-code","title":"Infrastructure as Code","text":"<ul> <li>helm - Kubernetes package manager</li> <li>terraform - Terraform modules</li> <li>tflint - Terraform linter plugins</li> </ul>"},{"location":"integrations/#cicd","title":"CI/CD","text":"<ul> <li>actions - GitHub Actions workflow files</li> <li>precommit - Pre-commit hooks (uses native <code>pre-commit autoupdate</code>)</li> </ul>"},{"location":"integrations/#containers","title":"Containers","text":"<ul> <li>docker - Dockerfiles and docker-compose files</li> </ul>"},{"location":"integrations/#development-tools","title":"Development Tools","text":"<ul> <li>asdf - asdf version manager</li> <li>mise - mise version manager (modern asdf alternative)</li> </ul>"},{"location":"integrations/#common-patterns","title":"Common Patterns","text":""},{"location":"integrations/#scan-specific-integration","title":"Scan Specific Integration","text":"<pre><code>uptool scan --only=npm\nuptool scan --only=terraform,tflint\n</code></pre>"},{"location":"integrations/#update-single-integration","title":"Update Single Integration","text":"<pre><code>uptool update --only=helm --diff\n</code></pre>"},{"location":"integrations/#exclude-integrations","title":"Exclude Integrations","text":"<pre><code>uptool update --exclude=precommit,terraform\n</code></pre>"},{"location":"integrations/#configuration","title":"Configuration","text":"<p>Control integrations via <code>uptool.yaml</code>:</p> <pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    policy:\n      update: minor\n\n  - id: terraform\n    enabled: false\n</code></pre> <p>See Configuration Guide for complete options.</p>"},{"location":"integrations/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Command documentation</li> <li>Configuration - Policy settings</li> <li>Template - Template for new integrations</li> </ul>"},{"location":"integrations/actions/","title":"GitHub Actions Integration","text":"<p>Update GitHub Actions workflow files to use the latest action versions.</p>"},{"location":"integrations/actions/#overview","title":"Overview","text":"<p>Integration ID: <code>actions</code></p> <p>Manifest Files: <code>.github/workflows/*.yml</code>, <code>.github/workflows/*.yaml</code></p> <p>Update Strategy: YAML text rewriting (preserves formatting and comments)</p> <p>Registry: GitHub Releases API</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/actions/#what-gets-updated","title":"What Gets Updated","text":"<ul> <li><code>uses:</code> directives in workflow steps (e.g., <code>actions/checkout@v4</code> \u2192 <code>actions/checkout@v4.2.2</code>)</li> <li>Action references with version tags (e.g., <code>@v4</code>, <code>@v4.2.2</code>)</li> </ul> <p>Not Updated:</p> <ul> <li>SHA-pinned actions (e.g., <code>@11bd71901bbe5b1630ceea73d27597364c9af683</code>) - kept for security</li> <li>Local actions (e.g., <code>uses: ./.github/actions/my-action</code>)</li> <li>Docker Hub references (e.g., <code>uses: docker://alpine:3.8</code>)</li> </ul>"},{"location":"integrations/actions/#example","title":"Example","text":"<p>Before (<code>.github/workflows/ci.yml</code>):</p> <pre><code>name: CI\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n</code></pre> <p>After:</p> <pre><code>name: CI\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4.2.2\n      - uses: actions/setup-node@v4.1.0\n        with:\n          node-version: '20'\n      - uses: actions/cache@v4.1.2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n</code></pre>"},{"location":"integrations/actions/#integration-specific-behavior","title":"Integration-Specific Behavior","text":"<ul> <li>Version tags: Detects <code>v1</code>, <code>v1.2</code>, <code>v1.2.3</code> style tags and updates to latest matching release</li> <li>SHA preservation: Actions pinned to full commit SHAs are not updated (security-conscious teams often pin to SHAs)</li> <li>Comment preservation: YAML comments and formatting are preserved during updates</li> <li>Multi-job support: Scans all jobs and steps in a workflow file</li> <li>Deduplication: Same action@version appearing multiple times is only counted once</li> </ul>"},{"location":"integrations/actions/#configuration","title":"Configuration","text":"<p>Example <code>uptool.yaml</code> configuration:</p> <pre><code>version: 1\n\nintegrations:\n  - id: actions\n    enabled: true\n    policy:\n      update: minor        # Only update minor/patch versions\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/actions/#limitations","title":"Limitations","text":"<ol> <li>No SHA-to-tag conversion: If you pin to SHAs, uptool won't convert them to tags</li> <li>Registry-only actions: Only actions available on GitHub are supported (no private registries)</li> <li>Major version jumps: Use <code>update: major</code> policy carefully - major versions may have breaking changes</li> </ol>"},{"location":"integrations/actions/#see-also","title":"See Also","text":"<ul> <li>CLI Reference</li> <li>Configuration Guide</li> <li>Docker Integration - For updating Docker images in workflows</li> </ul>"},{"location":"integrations/asdf/","title":"asdf Integration","text":"<p>Updates tool versions in <code>.tool-versions</code> files used by the asdf version manager.</p>"},{"location":"integrations/asdf/#overview","title":"Overview","text":"<p>Integration ID: <code>asdf</code></p> <p>Manifest Files: <code>.tool-versions</code></p> <p>Update Strategy: Line-based parsing and rewriting</p> <p>Registry: GitHub Releases (per tool via asdf plugin mapping)</p> <p>Status: \u26a0\ufe0f Experimental (85% test coverage, version resolution not yet implemented)</p>"},{"location":"integrations/asdf/#what-gets-updated","title":"What Gets Updated","text":"<p>Tool version entries in <code>.tool-versions</code>:</p> <ul> <li>Each line format: <code>tool_name version</code></li> <li>Comments and formatting preserved</li> <li>Multiple versions per tool supported (space-separated)</li> </ul>"},{"location":"integrations/asdf/#example","title":"Example","text":"<p>Before:</p> <pre><code># Development tools\ngo 1.23.0\nnodejs 20.10.0\nterraform 1.5.0\n\n# Build tools\npython 3.11.0\nruby 3.2.0\n</code></pre> <p>After:</p> <pre><code># Development tools\ngo 1.25.0\nnodejs 22.12.0\nterraform 1.10.5\n\n# Build tools\npython 3.13.1\nruby 3.3.6\n</code></pre>"},{"location":"integrations/asdf/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/asdf/#file-format","title":"File Format","text":"<p>Simple line-based format:</p> <pre><code>tool_name version [version2 version3...]  # Optional comment\n</code></pre> <p>uptool updates the first (primary) version for each tool.</p>"},{"location":"integrations/asdf/#tool-installation","title":"Tool Installation","text":"<p>uptool updates only <code>.tool-versions</code>. Run <code>asdf install</code> after to install new versions:</p> <pre><code>uptool update --only asdf\nasdf install\n</code></pre>"},{"location":"integrations/asdf/#github-rate-limits","title":"GitHub Rate Limits","text":"<p>Each tool queries GitHub Releases. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only asdf\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/asdf/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: asdf\n    enabled: true\n    policy:\n      update: patch        # Conservative for runtimes\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/asdf/#limitations","title":"Limitations","text":"<ol> <li>Experimental status: Version resolution not yet implemented. <code>uptool plan</code> returns empty update lists.</li> <li>Detection only: Currently only scans and detects <code>.tool-versions</code> files and their dependencies.</li> <li>No updates yet: Use native <code>asdf</code> commands for updates:</li> <li><code>asdf plugin update --all</code> - Update all plugins</li> <li><code>asdf list all &lt;tool&gt;</code> - Check available versions</li> <li><code>asdf install &lt;tool&gt; latest</code> - Install latest version</li> <li>Future implementation: Will query GitHub Releases per tool for version checking.</li> </ol>"},{"location":"integrations/asdf/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only asdf</code></li> <li>Configuration Guide - Policy settings</li> <li>asdf Documentation</li> <li>mise Integration - Modern alternative to asdf</li> </ul>"},{"location":"integrations/docker/","title":"Docker Integration","text":"<p>Update Docker image versions in Dockerfiles and docker-compose files.</p>"},{"location":"integrations/docker/#overview","title":"Overview","text":"<p>Integration ID: <code>docker</code></p> <p>Manifest Files: <code>Dockerfile</code>, <code>Dockerfile.*</code>, <code>docker-compose.yml</code>, <code>docker-compose.yaml</code>, <code>compose.yml</code>, <code>compose.yaml</code></p> <p>Update Strategy: Text rewriting (preserves formatting and comments)</p> <p>Registry: Docker Hub API</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/docker/#what-gets-updated","title":"What Gets Updated","text":"<p>Dockerfiles:</p> <ul> <li><code>FROM</code> instructions with tagged images (e.g., <code>FROM node:20</code> \u2192 <code>FROM node:22</code>)</li> <li>Multi-stage builds (all <code>FROM</code> stages are scanned)</li> <li>Platform-specific images (e.g., <code>FROM --platform=linux/amd64 node:20</code>)</li> </ul> <p>Docker Compose:</p> <ul> <li><code>image:</code> fields in service definitions (e.g., <code>image: postgres:15</code> \u2192 <code>image: postgres:16</code>)</li> </ul> <p>Not Updated:</p> <ul> <li><code>FROM scratch</code> - no versioning needed</li> <li>Build args (e.g., <code>FROM ${BASE_IMAGE}</code>) - cannot resolve dynamically</li> <li>Digest-pinned images (e.g., <code>node@sha256:...</code>) - kept for reproducibility</li> <li><code>latest</code> tag - no specific version to update from</li> </ul>"},{"location":"integrations/docker/#example","title":"Example","text":"<p>Before (<code>Dockerfile</code>):</p> <pre><code>FROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\n\nFROM node:20-alpine\nWORKDIR /app\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY . .\nCMD [\"node\", \"server.js\"]\n</code></pre> <p>After:</p> <pre><code>FROM node:22-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\n\nFROM node:22-alpine\nWORKDIR /app\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY . .\nCMD [\"node\", \"server.js\"]\n</code></pre> <p>Before (<code>docker-compose.yml</code>):</p> <pre><code>services:\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_PASSWORD: secret\n\n  redis:\n    image: redis:7.2\n</code></pre> <p>After:</p> <pre><code>services:\n  db:\n    image: postgres:16\n    environment:\n      POSTGRES_PASSWORD: secret\n\n  redis:\n    image: redis:7.4\n</code></pre>"},{"location":"integrations/docker/#integration-specific-behavior","title":"Integration-Specific Behavior","text":"<ul> <li>Semantic version filtering: Only considers semver-like tags (e.g., <code>16</code>, <code>7.2</code>, <code>1.0.0</code>), skips non-version tags like <code>alpine</code>, <code>slim</code>, <code>bullseye</code></li> <li>Official images: Handles official Docker Hub images (e.g., <code>node</code>, <code>postgres</code>) by querying <code>library/&lt;image&gt;</code></li> <li>Custom registries: Supports images with namespaces (e.g., <code>myorg/myimage:1.0</code>)</li> <li>Comment preservation: All comments and formatting in Dockerfiles are preserved</li> <li>Multi-file support: Detects all Dockerfiles including <code>Dockerfile.prod</code>, <code>Dockerfile.dev</code>, etc.</li> </ul>"},{"location":"integrations/docker/#configuration","title":"Configuration","text":"<p>Example <code>uptool.yaml</code> configuration:</p> <pre><code>version: 1\n\nintegrations:\n  - id: docker\n    enabled: true\n    policy:\n      update: minor        # Recommended for production\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/docker/#limitations","title":"Limitations","text":"<ol> <li>Docker Hub only: Currently only queries Docker Hub; private registries and other registries (ghcr.io, gcr.io) are not supported</li> <li>No variant handling: Doesn't track variants like <code>-alpine</code>, <code>-slim</code> separately</li> <li>No digest updates: SHA256 digest-pinned images are not updated</li> </ol>"},{"location":"integrations/docker/#see-also","title":"See Also","text":"<ul> <li>CLI Reference</li> <li>Configuration Guide</li> <li>GitHub Actions Integration - For updating workflow files</li> </ul>"},{"location":"integrations/helm/","title":"Helm Integration","text":"<p>Updates Kubernetes Helm chart dependencies in <code>Chart.yaml</code> files.</p>"},{"location":"integrations/helm/#overview","title":"Overview","text":"<p>Integration ID: <code>helm</code></p> <p>Manifest Files: <code>Chart.yaml</code></p> <p>Update Strategy: YAML parsing and rewriting</p> <p>Registry: Helm chart repositories (<code>index.yaml</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/helm/#what-gets-updated","title":"What Gets Updated","text":"<p>Chart dependency versions in the <code>dependencies</code> list:</p> <ul> <li><code>dependencies[].version</code> - Version of each chart dependency</li> </ul> <p>Not updated: Chart <code>version</code> (your app version) or <code>appVersion</code> (packaged app version)</p>"},{"location":"integrations/helm/#example","title":"Example","text":"<p>Before:</p> <pre><code>apiVersion: v2\nname: my-application\nversion: 1.0.0\ndependencies:\n  - name: postgresql\n    version: 12.0.0\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 17.0.0\n    repository: https://charts.bitnami.com/bitnami\n</code></pre> <p>After:</p> <pre><code>apiVersion: v2\nname: my-application\nversion: 1.0.0     # Unchanged - your chart version\ndependencies:\n  - name: postgresql\n    version: 18.1.8  # Updated\n    repository: https://charts.bitnami.com/bitnami\n  - name: redis\n    version: 23.2.12 # Updated\n    repository: https://charts.bitnami.com/bitnami\n</code></pre>"},{"location":"integrations/helm/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/helm/#repository-types","title":"Repository Types","text":"Type Example Support Public <code>https://charts.bitnami.com/bitnami</code> \u2705 Full Private <code>https://charts.company.internal</code> \u2705 With auth OCI Registry <code>oci://registry.example.com/charts</code> \u2705 With config"},{"location":"integrations/helm/#repository-authentication","title":"Repository Authentication","text":"<p>For private repositories, configure Helm authentication:</p> <pre><code>helm repo add myrepo https://charts.company.internal \\\n  --username=user \\\n  --password=pass\n</code></pre> <p>uptool respects Helm's repository configuration in <code>~/.config/helm/repositories.yaml</code>.</p>"},{"location":"integrations/helm/#chartlock-handling","title":"Chart.lock Handling","text":"<p>uptool updates only <code>Chart.yaml</code>. Run <code>helm dependency update</code> after to regenerate lockfile:</p> <pre><code>uptool update --only helm\nhelm dependency update charts/myapp\n</code></pre> <p>Monorepo: Each <code>Chart.yaml</code> updated independently.</p>"},{"location":"integrations/helm/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: helm\n    enabled: true\n    match:\n      files:\n        - \"Chart.yaml\"\n        - \"charts/*/Chart.yaml\"    # Monorepo pattern\n    policy:\n      update: minor\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/helm/#limitations","title":"Limitations","text":"<ol> <li>No Chart.lock updates: Only <code>Chart.yaml</code> modified. Run <code>helm dependency update</code> after.</li> <li>No version constraint validation: Test with <code>helm lint</code> after updating.</li> <li>Repository must be configured: Ensure repositories added via <code>helm repo add</code>.</li> </ol>"},{"location":"integrations/helm/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only helm</code></li> <li>Configuration Guide - Policy settings</li> <li>Helm Chart Dependencies</li> <li>Helm Repositories</li> </ul>"},{"location":"integrations/mise/","title":"mise Integration","text":"<p>Updates development tool versions in <code>mise.toml</code> and <code>.mise.toml</code> files.</p>"},{"location":"integrations/mise/#overview","title":"Overview","text":"<p>Integration ID: <code>mise</code></p> <p>Manifest Files: <code>mise.toml</code>, <code>.mise.toml</code></p> <p>Update Strategy: TOML parsing and rewriting</p> <p>Registry: GitHub Releases (per tool)</p> <p>Status: \u26a0\ufe0f Experimental (86% test coverage, version resolution not yet implemented)</p>"},{"location":"integrations/mise/#what-gets-updated","title":"What Gets Updated","text":"<p>Tool versions in the <code>[tools]</code> section:</p> <ul> <li>String format: <code>tool = \"version\"</code></li> <li>Map format: <code>tool = { version = \"version\", ... }</code></li> <li>Preserves whichever format you use</li> </ul> <p>Monorepo support: Each <code>mise.toml</code> updated independently.</p>"},{"location":"integrations/mise/#example","title":"Example","text":"<p>Before:</p> <pre><code>[tools]\ngo = \"1.23\"\nnode = \"20\"\npython = \"3.11\"\nterraform = { version = \"1.5.0\" }\ngolangci-lint = \"2.6\"\n</code></pre> <p>After:</p> <pre><code>[tools]\ngo = \"1.25\"\nnode = \"22\"\npython = \"3.13\"\nterraform = { version = \"1.10.5\" }   # Preserves map format\ngolangci-lint = \"2.7\"\n</code></pre>"},{"location":"integrations/mise/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/mise/#version-formats","title":"Version Formats","text":"<p>mise supports two TOML formats:</p> Format Example Use Case String <code>go = \"1.25\"</code> Simple (recommended) Map <code>go = { version = \"1.25\", path = \".go-version\" }</code> With additional options <p>uptool preserves the format - map stays map, string stays string.</p>"},{"location":"integrations/mise/#partial-versions","title":"Partial Versions","text":"<p>mise allows partial version specifications that uptool updates:</p> <pre><code>go = \"1.23\"      # Updates to \"1.25\" (latest 1.x)\nnode = \"20\"      # Updates to \"22\" (latest)\npython = \"3.11\"  # Updates to \"3.13\" (latest 3.x)\n</code></pre>"},{"location":"integrations/mise/#tool-installation","title":"Tool Installation","text":"<p>uptool updates only <code>mise.toml</code>. Run <code>mise install</code> after updating to install new versions:</p> <pre><code>uptool update --only mise\nmise install\n</code></pre>"},{"location":"integrations/mise/#github-rate-limits","title":"GitHub Rate Limits","text":"<p>Each tool queries GitHub Releases. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only mise\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/mise/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: mise\n    enabled: true\n    match:\n      files:\n        - \"mise.toml\"\n        - \".mise.toml\"     # Hidden variant\n        - \"*/mise.toml\"    # Nested projects\n    policy:\n      update: patch        # Conservative for runtimes\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/mise/#limitations","title":"Limitations","text":"<ol> <li>Experimental status: Version resolution not yet implemented. <code>uptool plan</code> returns empty update lists.</li> <li>Detection only: Currently only scans and detects <code>mise.toml</code>/<code>.mise.toml</code> files and their dependencies.</li> <li>No updates yet: Use native <code>mise</code> commands for updates:</li> <li><code>mise upgrade</code> - Update all tools</li> <li><code>mise latest &lt;tool&gt;</code> - Check latest version</li> <li><code>mise install &lt;tool&gt;@latest</code> - Install latest version</li> <li>Future implementation: Will query GitHub Releases per tool for version checking.</li> </ol>"},{"location":"integrations/mise/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only mise</code></li> <li>Configuration Guide - Policy settings</li> <li>mise Documentation</li> <li>asdf Integration - Alternative runtime manager</li> </ul>"},{"location":"integrations/npm/","title":"npm Integration","text":"<p>Updates JavaScript/Node.js dependencies in <code>package.json</code> files.</p>"},{"location":"integrations/npm/#overview","title":"Overview","text":"<p>Integration ID: <code>npm</code></p> <p>Manifest Files: <code>package.json</code></p> <p>Update Strategy: Custom JSON rewriting with constraint preservation</p> <p>Registry: npm Registry API (<code>https://registry.npmjs.org</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/npm/#what-gets-updated","title":"What Gets Updated","text":"<p>All dependency types in <code>package.json</code>:</p> <ul> <li><code>dependencies</code> - Production dependencies</li> <li><code>devDependencies</code> - Development dependencies</li> <li><code>peerDependencies</code> - Peer dependencies</li> <li><code>optionalDependencies</code> - Optional dependencies</li> </ul> <p>Monorepo support: Each <code>package.json</code> updated independently.</p>"},{"location":"integrations/npm/#example","title":"Example","text":"<p>Before:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"lodash\": \"~4.17.20\",\n    \"axios\": \"&gt;=0.27.0\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.0.0\"\n  }\n}\n</code></pre> <p>After:</p> <pre><code>{\n  \"dependencies\": {\n    \"express\": \"^4.19.2\",     // Preserves ^ constraint\n    \"lodash\": \"~4.17.21\",     // Preserves ~ constraint\n    \"axios\": \"&gt;=1.7.0\"        // Preserves &gt;= constraint\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.7.0\"\n  }\n}\n</code></pre>"},{"location":"integrations/npm/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/npm/#version-constraint-preservation","title":"Version Constraint Preservation","text":"<p>uptool preserves version constraint prefixes:</p> Constraint Meaning Before After <code>^</code> Compatible with <code>^4.18.0</code> <code>^4.19.2</code> <code>~</code> Approximately <code>~4.17.20</code> <code>~4.17.21</code> <code>&gt;=</code> Greater than or equal <code>&gt;=0.27.0</code> <code>&gt;=1.7.0</code> (none) Exact version <code>1.0.0</code> <code>1.5.0</code>"},{"location":"integrations/npm/#lockfile-handling","title":"Lockfile Handling","text":"<p>uptool updates only <code>package.json</code>. Run <code>npm install</code> after updating to sync lockfiles:</p> <pre><code>uptool update --only npm\nnpm install\n</code></pre>"},{"location":"integrations/npm/#private-registries","title":"Private Registries","text":"<p>Respects npm configuration from <code>.npmrc</code> or <code>npm config</code>. Configure authentication separately:</p> <pre><code>npm config set registry https://registry.company.com/\nnpm login --registry=https://registry.company.com/\n</code></pre>"},{"location":"integrations/npm/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: npm\n    enabled: true\n    match:\n      files:\n        - \"package.json\"\n        - \"apps/*/package.json\"     # Monorepo paths\n        - \"packages/*/package.json\"\n    policy:\n      update: minor                 # none, patch, minor, major\n      allow_prerelease: false\n      pin: false                    # false = preserve constraints\n</code></pre>"},{"location":"integrations/npm/#limitations","title":"Limitations","text":"<ol> <li>No lockfile updates: <code>package-lock.json</code> not modified. Run <code>npm install</code> after updates.</li> <li>No peer dependency validation: Run <code>npm install</code> to see peer dependency warnings.</li> </ol>"},{"location":"integrations/npm/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only npm</code>, <code>uptool plan --only npm</code></li> <li>Configuration Guide - Policy settings</li> <li>npm Registry API</li> <li>Semantic Versioning</li> </ul>"},{"location":"integrations/precommit/","title":"Pre-Commit Integration","text":"<p>Updates pre-commit hook versions in <code>.pre-commit-config.yaml</code> files.</p>"},{"location":"integrations/precommit/#overview","title":"Overview","text":"<p>Integration ID: <code>precommit</code></p> <p>Manifest Files: <code>.pre-commit-config.yaml</code></p> <p>Update Strategy: Native command - Uses <code>pre-commit autoupdate</code></p> <p>Registry: GitHub Releases (per hook repository)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/precommit/#what-gets-updated","title":"What Gets Updated","text":"<p>Hook repository revisions in the <code>repos</code> list:</p> <ul> <li><code>repos[].rev</code> - Git tag or commit SHA of each hook repository</li> <li>Remote hooks only (local and meta hooks skipped)</li> </ul>"},{"location":"integrations/precommit/#example","title":"Example","text":"<p>Before:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: trailing-whitespace\n      - id: check-yaml\n\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n\n  - repo: local    # Not updated\n    hooks:\n      - id: custom-check\n</code></pre> <p>After:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v6.0.0      # Updated\n    hooks:\n      - id: trailing-whitespace\n      - id: check-yaml\n\n  - repo: https://github.com/psf/black\n    rev: 24.10.0     # Updated\n    hooks:\n      - id: black\n\n  - repo: local    # Unchanged\n    hooks:\n      - id: custom-check\n</code></pre>"},{"location":"integrations/precommit/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/precommit/#why-native-command","title":"Why Native Command?","text":"<p>uptool uses <code>pre-commit autoupdate</code> instead of custom rewriting because:</p> <ol> <li>Manifest-first: Updates <code>.pre-commit-config.yaml</code> directly \u2705</li> <li>Comprehensive: Handles all edge cases (local hooks, complex revisions)</li> <li>Maintained: pre-commit team owns the update logic</li> <li>Reliable: Battle-tested by entire pre-commit ecosystem</li> </ol> <p>This aligns with uptool's philosophy: use native commands when they update manifests.</p>"},{"location":"integrations/precommit/#hook-types","title":"Hook Types","text":"Type Example Updated? Remote <code>repo: https://github.com/...</code> \u2705 Yes Local <code>repo: local</code> \u274c No Meta <code>repo: meta</code> \u274c No"},{"location":"integrations/precommit/#github-rate-limits","title":"GitHub Rate Limits","text":"<p><code>pre-commit autoupdate</code> queries GitHub API for each hook. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only precommit\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/precommit/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: precommit\n    enabled: true\n    policy:\n      update: major        # Aggressive for dev tools (safe)\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/precommit/#requirements","title":"Requirements","text":"<ol> <li>pre-commit installed: Must be in <code>$PATH</code></li> <li>Git repository: pre-commit requires git</li> <li>Valid config: <code>.pre-commit-config.yaml</code> must be valid YAML</li> </ol> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\n# or\nbrew install pre-commit\n# or\nmise install pre-commit\n\n# Verify\npre-commit --version\n</code></pre>"},{"location":"integrations/precommit/#limitations","title":"Limitations","text":"<ol> <li>Requires pre-commit CLI: Must have <code>pre-commit</code> installed and in PATH.</li> <li>Git repository required: pre-commit needs a git repository to operate.</li> <li>Limited policy control: pre-commit decides what to update (up tool passes preferences where supported).</li> </ol>"},{"location":"integrations/precommit/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only precommit</code></li> <li>Configuration Guide - Policy settings</li> <li>pre-commit Documentation</li> <li>Supported Hooks</li> </ul>"},{"location":"integrations/terraform/","title":"Terraform Integration","text":"<p>Updates Terraform module versions in <code>*.tf</code> files.</p>"},{"location":"integrations/terraform/#overview","title":"Overview","text":"<p>Integration ID: <code>terraform</code></p> <p>Manifest Files: <code>*.tf</code></p> <p>Update Strategy: HCL parsing and rewriting via <code>hashicorp/hcl</code></p> <p>Registry: Terraform Registry API (<code>https://registry.terraform.io</code>)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/terraform/#what-gets-updated","title":"What Gets Updated","text":"<p>Module versions in <code>module</code> blocks:</p> <ul> <li><code>module</code> block <code>version</code> attributes - Terraform Registry modules</li> </ul> <p>Not yet supported (future):</p> <ul> <li>Provider versions in <code>required_providers</code> blocks</li> <li>Git-based module source versions</li> </ul>"},{"location":"integrations/terraform/#example","title":"Example","text":"<p>Before:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.0.0\"\n\n  name = \"my-vpc\"\n  cidr = \"10.0.0.0/16\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 4.0\"\n\n  name = \"my-sg\"\n}\n</code></pre> <p>After:</p> <pre><code>module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"5.13.0\"   # Updated\n\n  name = \"my-vpc\"\n  cidr = \"10.0.0.0/16\"\n}\n\nmodule \"security_group\" {\n  source  = \"terraform-aws-modules/security-group/aws\"\n  version = \"~&gt; 5.0\"   # Updated (preserves constraint)\n\n  name = \"my-sg\"\n}\n</code></pre>"},{"location":"integrations/terraform/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/terraform/#version-constraint-preservation","title":"Version Constraint Preservation","text":"<p>uptool preserves version constraint operators:</p> Constraint Meaning Before After (none) Exact <code>\"3.0.0\"</code> <code>\"5.13.0\"</code> <code>~&gt;</code> Pessimistic <code>\"~&gt; 4.0\"</code> <code>\"~&gt; 5.0\"</code> <code>&gt;=</code> Greater or equal <code>\"&gt;= 3.0\"</code> <code>\"&gt;= 5.13\"</code>"},{"location":"integrations/terraform/#terraform-init-required","title":"Terraform Init Required","text":"<p>uptool updates only <code>.tf</code> files. Run <code>terraform init</code> after to update lockfile:</p> <pre><code>uptool update --only terraform\nterraform init -upgrade\n</code></pre>"},{"location":"integrations/terraform/#module-sources","title":"Module Sources","text":"<p>Only Terraform Registry modules updated:</p> <pre><code># \u2705 Updated - Registry module\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"5.13.0\"\n}\n\n# \u274c Not updated - Git source\nmodule \"custom\" {\n  source = \"git::https://github.com/org/repo.git?ref=v1.0.0\"\n}\n\n# \u274c Not updated - Local path\nmodule \"local\" {\n  source = \"./modules/networking\"\n}\n</code></pre>"},{"location":"integrations/terraform/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: terraform\n    enabled: true\n    match:\n      files:\n        - \"*.tf\"\n        - \"**/*.tf\"              # All subdirectories\n    policy:\n      update: patch              # Conservative for infrastructure\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/terraform/#limitations","title":"Limitations","text":"<ol> <li>Registry modules only: Local and Git sources not supported.</li> <li>No provider updates: <code>required_providers</code> versions not yet updated.</li> <li>No lockfile updates: Run <code>terraform init -upgrade</code> after.</li> </ol>"},{"location":"integrations/terraform/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only terraform</code></li> <li>Configuration Guide - Policy settings</li> <li>Terraform Registry</li> <li>Terraform Module Sources</li> </ul>"},{"location":"integrations/tflint/","title":"tflint Integration","text":"<p>Updates tflint plugin versions in <code>.tflint.hcl</code> configuration files.</p>"},{"location":"integrations/tflint/#overview","title":"Overview","text":"<p>Integration ID: <code>tflint</code></p> <p>Manifest Files: <code>.tflint.hcl</code></p> <p>Update Strategy: HCL parsing and rewriting via <code>hashicorp/hcl</code></p> <p>Registry: GitHub Releases (per plugin)</p> <p>Status: \u2705 Stable</p>"},{"location":"integrations/tflint/#what-gets-updated","title":"What Gets Updated","text":"<p>Plugin versions in <code>plugin</code> blocks:</p> <ul> <li><code>plugin</code> block <code>version</code> attributes - GitHub Releases versions</li> </ul>"},{"location":"integrations/tflint/#example","title":"Example","text":"<p>Before:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.21.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.20.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n</code></pre> <p>After:</p> <pre><code>plugin \"aws\" {\n  enabled = true\n  version = \"0.44.0\"   # Updated\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\nplugin \"azurerm\" {\n  enabled = true\n  version = \"0.28.0\"   # Updated\n  source  = \"github.com/terraform-linters/tflint-ruleset-azurerm\"\n}\n</code></pre>"},{"location":"integrations/tflint/#integration-specific-behavior","title":"Integration-Specific Behavior","text":""},{"location":"integrations/tflint/#plugin-sources","title":"Plugin Sources","text":"<p>Updates plugins from GitHub sources:</p> <pre><code># \u2705 Updated - GitHub source\nplugin \"aws\" {\n  version = \"0.44.0\"\n  source  = \"github.com/terraform-linters/tflint-ruleset-aws\"\n}\n\n# \u274c Not updated - Custom source\nplugin \"custom\" {\n  version = \"1.0.0\"\n  source  = \"example.com/custom-plugin\"\n}\n</code></pre>"},{"location":"integrations/tflint/#tflint-init-required","title":"tflint Init Required","text":"<p>uptool updates only <code>.tflint.hcl</code>. Run <code>tflint --init</code> after to install new plugin versions:</p> <pre><code>uptool update --only tflint\ntflint --init\n</code></pre>"},{"location":"integrations/tflint/#github-rate-limits","title":"GitHub Rate Limits","text":"<p>Each plugin queries GitHub Releases. Set <code>GITHUB_TOKEN</code> for higher limits:</p> <pre><code>export GITHUB_TOKEN=\"your_token\"\nuptool update --only tflint\n</code></pre> <ul> <li>Unauthenticated: 60 requests/hour</li> <li>Authenticated: 5,000 requests/hour</li> </ul>"},{"location":"integrations/tflint/#configuration","title":"Configuration","text":"<pre><code>version: 1\n\nintegrations:\n  - id: tflint\n    enabled: true\n    policy:\n      update: major        # Aggressive for linters (safe)\n      allow_prerelease: false\n</code></pre>"},{"location":"integrations/tflint/#limitations","title":"Limitations","text":"<ol> <li>GitHub sources only: Custom plugin sources not supported.</li> <li>No plugin installation: Run <code>tflint --init</code> after updating.</li> </ol>"},{"location":"integrations/tflint/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - <code>uptool scan --only tflint</code></li> <li>Configuration Guide - Policy settings</li> <li>TFLint Documentation</li> <li>TFLint Rulesets</li> </ul>"}]}