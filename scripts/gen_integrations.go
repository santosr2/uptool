// Command gen_integrations generates the all.go file that imports all integrations.
// This ensures that adding a new integration doesn't require manual updates.
//
// Usage:
//
//	go run scripts/gen_integrations.go
//
// Or via go generate:
//
//	go generate ./internal/integrations
package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const (
	integrationsDir = "internal/integrations"
	outputFile      = "internal/integrations/all/all.go"
	modulePath      = "github.com/santosr2/uptool"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Find repository root (directory containing go.mod)
	repoRoot, err := findRepoRoot()
	if err != nil {
		return fmt.Errorf("finding repository root: %w", err)
	}

	// Change to repository root
	if err := os.Chdir(repoRoot); err != nil {
		return fmt.Errorf("changing to repo root: %w", err)
	}

	// Find all integration packages
	integrations, err := findIntegrations()
	if err != nil {
		return fmt.Errorf("finding integrations: %w", err)
	}

	if len(integrations) == 0 {
		return fmt.Errorf("no integrations found in %s", integrationsDir)
	}

	// Generate the all.go file
	content, err := generateAllGo(integrations)
	if err != nil {
		return fmt.Errorf("generating code: %w", err)
	}

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outputFile), 0o750); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	// Write the generated file
	if err := os.WriteFile(outputFile, content, 0o600); err != nil {
		return fmt.Errorf("writing output file: %w", err)
	}

	fmt.Printf("Generated %s with %d integrations\n", outputFile, len(integrations))
	return nil
}

// findRepoRoot walks up the directory tree to find the repository root
// (directory containing go.mod).
func findRepoRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		// Check if go.mod exists in current directory
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		// Move up one directory
		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached filesystem root without finding go.mod
			return "", fmt.Errorf("go.mod not found in any parent directory")
		}
		dir = parent
	}
}

// findIntegrations scans the integrations directory and returns a sorted list
// of integration package names (subdirectories that contain .go files).
func findIntegrations() ([]string, error) {
	entries, err := os.ReadDir(integrationsDir)
	if err != nil {
		return nil, err
	}

	var integrations []string
	for _, entry := range entries {
		// Skip non-directories
		if !entry.IsDir() {
			continue
		}

		name := entry.Name()

		// Skip special directories
		if name == "all" || strings.HasPrefix(name, ".") || strings.HasPrefix(name, "_") {
			continue
		}

		// Verify it's a valid integration package (contains .go files)
		pkgPath := filepath.Join(integrationsDir, name)
		if hasGoFiles(pkgPath) {
			integrations = append(integrations, name)
		}
	}

	sort.Strings(integrations)
	return integrations, nil
}

// hasGoFiles checks if a directory contains any .go files (non-test).
func hasGoFiles(dir string) bool {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return false
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if strings.HasSuffix(name, ".go") && !strings.HasSuffix(name, "_test.go") {
			return true
		}
	}

	return false
}

// generateAllGo creates the content for the all.go file.
func generateAllGo(integrations []string) ([]byte, error) {
	var b strings.Builder

	// Package header
	b.WriteString("// Code generated by scripts/gen_integrations.go. DO NOT EDIT.\n\n")
	b.WriteString("// Package all imports all integration packages to trigger their self-registration.\n")
	b.WriteString("// Import this package with a blank identifier to enable all integrations:\n")
	b.WriteString("//\n")
	b.WriteString("//\timport _ \"" + modulePath + "/internal/integrations/all\"\n")
	b.WriteString("package all\n\n")

	// Imports
	b.WriteString("import (\n")
	b.WriteString("\t// Import all integration packages to trigger init() functions\n")
	for _, name := range integrations {
		importPath := fmt.Sprintf("%s/%s/%s", modulePath, integrationsDir, name)
		b.WriteString(fmt.Sprintf("\t_ %q\n", importPath))
	}
	b.WriteString(")\n")

	// Format the generated code
	formatted, err := format.Source([]byte(b.String()))
	if err != nil {
		// If formatting fails, return the unformatted version with the error
		return []byte(b.String()), fmt.Errorf("formatting generated code: %w", err)
	}

	return formatted, nil
}
