// Copyright (c) 2024 santosr2
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Package guards provides an extensible plugin system for auto-merge guards.
//
// # Overview
//
// Guards are pluggable checks that determine whether a Pull Request is ready for
// auto-merge. uptool provides built-in guards (ci-green, codeowners-approve,
// security-scan) and supports custom user-defined guards via the Guard interface.
//
// # Architecture
//
// The guard system consists of three main components:
//
//  1. Guard Interface - defines the contract for all guards
//  2. Registry - manages guard registration and lookup
//  3. Environment - provides GitHub context to guards
//
// # Built-in Guards
//
// uptool includes three production-ready guards:
//
//   - ci-green: Verifies all CI checks pass (SUCCESS or SKIPPED)
//   - codeowners-approve: Requires approval from repository CODEOWNERS
//   - security-scan: Ensures security scans (CodeQL, Trivy, SAST) pass
//
// Built-in guards are automatically registered via init() functions in the
// builtin package (internal/policy/guards/builtin/).
//
// # Custom Guards
//
// To create a custom guard:
//
//  1. Implement the Guard interface (Name, Description, Check methods)
//  2. Register the guard via init() function: guards.Register(&MyGuard{})
//  3. Import the guard package in your application
//  4. Add the guard name to org_policy.auto_merge.guards in uptool.yaml
//
// Example custom guard:
//
//	type MyGuard struct{}
//
//	func init() {
//	    guards.Register(&MyGuard{})
//	}
//
//	func (g *MyGuard) Name() string {
//	    return "my-custom-guard"
//	}
//
//	func (g *MyGuard) Description() string {
//	    return "Checks my custom approval workflow"
//	}
//
//	func (g *MyGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {
//	    // Custom logic here - query APIs, check files, etc.
//	    return true, nil
//	}
//
// # Code Generation
//
// The guard registry file (internal/policy/guards/builtin/all.go) is automatically
// generated by scripts/gen_guards.go. Run `go generate` to regenerate after adding
// new built-in guards.
//
// See docs/guards.md for comprehensive documentation on creating custom guards.
package guards

//go:generate go run ../../../scripts/gen_guards.go

import (
	"context"
	"fmt"
	"sync"
)

// Guard represents a pluggable auto-merge guard check.
//
// Guards determine whether a Pull Request meets the criteria for auto-merge.
// They can be built-in (ci-green, codeowners-approve, security-scan) or
// custom user-defined plugins.
//
// All guards must be thread-safe as they may be executed concurrently.
type Guard interface {
	// Name returns the unique identifier for this guard.
	//
	// The name is used in configuration (org_policy.auto_merge.guards) and
	// must be globally unique across all registered guards.
	//
	// Examples: "ci-green", "codeowners-approve", "slack-approval"
	Name() string

	// Description returns a human-readable description of what this guard checks.
	//
	// The description is shown in help text and error messages to help users
	// understand what the guard does and why it might be failing.
	//
	// Example: "Verifies that all CI checks pass (SUCCESS or SKIPPED)"
	Description() string

	// Check executes the guard check and returns true if the guard is satisfied.
	//
	// The context can be used for cancellation and timeout control. Guards should
	// respect context cancellation to avoid blocking during shutdown.
	//
	// The environment provides GitHub context (repo, PR number, API token) that
	// most guards need to query the GitHub API or related services.
	//
	// Returns:
	//   - true, nil: Guard is satisfied (PR can be auto-merged)
	//   - false, nil: Guard is not satisfied (PR should not be auto-merged)
	//   - false, error: Guard check failed (treat as not satisfied)
	//
	// Guards should return descriptive errors to help with debugging.
	Check(ctx context.Context, env *Environment) (bool, error)
}

// Environment contains the GitHub context for guard checks.
//
// This struct is passed to all Guard.Check() calls and provides the necessary
// information to query GitHub APIs or other systems about the PR.
//
// All fields are guaranteed to be populated and validated before being passed
// to guards.
type Environment struct {
	// GitHubRepo is the repository in "owner/repo" format (e.g., "santosr2/uptool").
	GitHubRepo string

	// GitHubToken is a GitHub API token with permissions to access the repository.
	// Typically has repo scope for private repos or public_repo for public repos.
	GitHubToken string

	// GitHubPRNumber is the pull request number as a string.
	// Guaranteed to be a valid numeric string (e.g., "42", "123").
	GitHubPRNumber string
}

// Registry manages registered guards (both built-in and custom).
//
// The registry provides thread-safe registration and lookup of guards.
// Guards are registered via init() functions and looked up by name during
// policy checks.
type Registry struct {
	guards map[string]Guard
	mu     sync.RWMutex // Protects guards map
}

// defaultRegistry is the global guard registry used by package-level functions.
//
// All guards registered via Register() are added to this global registry.
// Built-in guards are automatically registered during package initialization.
var defaultRegistry = &Registry{
	guards: make(map[string]Guard),
}

// Register adds a guard to the global registry.
//
// This function is typically called from init() functions to self-register guards:
//
//	func init() {
//	    guards.Register(&MyCustomGuard{})
//	}
//
// Panics if a guard with the same name is already registered, as duplicate
// guard names indicate a programming error.
func Register(guard Guard) {
	defaultRegistry.Register(guard)
}

// Register adds a guard to this registry.
//
// Panics if a guard with the same name is already registered.
// This is the underlying implementation used by the package-level Register function.
func (r *Registry) Register(guard Guard) {
	r.mu.Lock()
	defer r.mu.Unlock()

	name := guard.Name()
	if _, exists := r.guards[name]; exists {
		panic(fmt.Sprintf("guard %q already registered", name))
	}

	r.guards[name] = guard
}

// Get retrieves a guard by name from the global registry.
//
// Returns the guard and true if found, or nil and false if not registered.
//
// This function is thread-safe and can be called concurrently.
func Get(name string) (Guard, bool) {
	return defaultRegistry.Get(name)
}

// Get retrieves a guard by name from this registry.
//
// Returns the guard and true if found, or nil and false if not registered.
func (r *Registry) Get(name string) (Guard, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	guard, exists := r.guards[name]
	return guard, exists
}

// List returns all registered guard names from the global registry.
//
// The returned slice is a snapshot of registered guard names at the time
// of the call. The order is not guaranteed.
//
// This is useful for displaying available guards to users or debugging.
func List() []string {
	return defaultRegistry.List()
}

// List returns all registered guard names from this registry.
//
// Returns a new slice containing all registered guard names.
func (r *Registry) List() []string {
	r.mu.RLock()
	defer r.mu.RUnlock()

	names := make([]string, 0, len(r.guards))
	for name := range r.guards {
		names = append(names, name)
	}
	return names
}

// CheckGuard executes a guard check by name using the global registry.
//
// This is a convenience function that looks up the guard and executes its
// Check method. Returns an error if the guard is not found.
//
// Returns:
//   - true, nil: Guard found and satisfied
//   - false, nil: Guard found but not satisfied
//   - false, error: Guard not found or check failed
func CheckGuard(ctx context.Context, name string, env *Environment) (bool, error) {
	return defaultRegistry.CheckGuard(ctx, name, env)
}

// CheckGuard executes a guard check by name using this registry.
//
// Looks up the guard by name and executes its Check method with the provided
// context and environment.
func (r *Registry) CheckGuard(ctx context.Context, name string, env *Environment) (bool, error) {
	guard, exists := r.Get(name)
	if !exists {
		return false, fmt.Errorf("unknown guard: %s", name)
	}

	return guard.Check(ctx, env)
}
