name: 'Uptool Dependency Updater'
description: 'Universal manifest-first dependency updater for npm, Helm, Terraform, pre-commit, and more'
author: 'santosr2'

branding:
  icon: 'package'
  color: 'blue'

inputs:
  command:
    description: 'Command to run: scan, plan, or update'
    required: false
    default: 'plan'

  format:
    description: 'Output format: table or json'
    required: false
    default: 'table'

  only:
    description: 'Comma-separated list of integrations to include (e.g., npm,helm)'
    required: false
    default: ''

  exclude:
    description: 'Comma-separated list of integrations to exclude'
    required: false
    default: ''

  config:
    description: 'Path to uptool config file (default: uptool.yaml)'
    required: false
    default: ''

  dry-run:
    description: 'Show changes without applying (for update command)'
    required: false
    default: 'false'

  diff:
    description: 'Show diffs of changes (for update command)'
    required: false
    default: 'true'

  create-pr:
    description: 'Create a pull request with updates'
    required: false
    default: 'false'

  pr-title:
    description: 'Title for the pull request'
    required: false
    default: 'chore: update dependencies'

  pr-branch:
    description: 'Branch name for the pull request'
    required: false
    default: 'uptool/dependency-updates'

  create-issue:
    description: 'Create an issue when updates are available'
    required: false
    default: 'false'

  issue-title:
    description: 'Title for the issue'
    required: false
    default: 'Dependency Updates Available'

  issue-labels:
    description: 'Comma-separated labels for the issue'
    required: false
    default: 'dependencies,automated'

  token:
    description: 'GitHub token for creating PRs or issues'
    required: false
    default: ${{ github.token }}

  skip-install:
    description: 'Skip uptool installation (use when uptool is already available in PATH)'
    required: false
    default: 'false'

outputs:
  updates-available:
    description: 'Whether updates are available (true/false)'
    value: ${{ steps.uptool.outputs.updates-available }}

  manifests-updated:
    description: 'Number of manifests updated'
    value: ${{ steps.uptool.outputs.manifests-updated }}

  dependencies-updated:
    description: 'Number of dependencies updated'
    value: ${{ steps.uptool.outputs.dependencies-updated }}

runs:
  using: 'composite'
  steps:
    - name: Install uptool
      if: inputs.skip-install != 'true'
      shell: bash
      run: |
        # Detect OS and architecture
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)

        case "$ARCH" in
          x86_64) ARCH="amd64" ;;
          aarch64|arm64) ARCH="arm64" ;;
          *) echo "::error::Unsupported architecture: $ARCH"; exit 1 ;;
        esac

        # Get the latest release version
        LATEST_VERSION=$(curl -s https://api.github.com/repos/santosr2/uptool/releases/latest | grep '"tag_name"' | sed -E 's/.*"v([^"]+)".*/\1/')

        if [ -z "$LATEST_VERSION" ]; then
          echo "::error::Failed to get latest uptool version"
          exit 1
        fi

        echo "Installing uptool v${LATEST_VERSION} for ${OS}/${ARCH}..."

        # Download and install uptool
        DOWNLOAD_URL="https://github.com/santosr2/uptool/releases/download/v${LATEST_VERSION}/uptool_${LATEST_VERSION}_${OS}_${ARCH}.tar.gz"

        curl -sL "$DOWNLOAD_URL" | tar -xz -C /tmp
        chmod +x /tmp/uptool

        # Verify installation
        /tmp/uptool --version

        echo "âœ… uptool v${LATEST_VERSION} installed successfully"

    - name: Verify uptool availability
      shell: bash
      run: |
        if [ "${{ inputs.skip-install }}" == "true" ]; then
          echo "Installation skipped - verifying uptool is available in PATH..."
          if ! command -v uptool >/dev/null 2>&1; then
            echo "::error::skip-install is true but uptool not found in PATH"
            exit 1
          fi
          echo "UPTOOL_CMD=uptool" >> "$GITHUB_ENV"
          uptool --version
        else
          echo "UPTOOL_CMD=/tmp/uptool" >> "$GITHUB_ENV"
        fi

    - name: Run uptool
      id: uptool
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        # Change to workspace directory to avoid config path warnings
        cd "$GITHUB_WORKSPACE"

        CMD="${{ inputs.command }}"
        ARGS=""

        # Add config flag
        if [ -n "${{ inputs.config }}" ]; then
          ARGS="$ARGS --config=${{ inputs.config }}"
        fi

        # Add format flag
        if [ "$CMD" != "update" ] && [ -n "${{ inputs.format }}" ]; then
          ARGS="$ARGS --format=${{ inputs.format }}"
        fi

        # Add only flag
        if [ -n "${{ inputs.only }}" ]; then
          ARGS="$ARGS --only=${{ inputs.only }}"
        fi

        # Add exclude flag
        if [ -n "${{ inputs.exclude }}" ]; then
          ARGS="$ARGS --exclude=${{ inputs.exclude }}"
        fi

        # Add update-specific flags
        if [ "$CMD" == "update" ]; then
          if [ "${{ inputs.dry-run }}" == "true" ]; then
            ARGS="$ARGS --dry-run"
          fi
          if [ "${{ inputs.diff }}" == "true" ]; then
            ARGS="$ARGS --diff"
          fi
        fi

        # Run uptool
        echo "Running: $UPTOOL_CMD $CMD $ARGS"
        set -o pipefail
        $UPTOOL_CMD $CMD $ARGS 2>&1 | tee /tmp/uptool-output.txt
        EXIT_CODE=$?
        set +o pipefail

        if [ "$EXIT_CODE" -ne 0 ]; then
          echo "::error::uptool command failed with exit code $EXIT_CODE"
          exit "$EXIT_CODE"
        fi

        # Parse output to set outputs (use safer extraction with defaults)
        if grep -q "No updates available" /tmp/uptool-output.txt || grep -q "No manifests found" /tmp/uptool-output.txt; then
          echo "updates-available=false" >> "$GITHUB_OUTPUT"
          echo "manifests-updated=0" >> "$GITHUB_OUTPUT"
          echo "dependencies-updated=0" >> "$GITHUB_OUTPUT"
        else
          echo "updates-available=true" >> "$GITHUB_OUTPUT"

          # Extract counts from output (use grep -E for better compatibility)
          MANIFESTS=$(grep -oE '[0-9]+ manifests' /tmp/uptool-output.txt | grep -oE '[0-9]+' | head -1 || echo "0")
          DEPS=$(grep -oE '[0-9]+ (dependencies|updates)' /tmp/uptool-output.txt | grep -oE '[0-9]+' | awk '{s+=$1} END {print s+0}')

          # Ensure we always have numeric values
          MANIFESTS=${MANIFESTS:-0}
          DEPS=${DEPS:-0}

          echo "manifests-updated=$MANIFESTS" >> "$GITHUB_OUTPUT"
          echo "dependencies-updated=$DEPS" >> "$GITHUB_OUTPUT"
        fi

        # Exit successfully if uptool ran without errors
        exit 0

    - name: Generate detailed PR body
      if: inputs.create-pr == 'true' && steps.uptool.outputs.updates-available == 'true'
      id: pr-body
      shell: bash
      run: |
        # Change to workspace directory
        cd "$GITHUB_WORKSPACE"

        # Build config flag if specified
        CONFIG_FLAG=""
        if [ -n "${{ inputs.config }}" ]; then
          CONFIG_FLAG="--config=${{ inputs.config }}"
        fi

        # Run uptool plan with JSON output to get detailed update information
        $UPTOOL_CMD plan $CONFIG_FLAG --format=json > /tmp/plan-output.json

        # Generate PR body with detailed information
        cat > /tmp/pr-body.md <<'EOFMARKER'
        ## ğŸ“¦ Dependency Updates

        This PR updates dependencies to their latest versions.

        EOFMARKER

        # Parse JSON and create detailed tables per manifest
        jq -r '
          .plans[] |
          "### " + (.manifest.path | gsub("^\\./"; "")) + "\n\n" +
          "| Package | Update | Type | Links |\n" +
          "|---------|--------|------|-------|\n" +
          (
            .updates[] |
            "| **" + .dependency.name + "** | `" + .dependency.current_version + "` â†’ `" + .target_version + "` | " +
            (if .impact == "major" then "ğŸ”´ Major"
             elif .impact == "minor" then "ğŸŸ¡ Minor"
             elif .impact == "patch" then "ğŸŸ¢ Patch"
             else "âšª " + .impact end) +
            " | " +
            (if .changelog_url != "" and .changelog_url != null then
              "[Changelog](" + .changelog_url + ")"
             else
              "N/A"
             end) +
            " |\n"
          ) +
          "\n"
        ' /tmp/plan-output.json >> /tmp/pr-body.md

        # Add update statistics
        TOTAL_UPDATES=$(jq '[.plans[].updates[]] | length' /tmp/plan-output.json)
        MANIFEST_COUNT=$(jq '[.plans[]] | length' /tmp/plan-output.json)
        MAJOR_COUNT=$(jq '[.plans[].updates[] | select(.impact == "major")] | length' /tmp/plan-output.json)
        MINOR_COUNT=$(jq '[.plans[].updates[] | select(.impact == "minor")] | length' /tmp/plan-output.json)
        PATCH_COUNT=$(jq '[.plans[].updates[] | select(.impact == "patch")] | length' /tmp/plan-output.json)

        cat >> /tmp/pr-body.md <<EOFMARKER

        ---

        ### ğŸ“Š Update Summary

        - **Total updates:** $TOTAL_UPDATES
        - **Manifests affected:** $MANIFEST_COUNT
        - **Update types:** ğŸ”´ $MAJOR_COUNT major Â· ğŸŸ¡ $MINOR_COUNT minor Â· ğŸŸ¢ $PATCH_COUNT patch

        <details>
        <summary>â„¹ï¸ <strong>Update Type Definitions</strong></summary>

        - ğŸ”´ **Major** - Breaking changes may be introduced
        - ğŸŸ¡ **Minor** - New features, backwards compatible
        - ğŸŸ¢ **Patch** - Bug fixes and minor improvements

        </details>

        ### âœ… Checklist

        - [ ] Review all dependency changes
        - [ ] Check for breaking changes (especially major updates)
        - [ ] Verify tests pass
        - [ ] Update documentation if needed
        - [ ] Test in staging/development environment

        ### ğŸ”— Resources

        - [uptool Documentation](https://github.com/santosr2/uptool)
        - [Manifest-First Philosophy](https://github.com/santosr2/uptool#manifest-first)

        ---

        <sub>ğŸ¤– This PR was automatically generated by [uptool](https://github.com/santosr2/uptool)</sub>
        EOFMARKER

        # Output the PR body for the next step (escape for GitHub Actions)
        {
          echo 'pr-body<<EOF_PR_BODY_DELIMITER'
          cat /tmp/pr-body.md
          echo 'EOF_PR_BODY_DELIMITER'
        } >> $GITHUB_OUTPUT

    - name: Extract PR metadata from config
      if: inputs.create-pr == 'true' && steps.uptool.outputs.updates-available == 'true'
      id: pr-metadata
      shell: bash
      run: |
        # Change to workspace directory
        cd "$GITHUB_WORKSPACE"

        # Determine config file path
        CONFIG_FILE="${{ inputs.config }}"
        if [ -z "$CONFIG_FILE" ]; then
          CONFIG_FILE="uptool.yaml"
        fi

        # Initialize default values
        LABELS="dependencies,automated"
        ASSIGNEES=""
        REVIEWERS=""
        COMMIT_PREFIX=""

        # Extract metadata from config if it exists
        if [ -f "$CONFIG_FILE" ]; then
          # Extract labels from all integrations (combined)
          CONFIG_LABELS=$(yq -r '[.integrations[].policy.labels // []] | flatten | unique | join(",")' "$CONFIG_FILE" 2>/dev/null || echo "")
          if [ -n "$CONFIG_LABELS" ] && [ "$CONFIG_LABELS" != "null" ]; then
            LABELS="$CONFIG_LABELS"
          fi

          # Extract assignees from all integrations (combined)
          CONFIG_ASSIGNEES=$(yq -r '[.integrations[].policy.assignees // []] | flatten | unique | join(",")' "$CONFIG_FILE" 2>/dev/null || echo "")
          if [ -n "$CONFIG_ASSIGNEES" ] && [ "$CONFIG_ASSIGNEES" != "null" ]; then
            ASSIGNEES="$CONFIG_ASSIGNEES"
          fi

          # Extract reviewers from all integrations (combined)
          CONFIG_REVIEWERS=$(yq -r '[.integrations[].policy.reviewers // []] | flatten | unique | join(",")' "$CONFIG_FILE" 2>/dev/null || echo "")
          if [ -n "$CONFIG_REVIEWERS" ] && [ "$CONFIG_REVIEWERS" != "null" ]; then
            REVIEWERS="$CONFIG_REVIEWERS"
          fi

          # Extract commit message prefix (use first non-null)
          CONFIG_PREFIX=$(yq -r '[.integrations[].policy.commit_message.prefix // ""] | map(select(. != "")) | first // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
          if [ -n "$CONFIG_PREFIX" ] && [ "$CONFIG_PREFIX" != "null" ]; then
            COMMIT_PREFIX="$CONFIG_PREFIX"
          fi
        fi

        echo "labels=$LABELS" >> "$GITHUB_OUTPUT"
        echo "assignees=$ASSIGNEES" >> "$GITHUB_OUTPUT"
        echo "reviewers=$REVIEWERS" >> "$GITHUB_OUTPUT"
        echo "commit-prefix=$COMMIT_PREFIX" >> "$GITHUB_OUTPUT"

        echo "PR Metadata extracted:"
        echo "  Labels: $LABELS"
        echo "  Assignees: $ASSIGNEES"
        echo "  Reviewers: $REVIEWERS"
        echo "  Commit Prefix: $COMMIT_PREFIX"

    - name: Create Pull Request
      if: inputs.create-pr == 'true' && steps.uptool.outputs.updates-available == 'true'
      uses: peter-evans/create-pull-request@c5a7806660adbe173f04e3e038b0ccdcd758773c # v7.0.5
      with:
        token: ${{ inputs.token }}
        commit-message: "${{ steps.pr-metadata.outputs.commit-prefix && format('{0}: {1}', steps.pr-metadata.outputs.commit-prefix, inputs.pr-title) || inputs.pr-title }}"
        title: ${{ inputs.pr-title }}
        branch: ${{ inputs.pr-branch }}
        body: ${{ steps.pr-body.outputs.pr-body }}
        labels: ${{ steps.pr-metadata.outputs.labels }}
        assignees: ${{ steps.pr-metadata.outputs.assignees }}
        reviewers: ${{ steps.pr-metadata.outputs.reviewers }}

    - name: Generate issue body
      if: inputs.create-issue == 'true' && steps.uptool.outputs.updates-available == 'true'
      id: issue-body
      shell: bash
      run: |
        # Change to workspace directory
        cd "$GITHUB_WORKSPACE"

        # Build config flag if specified
        CONFIG_FLAG=""
        if [ -n "${{ inputs.config }}" ]; then
          CONFIG_FLAG="--config=${{ inputs.config }}"
        fi

        # Run uptool plan with JSON output to get detailed update information
        $UPTOOL_CMD plan $CONFIG_FLAG --format=json > /tmp/plan-output.json

        # Generate issue body
        cat > /tmp/issue-body.md <<'EOFMARKER'
        ## ğŸ”„ Dependency Updates Available

        Dependency scan found updates available for your project.

        EOFMARKER

        # Parse JSON and create detailed tables per manifest
        jq -r '
          .plans[] |
          "### " + (.manifest.path | gsub("^\\./"; "")) + "\n\n" +
          "| Package | Update | Type | Links |\n" +
          "|---------|--------|------|-------|\n" +
          (
            .updates[] |
            "| **" + .dependency.name + "** | `" + .dependency.current_version + "` â†’ `" + .target_version + "` | " +
            (if .impact == "major" then "ğŸ”´ Major"
             elif .impact == "minor" then "ğŸŸ¡ Minor"
             elif .impact == "patch" then "ğŸŸ¢ Patch"
             else "âšª " + .impact end) +
            " | " +
            (if .changelog_url != "" and .changelog_url != null then
              "[Changelog](" + .changelog_url + ")"
             else
              "N/A"
             end) +
            " |\n"
          ) +
          "\n"
        ' /tmp/plan-output.json >> /tmp/issue-body.md

        # Add update statistics
        TOTAL_UPDATES=$(jq '[.plans[].updates[]] | length' /tmp/plan-output.json)
        MANIFEST_COUNT=$(jq '[.plans[]] | length' /tmp/plan-output.json)
        MAJOR_COUNT=$(jq '[.plans[].updates[] | select(.impact == "major")] | length' /tmp/plan-output.json)
        MINOR_COUNT=$(jq '[.plans[].updates[] | select(.impact == "minor")] | length' /tmp/plan-output.json)
        PATCH_COUNT=$(jq '[.plans[].updates[] | select(.impact == "patch")] | length' /tmp/plan-output.json)

        cat >> /tmp/issue-body.md <<EOFMARKER

        ---

        ### ğŸ“Š Update Summary

        - **Total updates:** $TOTAL_UPDATES
        - **Manifests affected:** $MANIFEST_COUNT
        - **Update types:** ğŸ”´ $MAJOR_COUNT major Â· ğŸŸ¡ $MINOR_COUNT minor Â· ğŸŸ¢ $PATCH_COUNT patch

        <details>
        <summary>â„¹ï¸ <strong>Update Type Definitions</strong></summary>

        - ğŸ”´ **Major** - Breaking changes may be introduced
        - ğŸŸ¡ **Minor** - New features, backwards compatible
        - ğŸŸ¢ **Patch** - Bug fixes and minor improvements

        </details>

        ### ğŸ“‹ Next Steps

        1. Review the dependency changes above
        2. Check changelogs for breaking changes (especially major updates)
        3. Run \`uptool plan\` locally to review planned updates
        4. Apply updates: \`uptool update\`
        5. Test your application
        6. Create a PR with the changes

        ### ğŸ”— Resources

        - [uptool Documentation](https://github.com/santosr2/uptool)
        - [Manifest-First Philosophy](https://github.com/santosr2/uptool#manifest-first)

        ---

        <sub>ğŸ¤– This issue was automatically created by [uptool](https://github.com/santosr2/uptool)</sub>
        EOFMARKER

        # Output the issue body for the next step (escape for GitHub Actions)
        {
          echo 'issue-body<<EOF_ISSUE_BODY_DELIMITER'
          cat /tmp/issue-body.md
          echo 'EOF_ISSUE_BODY_DELIMITER'
        } >> $GITHUB_OUTPUT

    - name: Create or Update Issue
      if: inputs.create-issue == 'true' && steps.uptool.outputs.updates-available == 'true'
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
      env:
        ISSUE_TITLE: ${{ inputs.issue-title }}
        ISSUE_BODY: ${{ steps.issue-body.outputs.issue-body }}
        ISSUE_LABELS: ${{ inputs.issue-labels }}
      with:
        github-token: ${{ inputs.token }}
        script: |
          const issueTitle = process.env.ISSUE_TITLE;
          const issueBody = process.env.ISSUE_BODY;
          const labelString = process.env.ISSUE_LABELS || '';
          const labels = labelString.split(',').map(l => l.trim()).filter(l => l);

          // Search for existing open issue with the same title
          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            per_page: 100
          });

          const existingIssue = issues.data.find(issue =>
            issue.title === issueTitle
          );

          if (existingIssue) {
            // Update existing issue with a comment
            const updateDate = new Date().toISOString().slice(0, 10);
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssue.number,
              body: `### ğŸ”„ Update (${updateDate})\n\n${issueBody}`
            });

            console.log(`Updated existing issue #${existingIssue.number}`);
          } else {
            // Create new issue
            const newIssue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: labels
            });

            console.log(`Created new issue #${newIssue.data.number}`);
          }
