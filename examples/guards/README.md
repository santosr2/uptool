# Custom Auto-Merge Guards

This directory contains examples of custom guard implementations for uptool's auto-merge feature.

## Overview

Guards are pluggable checks that determine whether a Pull Request is ready for auto-merge. uptool provides built-in guards, but you can also create custom guards to implement organization-specific workflows.

## Built-in Guards

The following guards are provided out-of-the-box:

- **`ci-green`**: All CI checks must pass (SUCCESS or SKIPPED)
- **`codeowners-approve`**: Repository codeowners must approve the PR
- **`security-scan`**: Security scans (CodeQL, Trivy, SAST) must pass

## Code Generation

uptool uses code generation to automatically maintain the guard registry. When you add a new built-in guard, the generator discovers it and updates the registration file.

### How It Works

1. **Generator Script**: `scripts/gen_guards.go` scans `internal/policy/guards/builtin/` for guard files
2. **Generated File**: `internal/policy/guards/builtin/all.go` lists all discovered guards
3. **Build Integration**: The `mise run build` task automatically runs code generation

### Generated File

The generated `all.go` file contains documentation listing all discovered guards:

```go
// Code generated by scripts/gen_guards.go. DO NOT EDIT.

// Package builtin registers all built-in auto-merge guards.
// The guards are registered via init() functions in their individual files:
//   - ci_green.go
//   - codeowners.go
//   - security_scan.go
package builtin

// This file intentionally blank - guard registration happens via init() functions
// in individual guard files.
```

### Triggering Generation

Three ways to regenerate the guard registry:

```bash
# 1. Via go generate (recommended)
go generate ./internal/policy/guards

# 2. Via generator script directly
go run scripts/gen_guards.go

# 3. Via mise task (runs both integrations and guards)
mise run generate
```

The build process (`mise run build`) automatically runs generation before compiling.

### Adding Built-in Guards

To add a new built-in guard:

1. Create `internal/policy/guards/builtin/my_guard.go`
2. Implement the `Guard` interface with `Name()`, `Description()`, `Check()` methods
3. Add `init()` function that calls `guards.Register(&MyGuard{})`
4. Run `go generate ./internal/policy/guards` to update `all.go`
5. The guard is now automatically included and available by name

**Example**:

```bash
# Create new built-in guard
cat > internal/policy/guards/builtin/jira_linked.go <<'EOF'
package builtin

import (
    "context"
    "github.com/santosr2/uptool/internal/policy/guards"
)

type JiraLinkedGuard struct{}

func init() {
    guards.Register(&JiraLinkedGuard{})
}

func (g *JiraLinkedGuard) Name() string {
    return "jira-linked"
}

func (g *JiraLinkedGuard) Description() string {
    return "Verifies that the PR is linked to a JIRA ticket"
}

func (g *JiraLinkedGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {
    // Implementation here
    return true, nil
}
EOF

# Regenerate registry
go generate ./internal/policy/guards

# Verify the guard appears in all.go
git diff internal/policy/guards/builtin/all.go
```

## Creating Custom Guards

Custom guards are user-defined guards that live outside the uptool codebase. They're perfect for organization-specific workflows.

### 1. Implement the Guard Interface

Create a Go file implementing the `guards.Guard` interface:

```go
package custom

import (
    "context"
    "github.com/santosr2/uptool/internal/policy/guards"
)

type MyCustomGuard struct{}

// Name returns the unique identifier for this guard
func (g *MyCustomGuard) Name() string {
    return "my-custom-guard"
}

// Description returns a human-readable description
func (g *MyCustomGuard) Description() string {
    return "Checks my custom approval workflow"
}

// Check executes the guard logic
func (g *MyCustomGuard) Check(ctx context.Context, env *guards.Environment) (bool, error) {
    // Your custom logic here
    // Return true if guard is satisfied, false otherwise
    return true, nil
}
```

### 2. Register the Guard

Register your guard in an `init()` function:

```go
func init() {
    guards.Register(&MyCustomGuard{})
}
```

### 3. Import the Guard Package

There are two ways to use your custom guard:

#### Option A: Modify uptool source

Import your guard package in `internal/policy/enforcement.go`:

```go
import (
    _ "github.com/santosr2/uptool/examples/guards/custom" // Your custom guards
    _ "github.com/santosr2/uptool/internal/policy/guards/builtin"
)
```

Then rebuild uptool:

```bash
go build -o uptool ./cmd/uptool
```

#### Option B: Go Plugin (Future)

In a future release, uptool will support loading guards as Go plugins (`.so` files) without modifying the source:

```bash
# Build your guard as a plugin
go build -buildmode=plugin -o my_guard.so custom/my_guard.go

# Load it via configuration
export UPTOOL_GUARD_PLUGINS="./my_guard.so"
```

## Using Custom Guards

### 1. Add to Configuration

Add your custom guard to `uptool.yaml`:

```yaml
org_policy:
  auto_merge:
    enabled: true
    guards:
      - "ci-green"                # Built-in guard
      - "codeowners-approve"      # Built-in guard
      - "my-custom-guard"         # Your custom guard
      - "slack-approval"          # Example custom guard
```

### 2. Run the Check

```bash
uptool check-policy
```

## Example: Slack Approval Guard

See `custom/slack_approval.go` for a complete example that:

- Checks if a PR has been approved via Slack thumbs-up reaction
- Uses external APIs (Slack)
- Reads custom environment variables (`SLACK_BOT_TOKEN`, `SLACK_CHANNEL_ID`)

### Usage

```yaml
org_policy:
  auto_merge:
    enabled: true
    guards:
      - "slack-approval"
```

Set environment variables:

```bash
export SLACK_BOT_TOKEN="xoxb-your-token"
export SLACK_CHANNEL_ID="C01234567"
export GITHUB_TOKEN="ghp_your_token"
export GITHUB_REPOSITORY="owner/repo"
export GITHUB_PR_NUMBER="123"

uptool check-policy
```

## Guard Environment

Custom guards receive a `guards.Environment` struct with GitHub context:

```go
type Environment struct {
    GitHubRepo     string // Format: "owner/repo"
    GitHubToken    string // GitHub API token
    GitHubPRNumber string // PR number (validated numeric)
}
```

## Best Practices

1. **Validate inputs**: Always validate environment variables and API responses
2. **Use timeouts**: Set reasonable timeouts for external API calls
3. **Handle errors gracefully**: Return meaningful errors to help debugging
4. **Security**: Never log sensitive tokens or credentials
5. **Documentation**: Add clear descriptions in `Description()` method
6. **Testing**: Write tests for your custom guards

## List Available Guards

To see all registered guards (built-in + custom):

```bash
# This will be added in a future PR
uptool guards list
```

## Troubleshooting

### Guard not found

```text
Error: unknown guard: my-custom-guard
```

**Solution**: Ensure your guard package is imported and `init()` registers it.

### Guard always fails

Check the guard's error message in the output:

```bash
uptool check-policy
```

Look for lines like:

```text
âŒ Auto-merge guards: FAILED
   - guard "my-custom-guard" error: SLACK_BOT_TOKEN not set
```

## Contributing

If you create a useful custom guard, consider contributing it as a built-in guard by submitting a PR!

1. Move your guard to `internal/policy/guards/builtin/`
2. Add tests in `internal/policy/guards/builtin/*_test.go`
3. Update documentation
4. Submit PR

## License

All example guards are MIT licensed. Feel free to use them as templates for your own custom guards.
